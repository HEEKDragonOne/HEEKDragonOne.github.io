

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://img-blog.csdnimg.cn/a458bf114f6f4912953f8b73eab00580.png">
  <link rel="icon" href="https://img-blog.csdnimg.cn/a458bf114f6f4912953f8b73eab00580.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="墨水记忆">
  
  <meta name="author" content="DragonOne">
  <meta name="keywords" content="">
  
    <meta name="baidu-site-verification" content="code-9Ovxk6LCbY" />
  
  <title>JAVA基础知识复习(一)-正文 - 墨水记忆</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"tothefor.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"952d55c20fecac468ce267fb5ef10df9","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"jx7bocft2eNXc79VRkkkNmhT-gzGzoHsz","app_key":"tL3DrseUcom3imP7y6HAnTfh","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="墨水记忆" type="application/atom+xml">
</head>



<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>墨水记忆</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友情链接
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                文档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/databases/">
                    
                    资料库
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/javaProject/">
                    
                    Java项目
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/comment/">
                <i class="iconfont icon-comment"></i>
                留言板
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img-blog.csdnimg.cn/af560031e20c4a8f8d05ed9f18fe4ef3.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JAVA基础知识复习(一)-正文">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      DragonOne
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-09 13:43" pubdate>
        April 9, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      100
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    <!--动态线条背景-->
<!-- <script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script> -->

    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JAVA基础知识复习(一)-正文</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：December 3, 2021 pm
                
              </p>
            
            <div class="markdown-body">
              <p>JAVA基础知识简单复习一。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1.基本框架"></a>1.基本框架</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建文件 HelloWorld.java(文件名需与类名一致)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注：String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读。</span><br></code></pre></div></td></tr></table></figure>
<h4 id="1-1程序编译和运行"><a href="#1-1程序编译和运行" class="headerlink" title="1.1程序编译和运行"></a>1.1程序编译和运行</h4><p>在java环境文件夹目录下打开cmd(或者打开cmd后cd到java的环境文件夹中也行)。输入命令：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">javac HelloWorld.java <span class="hljs-comment">//编译</span><br>java HelloWorld <span class="hljs-comment">//运行。需要注意的是java命令后面不需要加.class</span><br></code></pre></div></td></tr></table></figure>

<hr>
<h3 id="2-java三大特性"><a href="#2-java三大特性" class="headerlink" title="2.java三大特性"></a>2.java三大特性</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问优点：减少耦合，代码重用，减轻维护<br>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br>多态：指允许不同类的对象对同一消息做出响应。<span class="hljs-comment">//只适用于方法，而不适用于属性。</span><br><span class="hljs-comment">//多态性</span><br><span class="hljs-comment">//针对方法：编译看左，运行看右。针对属性：编译和运行都看左。</span><br></code></pre></div></td></tr></table></figure>
<p>多态一般分为编译时多态和运行时多态，编译时主要指方法的重载；运行时主要指程序中定义的对象引用所指向的具体类型在运行期间才确定</p>
<p>运行时多态有三个条件：继承、覆盖和重写、向上转型（父类引用指向子类对象）</p>
<hr>
<h3 id="3-java六大原则"><a href="#3-java六大原则" class="headerlink" title="3.java六大原则"></a>3.java六大原则</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>开闭原则：对扩展开发放，对修改关闭，要求在添加新功能时不需要修改代码，符合开闭原则最典型的设计模式是装饰者模式<br><span class="hljs-number">2.</span>单一职责原则：一个类只负责一件事，尽量使用合成/聚合的方式，而不是使用继承。<br><span class="hljs-number">3.</span>里式替换原则 ：任何基类可以出现的地方，子类一定可以出现。<br><span class="hljs-number">4.</span>依赖倒转原则：依赖于抽象而不依赖于具体<br><span class="hljs-number">5.</span>接口隔离原则：使用多个隔离的接口，比使用单个接口要好 ，不应该强迫客户依赖于它们不用的方法。<br><span class="hljs-number">6.</span>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。<br></code></pre></div></td></tr></table></figure>

<hr>
<h3 id="4-JAVA关键字"><a href="#4-JAVA关键字" class="headerlink" title="4.JAVA关键字"></a>4.JAVA关键字</h3><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td>私有的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">protected</td>
<td>受保护的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">public</td>
<td>公共的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td>默认</td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td>声明抽象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">class</td>
<td>类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">extends</td>
<td>扩充,继承</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">final</td>
<td>最终值,不可改变的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">implements</td>
<td>实现（接口）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">interface</td>
<td>接口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">native</td>
<td>本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">new</td>
<td>新,创建</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">static</td>
<td>静态</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">strictfp</td>
<td>严格,精准</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">synchronized</td>
<td>线程,同步</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">transient</td>
<td>短暂</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">volatile</td>
<td>易失</td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td>跳出循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">case</td>
<td>定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">continue</td>
<td>继续</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td>默认</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">do</td>
<td>运行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">else</td>
<td>否则</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">for</td>
<td>循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">if</td>
<td>如果</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">instanceof</td>
<td>实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">return</td>
<td>返回</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">switch</td>
<td>根据值选择执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">while</td>
<td>循环</td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td>断言表达式是否为真</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">catch</td>
<td>捕捉异常</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">finally</td>
<td>有没有异常都执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throw</td>
<td>抛出一个异常对象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throws</td>
<td>声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">try</td>
<td>捕获异常</td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td>引入</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">package</td>
<td>包</td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td>布尔型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">byte</td>
<td>字节型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">char</td>
<td>字符型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">double</td>
<td>双精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">float</td>
<td>单精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int</td>
<td>整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">long</td>
<td>长整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">short</td>
<td>短整型</td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td>父类,超类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">this</td>
<td>本类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void</td>
<td>无返回值</td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td>是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">const</td>
<td>是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">null</td>
<td>空</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-java注释"><a href="#5-java注释" class="headerlink" title="5.java注释"></a>5.java注释</h3><p>支持单行以及多行注释。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这是单行注释的示例</span><br><span class="hljs-comment">/* 这个也是单行注释的示例 */</span><br><span class="hljs-comment">/* 这是第一个Java程序</span><br><span class="hljs-comment">    * 它将输出 Hello World</span><br><span class="hljs-comment">    * 这是一个多行注释的示例</span><br><span class="hljs-comment">    */</span><br></code></pre></div></td></tr></table></figure>

<hr>
<h3 id="6-方法重载和重写的区别"><a href="#6-方法重载和重写的区别" class="headerlink" title="6.方法重载和重写的区别"></a>6.方法重载和重写的区别</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重写：发生在继承类中，方法名和参数列表相同，重写有以下三个限制：<br><span class="hljs-number">1.</span>子类方法的访问权限必须大于等于父类方法。<br><span class="hljs-number">2.</span>子类方法的返回类型必须是父类方法返回类型或为其子类型。如父类为<span class="hljs-keyword">void</span>，则子类也只能为<span class="hljs-keyword">void</span>。<br><span class="hljs-number">3.</span>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。即子类抛出的异常类型不大于父类的异常类型。<br></code></pre></div></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重载：发生在同一个类中，方法名相同，参数列表不同（个数、类型、顺序），与权限修饰、返回值类型、抛出异常无关。<br></code></pre></div></td></tr></table></figure>
<p>注意：构造器是不可以被重写的，但是能重载。<br>构造方法的特性：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>名字与类名相同。<br><span class="hljs-number">2.</span>没有返回值，但不能用<span class="hljs-keyword">void</span>声明构造函数。<br><span class="hljs-number">3.</span>生成类的对象时自动执行，无需调用。<br></code></pre></div></td></tr></table></figure>

<hr>
<h3 id="7-常用修饰符特性"><a href="#7-常用修饰符特性" class="headerlink" title="7.常用修饰符特性"></a>7.常用修饰符特性</h3><p>Java中有4中访问权限的修饰符：private、default（(默认一般省略）、public、protected。一般用于对类或类中的成员（字段以及方法）加上访问修饰符。<br>权限的主要作用范围：同一个类中、同一个包下、父子类、不同的包<br>可被修饰对象：类和成员变量；类可见表示其它类可以用这个类创建实例对象；成员可见表示其它类可以用这个类的实例对象访问到该成员。<br>4种修饰符的权限范围：</p>
<blockquote>
<ul>
<li>private：指”私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问</li>
<li>default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。</li>
<li>protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li>
<li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>很容易看出，权限范围从小到大依次为：private &lt; default &lt; protected &lt; public</p>
<h4 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h4><p>final</p>
<hr>
<p>在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p>
<ul>
<li>修饰变量：表示常量，对于基本类型，final 使数值不变；对于引用类型，final 使引用地址不变，但对象本身的属性是可以被修改的。</li>
<li>修饰方法：不能被子类的方法重写，但可以被继承，不能修饰构造方法。。</li>
<li>修饰类 ：该不能被继承，没有子类，final类中的方法默认是final的。Java中的String类就是一个final类</li>
</ul>
<p>static</p>
<hr>
<p>在Java语言中，static 可以用来修饰成员变量和成员方法，当然也可以是静态代码块</p>
<ul>
<li>静态变量：又称为类变量，该类的所有实例都共享本类的静态变量，且在内存中只存在一份</li>
<li>静态方法：在类加载的时候就存在了，它不依赖于任何实例，只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字（此时可能没有实例）。</li>
<li>静态语句块：在类初始化时运行一次。</li>
<li>静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</li>
</ul>
<p>需要注意的是：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>静态变量，静态方法可以通过类名直接访问<br><span class="hljs-number">2.</span>初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。（此处不演示，在类初始化篇章中演示）<br></code></pre></div></td></tr></table></figure>
<p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h4 id="成员变量、静态变量、局部变量的区别"><a href="#成员变量、静态变量、局部变量的区别" class="headerlink" title="成员变量、静态变量、局部变量的区别"></a>成员变量、静态变量、局部变量的区别</h4><p>从生命周期比较：</p>
<ul>
<li><p>静态变量可以被对象调用，也可以被类名调用。以static关键字申明的变量，其独立在对象之外，有许多对象共享的变量。在对象产生之前产生，存在于方法区静态区中。</p>
</li>
<li><p>成员变量只能被对象调用。随着对象创建而存在，随对象销毁而销毁。存在于堆栈内存中</p>
</li>
<li><p>局部变量在方法或语句块中申明的变量，生命周期只在定义的{}之中，不能跨方法或语句块使用。</p>
</li>
</ul>
<p>从访问权限比较：</p>
<ul>
<li><p>静态变量称为对象的共享数据，成员变量可以称为对象的特有数据，局部变量为方法所有</p>
</li>
<li><p>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p>
</li>
</ul>
<h4 id="abstract-和-interface"><a href="#abstract-和-interface" class="headerlink" title="abstract 和 interface"></a>abstract 和 interface</h4><h5 id="1-abstract"><a href="#1-abstract" class="headerlink" title="1.abstract"></a>1.abstract</h5><p>在 Java 中 abstract 即抽象，一般使用 abstract 关键字修饰的类或方法。<br>修饰的类时，一定有构造器（构造函数），便于子类实例化时调用。</p>
<blockquote>
<p>1.不能被实例化，需要继承抽象类后才能实例化其子类。<br>2.访问权限可以使用public、private、protected，其表达形式为：（public）abstract class 类名{}<br>3.抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承<br>4.可以定义构造方法、静态方法、普通方法；非抽象的普通成员变量、静态成员变量</p>
</blockquote>
<p>修饰的方法时，只需要声明方法，不需要写方法体（大括号也不写）。</p>
<blockquote>
<p>1.含有该抽象方法的类必须定义为抽象类，但抽象类可以没有抽象方法。<br>2.访问权限可以使用public、default、protected，不能为private，因为抽象方法必须被子类实现（覆写），而private权限对于子类来 说是不能访问的，所以就会产生矛盾，<br>3.不能用static修饰，因为没有主体<br>4.若子类没有重写父类中的所有抽象方法，则此子类必须也是一个抽象类，用abstract修饰；否则必须全部重写父类中的抽象类方法。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyAbstract</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> String name=<span class="hljs-string">&quot;小米&quot;</span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price= <span class="hljs-number">1800</span>;<br>	<br>	MyAbstract(String name)&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(name);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(price);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//权限不能为 private //抽象方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>abstract使用注意点：</strong></p>
<blockquote>
<p>1.abstract 不能用来修饰 属性、构造器等结构。<br>2.abstract 不能用来修饰 私有方法、静态方法、final的方法、final的类。</p>
</blockquote>
<h5 id="2-interface"><a href="#2-interface" class="headerlink" title="2.interface"></a>2.interface</h5><p>在 Java中 interface 即接口，是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，Java 8 开始，接口也可以拥有default的方法实现，是因为不支持默认方法的接口的维护成本太高。</p>
<blockquote>
<p>1.接口的方法访问权限只能为 public ，Java 8可以为default，但是必须有方法体<br>2.接口的方法默认public abstract 也可以由 static 修饰<br>3.接口的方法可以定义为 public static ，但是必须有方法体，且只能有接口类名调用<br>4.成员变量默认为public staic final</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">MyInterface</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> price = <span class="hljs-number">1800</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;MyInterface print： default Method&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;MyInterface price=&quot;</span>+price);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span> </span>&#123;<br>		 System.out.println(<span class="hljs-string">&quot;I&#x27;m a MyInterfaceImpl&quot;</span>);<br>	&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		MyInterface my = <span class="hljs-keyword">new</span> MyInterfaceImpl();<br>		my.outName();<br>		my.print();<br><span class="hljs-comment">//		MyInterfaceImpl.print();// 实现类类名调用时， 提示编译错误</span><br>		MyInterface.price();<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="3-abstract-和-interface-的区别"><a href="#3-abstract-和-interface-的区别" class="headerlink" title="3.abstract 和 interface 的区别"></a>3.abstract 和 interface 的区别</h5><p>从定义分析</p>
<ul>
<li><p>抽象类和接口都不能直接实例化；抽象方法必须由子类来进行重写</p>
</li>
<li><p>抽象类单继承，接口多实现</p>
</li>
<li><p>抽象类可有构造方法，普通成员变量，非抽象的普通方法，静态方法</p>
</li>
<li><p>抽象类的抽象方法访问权限可以为：public、protected 、default</p>
</li>
<li><p>接口中变量类型默认public staic final，</p>
</li>
<li><p>接口中普通方法默认public abstract，没有具体实现</p>
</li>
<li><p>jdk1.8 中接口可有静态方法和default（有方法体）方法</p>
</li>
</ul>
<p>从应用场合分析</p>
<ul>
<li>接口：需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li>
<li>抽象类：1、在既需要统一的接口，又需要实例变量或缺省的方法的情况下就可以使用它；2、定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口</li>
</ul>
<h4 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h4><p>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>
<h4 id="受保护的修饰符-protected"><a href="#受保护的修饰符-protected" class="headerlink" title="受保护的修饰符-protected"></a>受保护的修饰符-protected</h4><ul>
<li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。<br>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。接口及接口的成员变量和成员方法不能声明为 protected。<br>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。<h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4>注意以下方法继承的规则：<blockquote>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p>1.static 修饰符，用来修饰类方法和类变量。<br>2.final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br>3.abstract 修饰符，用来创建抽象类和抽象方法。<br>4.synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h5 id="1-static-修饰符"><a href="#1-static-修饰符" class="headerlink" title="1.static 修饰符"></a>1.static 修饰符</h5><p>可以用来修饰：属性、方法、代码块、内部类。</p>
<ul>
<li>静态变量：<br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li>
<li>静态方法：<br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li>
</ul>
<p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p>
<p>使用 类.方法 或 对象.方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>对象</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        p it = <span class="hljs-keyword">new</span> p();<br>        p.eat();<br><span class="hljs-comment">//      p.sleep(); //不能通过类访问非静态方法</span><br>        it.eat();<br>        it.sleep();<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">p</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String s;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃完了&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉了&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>吃完了<br>吃完了<br>睡觉了<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>静态方法中：只能调用静态方法或属性。在静态方法内不能使用 this、super关键字。<br>非静态方法中：既可以调用非静态方法或属性，也可以调用静态的方法或属性。</p>
</blockquote>
<h5 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2.final修饰符"></a>2.final修饰符</h5><p>可以修饰：类、方法、变量。</p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。<br>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p>变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量。初始化时，可以在代码块中初始化、构造器中初始化。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> l;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> r;<br>&#123;<br>l=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>	r=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>final 也可以在形参中修饰，但被修饰的值在函数中不能改变，只能调用。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>	<span class="hljs-comment">//n=20; 不可以改变值</span><br>	System.out.println(n);<span class="hljs-comment">//可以正常输出</span><br>&#125;<br></code></pre></div></td></tr></table></figure>


<h5 id="3-abstract-修饰符"><a href="#3-abstract-修饰符" class="headerlink" title="3.abstract 修饰符"></a>3.abstract 修饰符</h5><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。<br>抽象类可以包含抽象方法和非抽象方法。</p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>抽象方法不能被声明成 final 和 static。<br>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。<br>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。<br>抽象方法的声明以分号结尾，例如：public abstract sample();。</p>
<h5 id="4-synchronized-修饰符"><a href="#4-synchronized-修饰符" class="headerlink" title="4.synchronized 修饰符"></a>4.synchronized 修饰符</h5><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h5 id="5-transient-修饰符"><a href="#5-transient-修饰符" class="headerlink" title="5.transient 修饰符"></a>5.transient 修饰符</h5><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<h5 id="6-volatile-修饰符"><a href="#6-volatile-修饰符" class="headerlink" title="6.volatile 修饰符"></a>6.volatile 修饰符</h5><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>一个 volatile 对象引用可能是 null。</p>
<hr>
<h3 id="8-数据类型"><a href="#8-数据类型" class="headerlink" title="8.数据类型"></a>8.数据类型</h3><p>Java 语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。并且还提供了其对应的引用类型。</p>
<h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>在 Java 中是用 unicode来表示字符，所以 2 个字节来表示一个字符； 一个数字或英文或汉字都是一个字符，只不过数字和英文时，存储的2个字节的第一个字节都为0，就是浪费了点空间。存汉字就占满了2个字节。</p>
<h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>在 Java 基本类型中只有两个状态，true、false，理论上只占一个字节，但是实际如下：</p>
<ul>
<li>单个的boolean类型变量在编译的时候是使用的 int 类型，即 boolean a = true 时，这个a在 JVM 中占用 4 个字节，即32位；</li>
<li>boolean类型的数组时，在编译时是作为byte array来编译的。所以，boolean数组里的每一个元件占用一个字节；即 boolean[] b = new boolean[10] 的数组时，每一个boolean在 JVM中占一个字节；</li>
</ul>
<p><strong>注意</strong>： float 和 double 都不能表示精确的值，所以一般不能用在计算货币，要想精度不失效，可以使用 BigDecimal</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Java 中引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p>
<ul>
<li>对象、数组都是引用数据类型；</li>
<li>所有引用类型的默认值都是null；</li>
<li>一个引用变量可以用来引用任何与之兼容的类型<br>我们的基本类型都有对应的引用类型，且基本类型与其对应的引用类型之间的赋值使用自动装箱与拆箱完成<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4></li>
</ul>
<p>也可见 《JAVA基础知识复习(八)-包装类、装箱拆箱》博客内容。</p>
<p>自动拆箱：故名思议就是将对象重新转化为基本数据类型；是享元模式（flyweight）</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer num = <span class="hljs-number">10</span>;	<span class="hljs-comment">//装箱</span><br><span class="hljs-keyword">int</span> num1 = num;	<span class="hljs-comment">//拆箱</span><br></code></pre></div></td></tr></table></figure>
<p>基本数据类型和引用数据类型区别</p>
<ul>
<li>基本数据类型在被创建时，数值直接存储在栈上。</li>
<li>引用数据类型在被创建时，对象的具体信息都存储在堆内存上，对象的引用地址存储在栈上</li>
</ul>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 不可变，String 类型 是一个final修饰的类型。因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。<br>String 不可变的好处</p>
<ul>
<li>可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 经常作为参数，String 不可变性可以保证参数不可变。</li>
</ul>
<h4 id="String赋值"><a href="#String赋值" class="headerlink" title="String赋值"></a>String赋值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s5 == s6);  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。而不是象new一样放在压缩堆中；当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值为”bbb”的对象，</p>
<ul>
<li>如果有：就会把它赋给当前引用。即原来那个引用和现在这个引用指点向了同一对象,</li>
<li>如果没有：则在常量池中新创建一个”bbb”,<br>下一次如果有String s2 = “bbb”；又会将s2指向”abcd”这个对象；即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象.</li>
</ul>
<p>而String s = new String(“abcd”);和其它任何对象一样，每调用一次就产生一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码1  </span><br>String sa = <span class="hljs-string">&quot;ab&quot;</span>;                                          <br>String sb = <span class="hljs-string">&quot;cd&quot;</span>;                                       <br>String sab=sa+sb;                                      <br>String s=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sab==s); <span class="hljs-comment">// false  </span><br><span class="hljs-comment">//当执行sa+sb时，JVM首先会在堆中创建一个StringBuilder类，将刚生成的String对象的堆地址存放在局部变量sab中</span><br><span class="hljs-comment">//局部变量 s 存储的是常量池中&quot;abcd&quot;所对应的拘留字符串对象的地址</span><br><br><span class="hljs-comment">//代码2  </span><br>String sc=<span class="hljs-string">&quot;ab&quot;</span>+<span class="hljs-string">&quot;cd&quot;</span>;  <br>String sd=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sc==sd); <span class="hljs-comment">//true  </span><br><span class="hljs-comment">//&quot;ab&quot;+&quot;cd&quot;会直接在编译期就合并成常量&quot;abcd&quot;， 因此相同字面值常量&quot;abcd&quot;所对应的是同一个拘留字符串对象，自然地址也就相同。</span><br></code></pre></div></td></tr></table></figure>
<p>扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p>这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<h4 id="String、StringBuffer、-StringBuilder的区别"><a href="#String、StringBuffer、-StringBuilder的区别" class="headerlink" title="String、StringBuffer、 StringBuilder的区别"></a>String、StringBuffer、 StringBuilder的区别</h4><ul>
<li>从运行速度上说，StringBuilder&gt;StringBuffer&gt;String，因为String是不可变的对象</li>
<li>String：是字符串常量（由final修饰），StringBuffer和StringBuilder 是字符串变量</li>
<li>StringBuffer：有同步锁，但效率低，适用于多线程下字符缓冲区进行大量操作。</li>
<li>StringBuilder：效率高，线程不安全，适用于单线程下的字符缓冲区进行大量操作的情况；</li>
</ul>
<p>StringBuffer 和 StringBuilder 能大量操作字符的原理<br>在append是后，采用了Arrays.copyOf（） 进行了数组复制</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    toStringCache = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">super</span>.append(String.valueOf(obj));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// AbstractStringBuilder 类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-keyword">int</span> len = str.length();<br>    ensureCapacityInternal(count + len); <span class="hljs-comment">// 采用复制方式增加数组长度</span><br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        value = Arrays.copyOf(value,<br>                              newCapacity(minimumCapacity));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><ul>
<li>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</li>
<li>String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br>String s3 = s1.intern();<br>String s4 = s2.intern();<br>System.out.println(s3 == s4);           <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
String#intern 方法：intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中返回这个新字符串的引用，若存在（使用 equals() 方法进行确定）那么就会返回 String Pool 中字符串的引用；</li>
</ul>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h4 id="String-常用方法"><a href="#String-常用方法" class="headerlink" title="String 常用方法"></a>String 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span> <span class="hljs-comment">//测试此字符串是否以指定的后缀结束</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<span class="hljs-comment">//返回指定索引处的 char 值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span>   </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar,<span class="hljs-keyword">char</span> newChar)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>在 Java 中 Object 是所有的祖类。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br></code></pre></div></td></tr></table></figure>
<p>equals()</p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。<h4 id="“-”和equals的区别"><a href="#“-”和equals的区别" class="headerlink" title="“==”和equals的区别"></a>“==”和equals的区别</h4>==： 用来判断两个对象的内存地址是否相同（比较的是变量(栈)内存中存放的对象的(堆)内存地址，）。比较的是真正意义上的指针操作。</li>
</ul>
<p>equals：用来比较的是两个对象的内容是否相等。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s1 为一个引用</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s2 为另一个引用,对象的内容一样</span><br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>String s4 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// true</span><br>System.out.println(s1 == s3); <span class="hljs-comment">// false</span><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>System.out.println(s3.equals(s4)); <span class="hljs-comment">// true</span><br>System.out.println(s1.equals(s3)); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>对equals重新需要注意五点：</p>
<blockquote>
<p>1 自反性：对任意引用值X，x.equals(x)的返回值一定为true；<br>2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；<br>3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；<br>4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；<br>5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p>
</blockquote>
<p><strong>注意</strong><br>自定义的类用equals比较时，仍然用的 == 在比较。因为自定义类默认继承的Object类中的equals方法，而Object类中的equals方法用的是 == 在比较。Object类中的equals方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>可以看见，用的是 == 来比较。所以，也是比较的地址值。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Man p = <span class="hljs-keyword">new</span> Man(<span class="hljs-number">12</span>,<span class="hljs-string">&quot;abcdef&quot;</span>); <span class="hljs-comment">//这里的Man为自定义类</span><br>        Man p1= <span class="hljs-keyword">new</span> Man(<span class="hljs-number">12</span>,<span class="hljs-string">&quot;abcdef&quot;</span>);<br>        System.out.println(p.equals(p1));<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;qwer&quot;</span>);<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;qwer&quot;</span>);<br>        System.out.println(s1.equals(s2));<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure>
<p>String 类中的equals 方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//注释为作者自加，并不是String类中所有的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123; <span class="hljs-comment">//首先比较两个的地址，如果地址都相同，那么内容一定是相同的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123; <span class="hljs-comment">//看两个是不是String类或String类的父类之一，不一定都一样。可以自行建两个类测试。是其之一才比较，不是就不需要比较了</span><br>            String aString = (String)anObject; <span class="hljs-comment">//把两个都转换成相同的String类</span><br>            <span class="hljs-keyword">if</span> (!COMPACT_STRINGS || <span class="hljs-keyword">this</span>.coder == aString.coder) &#123;<br>                <span class="hljs-keyword">return</span> StringLatin1.equals(value, aString.value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>要想实现自定义类的 equals 方法比较值，而不是比较地址，可以重写 equals 方法。具体写法可以参考 Object 类和 String 类的equals 方法。</strong></p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>所以：在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<h4 id="hashCode（）与equals（）"><a href="#hashCode（）与equals（）" class="headerlink" title="hashCode（）与equals（）"></a>hashCode（）与equals（）</h4><p>1.如果两个对象相等，则hashcode一定也是相同的<br>2.两个对象相等,对两个对象分别调用equals方法都返回true<br>3.两个对象有相同的hashcode值，它们也不一定是相等的<br>4.因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>5.hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<p>克隆（clone方法）为浅拷贝<br>1.浅拷贝：对基本数据类型进行值拷贝，对引用数据类型的引用地址进行拷贝，拷贝对象和原始对象的引用类型引用同一个对象</p>
<p>2.深拷贝： 对基本数据类型进行值拷贝，对引用数据类型的内容进行拷贝，拷贝对象和原始对象的引用类型引用不同对象。</p>
<p>深拷贝实现：</p>
<ul>
<li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li>
<li>实现Clonable接口，覆盖并重写clone()，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> Test <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>		Test newBody = (Test) <span class="hljs-keyword">super</span>.clone();<br>		newBody.arr = arr.clone();    <span class="hljs-comment">// 深拷贝实现</span><br>		<span class="hljs-keyword">return</span> newBody;<br>	&#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure>
开发中常用的对象拷贝工具：<br>例如DozerMapper、Apache BeanUtils、Spring、Jodd BeanUtils、甚至是Cglib 都提供了这样的功能</li>
</ul>
<p>选择Cglib的 BeanCopier 进行Bean拷贝的理由是，其性能要比 **Spring的BeanUtils <strong>，</strong>Apache的BeanUtils **和 PropertyUtils 要好很多，尤其是数据量比较大的情况下</p>
<p>Cglib 的beans 包 操作:</p>
<ul>
<li>BeanCopier：用于两个bean之间，同名属性间的拷贝。</li>
<li>BulkBean：用于两个bean之间，自定义get&amp;set方法间的拷贝。</li>
<li>BeanMap：针对POJO Bean与Map对象间的拷贝。</li>
<li>BeanGenerator：根据Map&lt;String,Class&gt;properties的属性定义，动态生成POJO Bean类。</li>
</ul>
<h3 id="9-this关键字的使用"><a href="#9-this关键字的使用" class="headerlink" title="9.this关键字的使用"></a>9.this关键字的使用</h3><p>在一个类中，用来区分形参和类属性（在形参和类属性同名时）。不同名时可以不使用。加上 this 表示是当前对象或者是当前正在创建的对象。可以使用 “this.属性” 或者 “this.方法” 。<br>使用实例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bank</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">bank</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">bank</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name ;<br>        <span class="hljs-keyword">this</span>.age = age ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setString</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>        age = a ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="9-1-this调用构造函数"><a href="#9-1-this调用构造函数" class="headerlink" title="9.1 this调用构造函数"></a>9.1 this调用构造函数</h4><p>在一个类的构造函数中，可以再去调用此类的其他构造函数。<br>用法：this(参数列表)；</p>
<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bank</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">bank</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">bank</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>();<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">bank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;sdf&quot;</span>,<span class="hljs-number">23</span>);<br>        System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>第二个构造函数中调用了第一个构造函数；第三个构造函数调用了第二个构造函数。<br><strong>注意：</strong></p>
<blockquote>
<ol>
<li>构造函数中不能再调用自己。</li>
<li>构造函数之间的调用不能形成环（死循环）。</li>
<li>一个类中如果有 n 个构造函数，则最多有 n-1 个构造函数中可以使用 this(参数列表) 去调用其他的构造函数。</li>
<li>一个构造函数中的调用声明必须在当前构造函数的首行。</li>
<li>一个构造函数中只能使用一次 this(参数列表) ，即只能调用一次其他构造函数。（否则就违法了第4条）</li>
</ol>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JAVA/">JAVA</a>
                    
                  </div>
                
                
              </div>
              <!-- 
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
               -->
              <p class="note note-warning">
                <strong>本文作者: </strong><a href="/">墨水的记忆</a> <br>
                <strong>本文链接: </strong><a href="https://tothefor.com/DragonOne/1509981974.html">https://tothefor.com/DragonOne/1509981974.html</a> <br>
                <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                   </p>
                   
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/DragonOne/2054008573.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JAVA基础知识复习(四)-数组</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/DragonOne/3705173716.html">
                        <span class="hidden-mobile">JAVA基础知识复习(三)-Character类</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "jx7bocft2eNXc79VRkkkNmhT-gzGzoHsz",
          app_key: "tL3DrseUcom3imP7y6HAnTfh",
          placeholder: "无需登录，匿名评论。  \n客官，来说点什么吧！(*╹▽╹*)",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://img-blog.csdnimg.cn/19499a592ed54c44a65f3913367ee966.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">   </br>  <p align="center">	(*╹▽╹*)ﾞ您的鼓励是我最大的动力。ヾ(◍°∇°◍)ﾉ</p>
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="javascript:" rel="nofollow noopener"><span>墨水记忆</span></a> <i class="iconfont icon-love"></i> <a href="javascript:" rel="nofollow noopener"><span>DragonOne</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="javascript:" rel="nofollow noopener">
        最好的记忆不如最淡的墨水
      </a>
    </span>
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?952d55c20fecac468ce267fb5ef10df9";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- 雪花特效 -->
<!-- <script type="text/javascript" src="\js\snow.js"></script> -->
<!--单击显示文字-->
<script type="text/javascript" src="/js/click_show_text.js"></script>
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/styles/backgroundize.css" />
  <!-- hexo injector body_end end --></body>
</html>
